This is the structure and content of a Java Maven project. My goal is to [...Describe your objective here...]. Please analyze the code for inconsistencies, suggest improvements, and complete any missing parts.

## Project Structure

```
    |-- .dockerignore
    |-- .gitattributes
    |-- .gitignore
    |-- Dockerfile
    |-- Makefile
    |-- docker-compose.yml
    |-- mvnw
    |-- mvnw.cmd
    |-- pom.xml
    |-- rental_api_snapshot.txt
    |-- start-docker.sh
|-- .mvn/
    |-- wrapper/
        |-- maven-wrapper.properties
|-- scripts/
    |-- init-keyspace.cql
|-- src/
    |-- main/
        |-- java/
            |-- inc/
                |-- yowyob/
                    |-- rental_api_reactive/
                        |-- RentalApiReactiveApplication.java
                        |-- application/
                            |-- dto/
                                |-- Money.java
                                |-- OrganizationType.java
                                |-- PaymentMethod.java
                                |-- Permission.java
                                |-- RoleType.java
                                |-- SubscriptionStatus.java
                                |-- TimeSlot.java
                                |-- UserType.java
                                |-- WorkingHours.java
                            |-- service/
                                |-- AgencyReactiveService.java
                                |-- AuthReactiveService.java
                                |-- AuthorizationReactiveService.java
                                |-- DriverReactiveService.java
                                |-- MultiTenantReactiveService.java
                                |-- OnboardingReactiveService.java
                                |-- OrganizationReactiveService.java
                                |-- PasswordReactiveService.java
                                |-- PermissionCacheReactiveService.java
                                |-- PermissionReactiveService.java
                                |-- PersonnelReactiveService.java
                                |-- RoleReactiveService.java
                                |-- SubscriptionPlanReactiveService.java
                                |-- SubscriptionValidationReactiveService.java
                                |-- UserDetailsReactiveService.java
                                |-- UserReactiveService.java
                                |-- UserRoleReactiveService.java
                        |-- infrastructure/
                            |-- config/
                                |-- AppProperties.java
                                |-- DefaultRoleConfiguration.java
                                |-- OpenApiConfig.java
                                |-- ReactiveConfiguration.java
                                |-- ReactiveSecurityConfig.java
                                |-- SubscriptionPlanDataInitializer.java
                                |-- WebConfig.java
                            |-- security/
                                |-- CustomPermissionEvaluator.java
                                |-- UserPrincipal.java
                                |-- config/
                                    |-- CustomAuthenticationManager.java
                                    |-- MethodSecurityConfig.java
                                    |-- ReactiveSecurityContextRepository.java
                                |-- filter/
                                    |-- MultiTenantSecurityFilter.java
                                |-- jwt/
                                    |-- JwtAuthenticationWebFilter.java
                                    |-- JwtReactiveTokenProvider.java
                                |-- model/
                                    |-- TokenContext.java
                                    |-- UserPrincipal.java
                            |-- web/
                                |-- controller/
                                    |-- AgencyReactiveController.java
                                    |-- AuthReactiveController.java
                                    |-- DriverReactiveController.java
                                    |-- HealthReactiveController.java
                                    |-- OnboardingReactiveController.java
                                    |-- OrganizationReactiveController.java
                                    |-- PermissionReactiveController.java
                                    |-- PersonnelReactiveController.java
                                    |-- RoleReactiveController.java
                                    |-- SubscriptionPlanReactiveController.java
                                    |-- UserProfileReactiveController.java
                                    |-- UserReactiveController.java
                                    |-- UserRoleReactiveController.java
                                |-- dto/
                                    |-- AgencyBusinessSettings.java
                                    |-- AgencyCountResponse.java
                                    |-- AgencyRedirectInfo.java
                                    |-- AgencyResponse.java
                                    |-- AgencyStatisticsRequest.java
                                    |-- AgencyStatisticsResponse.java
                                    |-- ApiResponse.java
                                    |-- AssignRoleRequest.java
                                    |-- AuthResponse.java
                                    |-- ChangePasswordRequest.java
                                    |-- CheckMultiplePermissionsRequest.java
                                    |-- CloneRoleRequest.java
                                    |-- CreateAgencyRequest.java
                                    |-- CreateDriverRequest.java
                                    |-- CreateOrganizationRequest.java
                                    |-- CreatePersonnelRequest.java
                                    |-- CreateRoleRequest.java
                                    |-- DeactivateAccountRequest.java
                                    |-- DriverResponse.java
                                    |-- EmployeeInfoResponse.java
                                    |-- ExtendRoleExpirationRequest.java
                                    |-- ForgotPasswordRequest.java
                                    |-- LoginRequest.java
                                    |-- MultiplePermissionCheckResponse.java
                                    |-- NotificationSettingsRequest.java
                                    |-- OnboardingCompletedResponse.java
                                    |-- OnboardingCompletionResponse.java
                                    |-- OnboardingOrganizationRequest.java
                                    |-- OnboardingOwnerRequest.java
                                    |-- OnboardingResponse.java
                                    |-- OnboardingSessionResponse.java
                                    |-- OnboardingSubscriptionRequest.java
                                    |-- OrganizationDashboardResponse.java
                                    |-- OrganizationInfoRequest.java
                                    |-- OrganizationPolicies.java
                                    |-- OrganizationResponse.java
                                    |-- OrganizationSettings.java
                                    |-- OrganizationStatisticsRequest.java
                                    |-- OrganizationStatisticsResponse.java
                                    |-- OwnerInfoRequest.java
                                    |-- PermissionCheckResponse.java
                                    |-- PermissionComparisonResponse.java
                                    |-- PermissionResponse.java
                                    |-- PersonnelResponse.java
                                    |-- RefreshTokenRequest.java
                                    |-- RegisterRequest.java
                                    |-- ResetPasswordRequest.java
                                    |-- ResourceLimitInfo.java
                                    |-- ResourcePermissionsResponse.java
                                    |-- RolePermissionsResponse.java
                                    |-- RoleResponse.java
                                    |-- SecurityContext.java
                                    |-- SubscriptionChangeValidation.java
                                    |-- SubscriptionInfoRequest.java
                                    |-- SubscriptionLimitsResponse.java
                                    |-- SubscriptionResponse.java
                                    |-- SubscriptionValidationResult.java
                                    |-- TenantFilter.java
                                    |-- UpdateAgencyRequest.java
                                    |-- UpdateDriverRequest.java
                                    |-- UpdateOrganizationRequest.java
                                    |-- UpdatePersonnelRequest.java
                                    |-- UpdateProfileRequest.java
                                    |-- UpdateRoleRequest.java
                                    |-- UpdateSubscriptionRequest.java
                                    |-- UserPermissionsResponse.java
                                    |-- UserPreferencesRequest.java
                                    |-- UserResponse.java
                                    |-- UserRoleResponse.java
                                    |-- UserStatsResponse.java
                                    |-- WorkingHoursInfo.java
                                |-- exception/
                                    |-- GlobalReactiveExceptionHandler.java
                        |-- persistence/
                            |-- config/
                                |-- CassandraReactiveConfig.java
                            |-- converter/
                                |-- JsonStringToMapConverter.java
                                |-- MapToJsonStringConverter.java
                            |-- entity/
                                |-- Agency.java
                                |-- BaseEntity.java
                                |-- Driver.java
                                |-- OnboardingSession.java
                                |-- Organization.java
                                |-- OrganizationSubscription.java
                                |-- Role.java
                                |-- SubscriptionPlan.java
                                |-- User.java
                                |-- UserRole.java
                            |-- mapper/
                                |-- AgencyMapper.java
                                |-- DriverMapper.java
                                |-- DtoMapper.java
                                |-- OrganizationMapper.java
                                |-- RoleMapper.java
                                |-- UserRoleMapper.java
                            |-- repository/
                                |-- AgencyReactiveRepository.java
                                |-- DriverReactiveRepository.java
                                |-- OnboardingSessionReactiveRepository.java
                                |-- OrganizationReactiveRepository.java
                                |-- OrganizationSubscriptionReactiveRepository.java
                                |-- RoleReactiveRepository.java
                                |-- SubscriptionPlanReactiveRepository.java
                                |-- UserReactiveRepository.java
                                |-- UserRoleReactiveRepository.java
        |-- resources/
            |-- application.properties
    |-- test/
        |-- java/
            |-- inc/
                |-- yowyob/
                    |-- rental_api_reactive/
                        |-- RentalApiReactiveApplicationTests.java
                        |-- application/
                            |-- service/
                                |-- OnboardingReactiveServiceTest.java
                                |-- OrganizationReactiveServiceTest.java
                                |-- PermissionReactiveServiceTest.java
                                |-- RoleReactiveServiceTest.java
                                |-- SubscriptionPlanReactiveServiceTest.java
                                |-- UserReactiveServiceTest.java
                                |-- UserRoleReactiveServiceTest.java
                        |-- infrastructure/
                            |-- config/
                                |-- TestDataBuilder.java
                            |-- web/
                                |-- controller/
                                    |-- HealthReactiveControllerTest.java
                                    |-- OrganizationReactiveControllerTest.java
                                    |-- UserReactiveControllerTest.java
                        |-- integration/
                            |-- OnboardingIntegrationTest.java
```

## File Contents

--- PATH: .dockerignore ---

```
# Ignorer les fichiers non nécessaires pour Docker

# Target directory
target/

# IDE files
.idea/
*.iml
.vscode/
.eclipse/

# OS files
.DS_Store
Thumbs.db

# Git
.git/
.gitignore

# Documentation
README.md
*.md

# Docker files (pas besoin dans l'image)
Dockerfile
docker-compose.yml
.dockerignore

# Scripts
start-docker.sh
*.sh

# Logs
*.log
logs/

# Temporary files
*.tmp
*.temp

# Maven wrapper (optionnel, on peut le garder)
# .mvn/
# mvnw
# mvnw.cmd
```

--- PATH: .gitattributes ---

```
/mvnw text eol=lf
*.cmd text eol=crlf
```

--- PATH: .gitignore ---

```
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
```

--- PATH: Dockerfile ---

```
# Multi-stage build pour optimiser l'image
FROM eclipse-temurin:21-jdk-alpine AS build

# Installer Maven
RUN apk add --no-cache maven

# Définir le répertoire de travail
WORKDIR /app

# Copier les fichiers Maven pour la résolution des dépendances
COPY pom.xml .
COPY .mvn .mvn
COPY mvnw .
COPY mvnw.cmd .

# Rendre mvnw exécutable
RUN chmod +x mvnw

# Télécharger les dépendances (mise en cache des layers)
RUN ./mvnw dependency:go-offline -B

# Copier le code source
COPY src src

# Construire l'application
RUN ./mvnw clean package -DskipTests

# ============================================================
# Runtime stage
# ============================================================
FROM eclipse-temurin:21-jre-alpine

# Installer curl pour health checks
RUN apk add --no-cache curl

# Créer un utilisateur non-root pour la sécurité
RUN addgroup -g 1001 -S rental && \
    adduser -u 1001 -S rental -G rental

# Définir le répertoire de travail
WORKDIR /app

# Copier le JAR depuis le stage de build
COPY --from=build /app/target/rental-api-reactive-*.jar app.jar

# Créer le répertoire des uploads
RUN mkdir -p /app/uploads && \
    chown -R rental:rental /app

# Changer vers l'utilisateur non-root
USER rental

# Exposer le port
EXPOSE 8080

# Variables d'environnement par défaut
ENV JAVA_OPTS="-Xms512m -Xmx1024m" \
    TZ=Africa/Douala

# Health check spécifique à WebFlux
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/api/v1/health || exit 1

# Point d'entrée
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

--- PATH: Makefile ---

```
.PHONY: help docker-start docker-stop docker-build docker-logs docker-clean

help: ## Affiche cette aide
	@echo "Commandes Docker disponibles:"
	@echo "  docker-start     - Démarre ScyllaDB + initialisation"
	@echo "  docker-app       - Démarre l'application complète"
	@echo "  docker-stop      - Arrête tous les services"
	@echo "  docker-build     - Reconstruit l'image de l'application"
	@echo "  docker-logs      - Affiche les logs"
	@echo "  docker-clean     - Nettoie tout (conteneurs + volumes)"

docker-start: ## Démarre seulement ScyllaDB
	@echo "Démarrage de ScyllaDB..."
	@chmod +x start-docker.sh && ./start-docker.sh

docker-app: ## Démarre l'application complète
	@echo "Démarrage de l'application complète..."
	@docker-compose up -d

docker-stop: ## Arrête tous les services
	@echo "Arrêt des services..."
	@docker-compose down

docker-build: ## Reconstruit l'image de l'application
	@echo "Construction de l'image..."
	@docker-compose build rental-api

docker-logs: ## Affiche les logs de tous les services
	@docker-compose logs -f

docker-logs-app: ## Affiche les logs de l'application
	@docker-compose logs -f rental-api

docker-logs-db: ## Affiche les logs de ScyllaDB
	@docker-compose logs -f scylladb

docker-clean: ## Nettoie tout (conteneurs + volumes)
	@echo "Nettoyage complet..."
	@docker-compose down -v --remove-orphans
	@docker system prune -f

docker-ps: ## Affiche le statut des conteneurs
	@docker-compose ps

docker-shell-app: ## Ouvre un shell dans l'application
	@docker-compose exec rental-api sh

docker-shell-db: ## Ouvre cqlsh dans ScyllaDB
	@docker-compose exec scylladb cqlsh

# Commandes classiques
start: docker-start
stop: docker-stop
clean: docker-clean

# Commandes Maven classiques
build: ## Compile le projet
	@echo "Compilation du projet..."
	@mvn clean compile

test: ## Lance les tests
	@echo "Exécution des tests..."
	@mvn test

package: ## Package l'application
	@echo "Packaging de l'application..."
	@mvn clean package -DskipTests

run: ## Démarre l'application sans Docker
	@echo "Démarrage de l'application..."
	@mvn spring-boot:run
```

--- PATH: docker-compose.yml ---

```yaml
version: '3.8'

services:
    # ============================================================
    # SERVICE SCYLLADB
    # ============================================================
    scylladb:
        image: scylladb/scylla:5.2
        container_name: rental-scylladb
        restart: unless-stopped
        command: --seeds=scylladb --smp 1 --memory 750M --overprovisioned 1 --api-address 0.0.0.0
        ports:
            - "9042:9042"
            - "9160:9160"
            - "10000:10000"
        volumes:
            - scylla_data:/var/lib/scylla
            - ./scripts/init-keyspace.cql:/opt/init-keyspace.cql
        environment:
            - SCYLLA_CLUSTER_NAME=rental-cluster
            - SCYLLA_DC=datacenter1
            - SCYLLA_RACK=rack1
        healthcheck:
            test: ["CMD-SHELL", "cqlsh -e 'DESCRIBE KEYSPACES'"]
            interval: 30s
            timeout: 10s
            retries: 10
            start_period: 60s
        networks:
            - rental-network

    # ============================================================
    # SERVICE INIT SCYLLA (pour créer le keyspace)
    # ============================================================
    scylla-init:
        image: scylladb/scylla:5.2
        container_name: rental-scylla-init
        depends_on:
            scylladb:
                condition: service_healthy
        volumes:
            - ./scripts/init-keyspace.cql:/init-keyspace.cql
        command: >
            sh -c "
              echo 'Attente de ScyllaDB...' &&
              sleep 10 &&
              echo 'Création du keyspace rental...' &&
              cqlsh scylladb -f /init-keyspace.cql &&
              echo 'Keyspace créé avec succès!'
            "
        networks:
            - rental-network
        restart: "no"

    # ============================================================
    # SERVICE APPLICATION SPRING BOOT (optionnel)
    # ============================================================
    rental-api:
        build: .
        container_name: rental-api-app
        depends_on:
            scylla-init:
                condition: service_completed_successfully
        ports:
            - "8080:8080"
        environment:
            - SPRING_CASSANDRA_CONTACT_POINTS=scylladb
            - SPRING_CASSANDRA_PORT=9042
            - SPRING_CASSANDRA_KEYSPACE_NAME=rental
            - SPRING_CASSANDRA_LOCAL_DATACENTER=datacenter1
            - SPRING_CASSANDRA_USERNAME=cassandra
            - SPRING_CASSANDRA_PASSWORD=cassandra
            - JAVA_OPTS=-Xms256m -Xmx512m
        healthcheck:
            test: ["CMD-SHELL", "curl -f http://localhost:8080/api/v1/health || exit 1"]
            interval: 30s
            timeout: 10s
            retries: 5
            start_period: 90s
        networks:
            - rental-network
        restart: unless-stopped

# ============================================================
# VOLUMES ET RÉSEAUX
# ============================================================
volumes:
    scylla_data:
        driver: local

networks:
    rental-network:
        driver: bridge
```

--- PATH: mvnw ---

```
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"
```

--- PATH: mvnw.cmd ---

```
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
```

--- PATH: pom.xml ---

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.4</version> <!-- Version stable au lieu de SNAPSHOT -->
        <relativePath/>
    </parent>

    <groupId>inc.yowyob</groupId>
    <artifactId>rental-api-reactive</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>rental-api-reactive</name>
    <description>API réactive pour le projet de location de véhicules</description>

    <properties>
        <java.version>21</java.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
        <jjwt.version>0.12.5</jjwt.version>
        <springdoc.version>2.5.0</springdoc.version>
        <cassandra.version>4.18.1</cassandra.version>
        <testcontainers.version>1.19.8</testcontainers.version>
        <reactor-test.version>3.6.0</reactor-test.version>
        <reactor-core.version>3.6.0</reactor-core.version>
        <reactor-netty.version>1.1.13</reactor-netty.version>
        <assertj.version>3.24.2</assertj.version>
    </properties>

    <dependencies>

        <!-- ======================================= -->
        <!-- REACTIVE WEB STACK                      -->
        <!-- ======================================= -->

        <!-- Spring Boot WebFlux (Reactive Web) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

        <!-- Spring Boot Reactive Security -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- ======================================= -->
        <!-- REACTIVE DATA ACCESS                     -->
        <!-- ======================================= -->

        <!-- Spring Data Reactive Cassandra -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-cassandra-reactive</artifactId>
        </dependency>

        <!-- Driver Cassandra amélioré -->
        <dependency>
            <groupId>org.apache.cassandra</groupId>
            <artifactId>java-driver-core</artifactId>
            <version>${cassandra.version}</version>
        </dependency>

        <!-- Support Reactive Streams -->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-core</artifactId>
        </dependency>

        <!-- Reactor Netty pour les clients HTTP réactifs -->
        <dependency>
            <groupId>io.projectreactor.netty</groupId>
            <artifactId>reactor-netty-http</artifactId>
        </dependency>

        <!-- ======================================= -->
        <!-- VALIDATION & SERIALIZATION              -->
        <!-- ======================================= -->

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>

        <!-- Support JSON reactive -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>

        <!-- ======================================= -->
        <!-- SECURITY & JWT                          -->
        <!-- ======================================= -->

        <!-- JWT - Version mise à jour -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- ======================================= -->
        <!-- MAPPING & TRANSFORMATION                -->
        <!-- ======================================= -->

        <!-- MapStruct pour mapping Entity/DTO -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>

        <!-- ======================================= -->
        <!-- DOCUMENTATION API                       -->
        <!-- ======================================= -->

        <!-- SpringDoc OpenAPI 3 pour WebFlux -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- ======================================= -->
        <!-- MONITORING & OBSERVABILITY              -->
        <!-- ======================================= -->

        <!-- Actuator pour monitoring réactif -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <!-- Micrometer pour métriques -->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>

        <!-- ======================================= -->
        <!-- UTILITIES                               -->
        <!-- ======================================= -->

        <!-- Lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Spring Aspects pour AOP -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-aspects</artifactId>
        </dependency>

        <!-- ======================================= -->
        <!-- TESTING - CORRECTED                     -->
        <!-- ======================================= -->

        <!-- Spring Boot Test Starter (inclut JUnit 5, Mockito, AssertJ, etc.) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Reactor Test pour tests réactifs -->
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Spring Security Test -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Testcontainers BOM pour éviter les conflits de versions -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers-bom</artifactId>
            <version>${testcontainers.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>

        <!-- Testcontainers Core -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>testcontainers</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Testcontainers JUnit 5 -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Testcontainers Cassandra -->
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>cassandra</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- JUnit 5 Platform -->
        <dependency>
            <groupId>org.junit.platform</groupId>
            <artifactId>junit-platform-launcher</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- AssertJ pour des assertions fluides -->
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Hamcrest pour des matchers supplémentaires -->
        <dependency>
            <groupId>org.hamcrest</groupId>
            <artifactId>hamcrest</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Mockito Core (déjà inclus dans spring-boot-starter-test mais explicite) -->
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Mockito JUnit Jupiter -->
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- JsonPath pour tester les réponses JSON -->
        <dependency>
            <groupId>com.jayway.jsonpath</groupId>
            <artifactId>json-path</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testng</groupId>
            <artifactId>testng</artifactId>
            <version>RELEASE</version>
            <scope>compile</scope>
        </dependency>

    </dependencies>

    <!-- ======================================= -->
    <!-- DEPENDENCY MANAGEMENT                    -->
    <!-- ======================================= -->
    <dependencyManagement>
        <dependencies>
            <!-- Testcontainers BOM -->
            <dependency>
                <groupId>org.testcontainers</groupId>
                <artifactId>testcontainers-bom</artifactId>
                <version>${testcontainers.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <!-- Spring Boot Maven Plugin -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>

            <!-- MapStruct Annotation Processor -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.12.1</version>
                <configuration>
                    <source>21</source>
                    <target>21</target>
                    <compilerArgs>
                        <arg>-Amapstruct.verbose=true</arg>  <!-- Activer le mode verbeux -->
                    </compilerArgs>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                             <scope>provided</scope>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>

            <!-- Surefire Plugin pour tests unitaires -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.2.5</version>
                <configuration>
                    <systemPropertyVariables>
                        <spring.profiles.active>test</spring.profiles.active>
                    </systemPropertyVariables>
                    <includes>
                        <include>**/*Test.java</include>
                        <include>**/*Tests.java</include>
                    </includes>
                    <excludes>
                        <exclude>**/*IntegrationTest.java</exclude>
                    </excludes>
                </configuration>
            </plugin>

            <!-- Failsafe Plugin pour tests d'intégration -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-failsafe-plugin</artifactId>
                <version>3.2.5</version>
                <configuration>
                    <includes>
                        <include>**/*IntegrationTest.java</include>
                        <include>**/*IT.java</include>
                    </includes>
                    <systemPropertyVariables>
                        <spring.profiles.active>test</spring.profiles.active>
                    </systemPropertyVariables>
                </configuration>
                <executions>
                    <execution>
                        <goals>
                            <goal>integration-test</goal>
                            <goal>verify</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <!-- JaCoCo pour la couverture de code -->
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>0.8.11</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

        </plugins>
    </build>

</project>
```

--- PATH: rental_api_snapshot.txt ---

```
# File content ignored because its size exceeds 2 MB.
```

--- PATH: start-docker.sh ---

```shell
#!/bin/bash

echo "🚀 Démarrage du projet Rental API Reactive avec Docker"

# Couleurs pour les logs
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${GREEN}[$(date +'%H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERREUR]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[ATTENTION]${NC} $1"
}

# Vérifier Docker
if ! command -v docker &> /dev/null; then
    error "Docker n'est pas installé"
    exit 1
fi

if ! command -v docker-compose &> /dev/null; then
    error "Docker Compose n'est pas installé"
    exit 1
fi

# Créer le dossier scripts s'il n'existe pas
mkdir -p scripts

# Créer le fichier init-keyspace.cql s'il n'existe pas
if [ ! -f scripts/init-keyspace.cql ]; then
    log "Création du script d'initialisation ScyllaDB..."
    cat > scripts/init-keyspace.cql << 'EOF'
-- Création du keyspace rental
CREATE KEYSPACE IF NOT EXISTS rental
WITH REPLICATION = {
    'class': 'SimpleStrategy',
    'replication_factor': 1
};

USE rental;
EOF
fi

# Arrêter les conteneurs existants
log "Arrêt des conteneurs existants..."
docker-compose down

# Démarrer seulement ScyllaDB et l'initialisation
log "🗄️ Démarrage de ScyllaDB..."
docker-compose up -d scylladb scylla-init

# Attendre que l'initialisation soit terminée
log "⏳ Attente de l'initialisation de ScyllaDB..."
docker-compose logs -f scylla-init &
LOGS_PID=$!

# Attendre que le service scylla-init soit terminé
while [ "$(docker-compose ps -q scylla-init)" ]; do
    sleep 2
done

kill $LOGS_PID 2>/dev/null

# Vérifier si l'initialisation a réussi
if [ "$(docker-compose ps scylla-init --format json | jq -r '.[0].State')" = "exited" ]; then
    log "✅ ScyllaDB initialisé avec succès"
else
    error "❌ Échec de l'initialisation de ScyllaDB"
    docker-compose logs scylla-init
    exit 1
fi

# Option pour démarrer l'application
read -p "Voulez-vous démarrer l'application Spring Boot ? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    log "🚀 Démarrage de l'application..."
    docker-compose up -d rental-api

    log "⏳ Attente que l'application soit prête..."
    for i in {1..60}; do
        if curl -s http://localhost:8080/api/v1/health > /dev/null 2>&1; then
            break
        fi
        echo -n "."
        sleep 2
    done
    echo ""

    if curl -s http://localhost:8080/api/v1/health > /dev/null 2>&1; then
        log "✅ Application démarrée avec succès!"
        echo ""
        echo -e "${BLUE} URLs importantes:${NC}"
        echo " Application: http://localhost:8080"
        echo " Swagger UI: http://localhost:8080/swagger-ui.html"
        echo " Health: http://localhost:8080/api/v1/health"
        echo " ScyllaDB: localhost:9042"
        echo ""
        echo -e "${BLUE} Commandes Docker utiles:${NC}"
        echo "docker-compose logs -f rental-api    # Logs de l'app"
        echo "docker-compose logs -f scylladb      # Logs de ScyllaDB"
        echo "docker-compose down                  # Arrêter tout"
        echo "docker-compose ps                    # Statut des services"
    else
        error "❌ L'application n'a pas pu démarrer"
        docker-compose logs rental-api
    fi
else
    log "✅ ScyllaDB prêt. Vous pouvez maintenant démarrer votre application avec:"
    echo "mvn spring-boot:run"
    echo ""
    echo "ou avec Docker:"
    echo "docker-compose up -d rental-api"
fi
```

--- PATH: .mvn\wrapper\maven-wrapper.properties ---

```properties
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip
```

--- PATH: scripts\init-keyspace.cql ---

```
-- Création du keyspace rental
CREATE KEYSPACE IF NOT EXISTS rental
    WITH REPLICATION = {
        'class': 'SimpleStrategy',
        'replication_factor': 1
        };

-- Utiliser le keyspace
USE rental;

-- Message de confirmation
-- Le keyspace 'rental' a été créé avec succès

-- Les tables seront créées automatiquement par Spring Data Cassandra
-- avec l'option spring.cassandra.schema-action=CREATE_IF_NOT_EXISTS
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\RentalApiReactiveApplication.java ---

```java
package inc.yowyob.rental_api_reactive;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RentalApiReactiveApplication {

	public static void main(String[] args) {
		SpringApplication.run(RentalApiReactiveApplication.class, args);
	}

}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\Money.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Money {

    @JsonProperty("amount")
    private BigDecimal amount;

    @JsonProperty("currency")
    private String currency; // Ex: "XAF", "EUR", "USD"
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\OrganizationType.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;

/**
 * Énumération des types d'organisations
 */
@Getter
public enum OrganizationType {
    /**
     * Entreprise de location de véhicules
     */
    @JsonProperty("CAR_RENTAL")
    CAR_RENTAL("CAR_RENTAL", "Location de véhicules", "Entreprise spécialisée dans la location de véhicules", "#3b82f6"),

    /**
     * Service de transport avec chauffeur
     */
    @JsonProperty("TRANSPORT_SERVICE")
    TRANSPORT_SERVICE("TRANSPORT_SERVICE", "Service de transport", "Service de transport avec chauffeur", "#10b981"),

    /**
     * Autopartage
     */
    @JsonProperty("CAR_SHARING")
    CAR_SHARING("CAR_SHARING", "Autopartage", "Service d'autopartage et de véhicules partagés", "#f59e0b"),

    /**
     * Flotte d'entreprise
     */
    @JsonProperty("FLEET_MANAGEMENT")
    FLEET_MANAGEMENT("FLEET_MANAGEMENT", "Gestion de flotte", "Gestion de flotte d'entreprise", "#8b5cf6"),

    /**
     * Location longue durée
     */
    @JsonProperty("LONG_TERM_RENTAL")
    LONG_TERM_RENTAL("LONG_TERM_RENTAL", "Location longue durée", "Location de véhicules longue durée", "#06b6d4"),

    /**
     * Service de livraison
     */
    @JsonProperty("DELIVERY_SERVICE")
    DELIVERY_SERVICE("DELIVERY_SERVICE", "Service de livraison", "Service de livraison et transport de marchandises", "#ef4444"),

    /**
     * Agence de voyage
     */
    @JsonProperty("TRAVEL_AGENCY")
    TRAVEL_AGENCY("TRAVEL_AGENCY", "Agence de voyage", "Agence de voyage avec services de transport", "#ec4899"),

    /**
     * Location d'équipements
     */
    @JsonProperty("EQUIPMENT_RENTAL")
    EQUIPMENT_RENTAL("EQUIPMENT_RENTAL", "Location d'équipements", "Location d'équipements et véhicules spécialisés", "#84cc16"),

    /**
     * Autre type d'organisation
     */
    @JsonProperty("OTHER")
    OTHER("OTHER", "Autre", "Autre type d'organisation", "#6b7280");

    private final String code;
    private final String displayName;
    private final String description;
    private final String color;

    OrganizationType(String code, String displayName, String description, String color) {
        this.code = code;
        this.displayName = displayName;
        this.description = description;
        this.color = color;
    }

    /**
     * Obtient le type d'organisation par son code
     */
    public static OrganizationType fromCode(String code) {
        for (OrganizationType type : values()) {
            if (type.getCode().equals(code)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Type d'organisation invalide: " + code);
    }

    /**
     * Vérifie si le type est lié au transport
     */
    public boolean isTransportRelated() {
        return this == TRANSPORT_SERVICE ||
            this == CAR_SHARING ||
            this == DELIVERY_SERVICE ||
            this == TRAVEL_AGENCY;
    }

    /**
     * Vérifie si le type est lié à la location
     */
    public boolean isRentalRelated() {
        return this == CAR_RENTAL ||
            this == LONG_TERM_RENTAL ||
            this == EQUIPMENT_RENTAL ||
            this == CAR_SHARING;
    }

    /**
     * Vérifie si le type nécessite une gestion de flotte
     */
    public boolean requiresFleetManagement() {
        return this == FLEET_MANAGEMENT ||
            this == TRANSPORT_SERVICE ||
            this == DELIVERY_SERVICE;
    }

    /**
     * Obtient les limites par défaut selon le type d'organisation
     */
    public OrganizationLimits getDefaultLimits() {
        switch (this) {
            case CAR_RENTAL:
                return new OrganizationLimits(5, 50, 20, 15);
            case TRANSPORT_SERVICE:
                return new OrganizationLimits(3, 30, 50, 25);
            case CAR_SHARING:
                return new OrganizationLimits(10, 100, 10, 20);
            case FLEET_MANAGEMENT:
                return new OrganizationLimits(1, 200, 100, 50);
            case LONG_TERM_RENTAL:
                return new OrganizationLimits(3, 80, 15, 12);
            case DELIVERY_SERVICE:
                return new OrganizationLimits(5, 50, 100, 30);
            case TRAVEL_AGENCY:
                return new OrganizationLimits(2, 20, 30, 10);
            case EQUIPMENT_RENTAL:
                return new OrganizationLimits(3, 40, 10, 8);
            default:
                return new OrganizationLimits(1, 10, 5, 5);
        }
    }

    /**
     * Classe interne pour les limites d'organisation
     */
    public static class OrganizationLimits {
        private final int maxAgencies;
        private final int maxVehicles;
        private final int maxDrivers;
        private final int maxUsers;

        public OrganizationLimits(int maxAgencies, int maxVehicles, int maxDrivers, int maxUsers) {
            this.maxAgencies = maxAgencies;
            this.maxVehicles = maxVehicles;
            this.maxDrivers = maxDrivers;
            this.maxUsers = maxUsers;
        }

        public int getMaxAgencies() { return maxAgencies; }
        public int getMaxVehicles() { return maxVehicles; }
        public int getMaxDrivers() { return maxDrivers; }
        public int getMaxUsers() { return maxUsers; }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\PaymentMethod.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

public enum PaymentMethod {
    @JsonProperty("MTN_MONEY")
    MTN_MONEY,

    @JsonProperty("ORANGE_MONEY")
    ORANGE_MONEY,

    @JsonProperty("CARD")
    CARD,

    @JsonProperty("BANK_TRANSFER")
    BANK_TRANSFER,

    @JsonProperty("CASH")
    CASH
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\Permission.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;

@Getter
public enum Permission {
    // === PERMISSIONS VÉHICULES ===
    @JsonProperty("vehicle_read")
    VEHICLE_READ("vehicle_read", "Lire les informations des véhicules", "VEHICLE"),
    @JsonProperty("vehicle_write")
    VEHICLE_WRITE("vehicle_write", "Créer de nouveaux véhicules", "VEHICLE"),
    @JsonProperty("vehicle_update")
    VEHICLE_UPDATE("vehicle_update", "Modifier les véhicules existants", "VEHICLE"),
    @JsonProperty("vehicle_delete")
    VEHICLE_DELETE("vehicle_delete", "Supprimer des véhicules", "VEHICLE"),
    @JsonProperty("vehicle_manage_images")
    VEHICLE_MANAGE_IMAGES("vehicle_manage_images", "Gérer les images des véhicules", "VEHICLE"),
    @JsonProperty("vehicle_change_status")
    VEHICLE_CHANGE_STATUS("vehicle_change_status", "Changer le statut des véhicules", "VEHICLE"),

    // === PERMISSIONS CHAUFFEURS ===
    @JsonProperty("driver_read")
    DRIVER_READ("driver_read", "Lire les informations des chauffeurs", "DRIVER"),
    @JsonProperty("driver_write")
    DRIVER_WRITE("driver_write", "Créer de nouveaux chauffeurs", "DRIVER"),
    @JsonProperty("driver_update")
    DRIVER_UPDATE("driver_update", "Modifier les chauffeurs existants", "DRIVER"),
    @JsonProperty("driver_delete")
    DRIVER_DELETE("driver_delete", "Supprimer des chauffeurs", "DRIVER"),
    @JsonProperty("driver_manage_documents")
    DRIVER_MANAGE_DOCUMENTS("driver_manage_documents", "Gérer les documents des chauffeurs", "DRIVER"),
    @JsonProperty("driver_manage_schedule")
    DRIVER_MANAGE_SCHEDULE("driver_manage_schedule", "Gérer les plannings des chauffeurs", "DRIVER"),

    // === PERMISSIONS LOCATIONS ===
    @JsonProperty("rental_read")
    RENTAL_READ("rental_read", "Lire les informations des locations", "RENTAL"),
    @JsonProperty("rental_write")
    RENTAL_WRITE("rental_write", "Créer de nouvelles locations", "RENTAL"),
    @JsonProperty("rental_update")
    RENTAL_UPDATE("rental_update", "Modifier les locations existantes", "RENTAL"),
    @JsonProperty("rental_delete")
    RENTAL_DELETE("rental_delete", "Supprimer des locations", "RENTAL"),
    @JsonProperty("rental_approve")
    RENTAL_APPROVE("rental_approve", "Approuver les demandes de location", "RENTAL"),
    @JsonProperty("rental_cancel")
    RENTAL_CANCEL("rental_cancel", "Annuler des locations", "RENTAL"),
    @JsonProperty("rental_extend")
    RENTAL_EXTEND("rental_extend", "Prolonger des locations", "RENTAL"),

    // === PERMISSIONS UTILISATEURS ===
    @JsonProperty("user_read")
    USER_READ("user_read", "Lire les informations des utilisateurs", "USER"),
    @JsonProperty("user_write")
    USER_WRITE("user_write", "Créer de nouveaux utilisateurs", "USER"),
    @JsonProperty("user_update")
    USER_UPDATE("user_update", "Modifier les utilisateurs existants", "USER"),
    @JsonProperty("user_delete")
    USER_DELETE("user_delete", "Supprimer des utilisateurs", "USER"),
    @JsonProperty("user_manage_roles")
    USER_MANAGE_ROLES("user_manage_roles", "Gérer les rôles des utilisateurs", "USER"),
    @JsonProperty("user_reset_password")
    USER_RESET_PASSWORD("user_reset_password", "Réinitialiser les mots de passe", "USER"),

    // === PERMISSIONS AGENCES ===
    @JsonProperty("agency_read")
    AGENCY_READ("agency_read", "Lire les informations des agences", "AGENCY"),
    @JsonProperty("agency_write")
    AGENCY_WRITE("agency_write", "Créer de nouvelles agences", "AGENCY"),
    @JsonProperty("agency_update")
    AGENCY_UPDATE("agency_update", "Modifier les agences existantes", "AGENCY"),
    @JsonProperty("agency_delete")
    AGENCY_DELETE("agency_delete", "Supprimer des agences", "AGENCY"),
    @JsonProperty("agency_manage_staff")
    AGENCY_MANAGE_STAFF("agency_manage_staff", "Gérer le personnel des agences", "AGENCY"),

    // === PERMISSIONS ORGANISATIONS ===
    @JsonProperty("organization_read")
    ORGANIZATION_READ("organization_read", "Lire les informations de l'organisation", "ORGANIZATION"),
    @JsonProperty("organization_write")
    ORGANIZATION_WRITE("organization_write", "Créer de nouvelles organisations", "ORGANIZATION"),
    @JsonProperty("organization_update")
    ORGANIZATION_UPDATE("organization_update", "Modifier les informations de l'organisation", "ORGANIZATION"),
    @JsonProperty("organization_delete")
    ORGANIZATION_DELETE("organization_delete", "Supprimer des organisations", "ORGANIZATION"),
    @JsonProperty("organization_manage_settings")
    ORGANIZATION_MANAGE_SETTINGS("organization_manage_settings", "Gérer les paramètres de l'organisation", "ORGANIZATION"),
    @JsonProperty("organization_manage_subscription")
    ORGANIZATION_MANAGE_SUBSCRIPTION("organization_manage_subscription", "Gérer l'abonnement de l'organisation", "ORGANIZATION"),

    // === PERMISSIONS RÔLES ===
    @JsonProperty("role_read")
    ROLE_READ("role_read", "Lire les informations des rôles", "ROLE"),
    @JsonProperty("role_write")
    ROLE_WRITE("role_write", "Créer de nouveaux rôles", "ROLE"),
    @JsonProperty("role_update")
    ROLE_UPDATE("role_update", "Modifier les rôles existants", "ROLE"),
    @JsonProperty("role_delete")
    ROLE_DELETE("role_delete", "Supprimer des rôles", "ROLE"),
    @JsonProperty("role_assign_permissions")
    ROLE_ASSIGN_PERMISSIONS("role_assign_permissions", "Assigner des permissions aux rôles", "ROLE"),

    // === PERMISSIONS PAIEMENTS ===
    @JsonProperty("payment_read")
    PAYMENT_READ("payment_read", "Lire les informations des paiements", "PAYMENT"),
    @JsonProperty("payment_process")
    PAYMENT_PROCESS("payment_process", "Traiter les paiements", "PAYMENT"),
    @JsonProperty("payment_refund")
    PAYMENT_REFUND("payment_refund", "Effectuer des remboursements", "PAYMENT"),
    @JsonProperty("payment_view_details")
    PAYMENT_VIEW_DETAILS("payment_view_details", "Voir les détails des transactions", "PAYMENT"),

    // === PERMISSIONS RAPPORTS ===
    @JsonProperty("report_read")
    REPORT_READ("report_read", "Lire les rapports", "REPORT"),
    @JsonProperty("report_generate")
    REPORT_GENERATE("report_generate", "Générer des rapports", "REPORT"),
    @JsonProperty("report_export")
    REPORT_EXPORT("report_export", "Exporter des rapports", "REPORT"),
    @JsonProperty("report_advanced")
    REPORT_ADVANCED("report_advanced", "Accéder aux rapports avancés", "REPORT"),

    // === PERMISSIONS PARAMÈTRES ===
    @JsonProperty("settings_read")
    SETTINGS_READ("settings_read", "Lire les paramètres", "SETTINGS"),
    @JsonProperty("settings_write")
    SETTINGS_WRITE("settings_write", "Modifier les paramètres", "SETTINGS"),
    @JsonProperty("settings_manage_notifications")
    SETTINGS_MANAGE_NOTIFICATIONS("settings_manage_notifications", "Gérer les notifications", "SETTINGS"),

    // === PERMISSIONS SYSTÈME ===
    @JsonProperty("system_admin")
    SYSTEM_ADMIN("system_admin", "Administration complète du système", "SYSTEM"),
    @JsonProperty("system_backup")
    SYSTEM_BACKUP("system_backup", "Effectuer des sauvegardes", "SYSTEM"),
    @JsonProperty("system_logs")
    SYSTEM_LOGS("system_logs", "Accéder aux logs système", "SYSTEM"),
    @JsonProperty("system_monitoring")
    SYSTEM_MONITORING("system_monitoring", "Accéder au monitoring", "SYSTEM");

    private final String code;
    private final String description;
    private final String resource;

    Permission(String code, String description, String resource) {
        this.code = code;
        this.description = description;
        this.resource = resource;
    }

    /**
     * Vérifie si la permission concerne une ressource donnée
     */
    public boolean isForResource(String resourceName) {
        return this.resource.equalsIgnoreCase(resourceName);
    }

    /**
     * Obtient toutes les permissions pour une ressource
     */
    public static Permission[] getPermissionsForResource(String resourceName) {
        return java.util.Arrays.stream(Permission.values())
            .filter(permission -> permission.isForResource(resourceName))
            .toArray(Permission[]::new);
    }

    /**
     * Obtient toutes les ressources disponibles
     */
    public static String[] getAllResources() {
        return java.util.Arrays.stream(Permission.values())
            .map(Permission::getResource)
            .distinct()
            .toArray(String[]::new);
    }

    /**
     * Trouve une permission par son code
     */
    public static Permission fromCode(String code) {
        for (Permission permission : Permission.values()) {
            if (permission.getCode().equals(code)) {
                return permission;
            }
        }
        return null;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\RoleType.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;

/**
 * Énumération des types de rôles dans le système
 */
@Getter
public enum RoleType {
    /**
     * Super Administrateur - Accès complet à toute la plateforme
     */
    @JsonProperty("SUPER_ADMIN")
    SUPER_ADMIN("SUPER_ADMIN", "Super Administrateur", "Administrateur système avec accès complet à toute la plateforme", 100, true, "#dc2626", "crown"),

    /**
     * Propriétaire d'organisation - Accès complet à son organisation
     */
    @JsonProperty("ORGANIZATION_OWNER")
    ORGANIZATION_OWNER("ORGANIZATION_OWNER", "Propriétaire d'Organisation", "Propriétaire de l'organisation avec droits complets sur son organisation", 90, false, "#7c3aed", "building"),

    /**
     * Administrateur d'organisation - Gestion administrative de l'organisation
     */
    @JsonProperty("ORGANIZATION_ADMIN")
    ORGANIZATION_ADMIN("ORGANIZATION_ADMIN", "Administrateur d'Organisation", "Administrateur de l'organisation avec droits étendus", 80, false, "#059669", "settings"),

    /**
     * Manager d'agence - Gestion complète de son agence
     */
    @JsonProperty("AGENCY_MANAGER")
    AGENCY_MANAGER("AGENCY_MANAGER", "Manager d'Agence", "Gestionnaire d'agence avec droits complets sur son agence", 70, false, "#2563eb", "home"),

    /**
     * Agent de location - Gestion des locations et service client
     */
    @JsonProperty("RENTAL_AGENT")
    RENTAL_AGENT("RENTAL_AGENT", "Agent de Location", "Agent de location responsable des réservations et du service client", 50, false, "#ea580c", "user-check"),

    /**
     * Chauffeur - Accès aux missions assignées
     */
    @JsonProperty("DRIVER")
    DRIVER("DRIVER", "Chauffeur", "Chauffeur avec accès aux missions et planning", 30, false, "#0891b2", "car"),

    /**
     * Comptable - Gestion financière et paiements
     */
    @JsonProperty("ACCOUNTANT")
    ACCOUNTANT("ACCOUNTANT", "Comptable", "Comptable responsable de la gestion financière", 60, false, "#16a34a", "calculator"),

    /**
     * Gestionnaire de paiements - Traitement des paiements
     */
    @JsonProperty("PAYMENT_MANAGER")
    PAYMENT_MANAGER("PAYMENT_MANAGER", "Gestionnaire de Paiements", "Gestionnaire responsable du traitement des paiements", 55, false, "#ca8a04", "credit-card"),

    /**
     * Mécanicien - Maintenance des véhicules
     */
    @JsonProperty("MECHANIC")
    MECHANIC("MECHANIC", "Mécanicien", "Mécanicien responsable de la maintenance des véhicules", 40, false, "#dc2626", "wrench"),

    /**
     * Client - Utilisateur final qui loue des véhicules
     */
    @JsonProperty("CLIENT")
    CLIENT("CLIENT", "Client", "Utilisateur client avec accès aux fonctionnalités de location", 10, true, "#059669", "user"),

    /**
     * Rôle personnalisé - Créé par les organisations
     */
    @JsonProperty("CUSTOM")
    CUSTOM("CUSTOM", "Rôle Personnalisé", "Rôle personnalisé créé par l'organisation", 0, false, "#6b7280", "shield");

    private final String code;
    private final String displayName;
    private final String description;
    private final int priority;
    private final boolean isSystemRole;
    private final String defaultColor;
    private final String defaultIcon;

    RoleType(String code, String displayName, String description, int priority, boolean isSystemRole, String defaultColor, String defaultIcon) {
        this.code = code;
        this.displayName = displayName;
        this.description = description;
        this.priority = priority;
        this.isSystemRole = isSystemRole;
        this.defaultColor = defaultColor;
        this.defaultIcon = defaultIcon;
    }

    /**
     * Vérifie si ce type de rôle est un rôle système
     */
    public boolean isSystemRole() {
        return this.isSystemRole;
    }

    /**
     * Vérifie si ce type de rôle peut créer des rôles personnalisés
     */
    public boolean canCreateCustomRoles() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN;
    }

    /**
     * Vérifie si ce type de rôle peut gérer les utilisateurs
     */
    public boolean canManageUsers() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN || this == AGENCY_MANAGER;
    }

    /**
     * Vérifie si ce type de rôle peut gérer les agences
     */
    public boolean canManageAgencies() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN;
    }

    /**
     * Vérifie si ce type de rôle peut gérer les véhicules
     */
    public boolean canManageVehicles() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN || this == AGENCY_MANAGER;
    }

    /**
     * Vérifie si ce type de rôle peut traiter les locations
     */
    public boolean canProcessRentals() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN ||
            this == AGENCY_MANAGER || this == RENTAL_AGENT;
    }

    /**
     * Vérifie si ce type de rôle peut gérer les paiements
     */
    public boolean canManagePayments() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN ||
            this == AGENCY_MANAGER || this == ACCOUNTANT || this == PAYMENT_MANAGER;
    }

    /**
     * Vérifie si ce type de rôle peut accéder aux rapports
     */
    public boolean canAccessReports() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN ||
            this == AGENCY_MANAGER || this == ACCOUNTANT;
    }

    /**
     * Vérifie si ce type de rôle nécessite une agence assignée
     */
    public boolean requiresAgency() {
        return this == AGENCY_MANAGER || this == RENTAL_AGENT || this == DRIVER || this == MECHANIC;
    }

    /**
     * Vérifie si ce type de rôle est considéré comme du personnel
     */
    public boolean isPersonnel() {
        return this == AGENCY_MANAGER || this == RENTAL_AGENT || this == DRIVER ||
            this == MECHANIC || this == ACCOUNTANT || this == PAYMENT_MANAGER;
    }

    /**
     * Vérifie si ce type de rôle peut être assigné à des utilisateurs externes
     */
    public boolean canBeAssignedExternally() {
        return this != SUPER_ADMIN && this != CUSTOM;
    }

    /**
     * Obtient la hiérarchie des rôles supérieurs
     */
    public RoleType[] getSuperiorRoles() {
        return switch (this) {
            case SUPER_ADMIN -> new RoleType[]{};
            case ORGANIZATION_OWNER -> new RoleType[]{SUPER_ADMIN};
            case ORGANIZATION_ADMIN -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER};
            case AGENCY_MANAGER -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER, ORGANIZATION_ADMIN};
            case ACCOUNTANT, PAYMENT_MANAGER -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER, ORGANIZATION_ADMIN};
            case RENTAL_AGENT -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER, ORGANIZATION_ADMIN, AGENCY_MANAGER};
            case MECHANIC -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER, ORGANIZATION_ADMIN, AGENCY_MANAGER};
            case DRIVER -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER, ORGANIZATION_ADMIN, AGENCY_MANAGER, RENTAL_AGENT};
            case CLIENT -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER, ORGANIZATION_ADMIN, AGENCY_MANAGER, RENTAL_AGENT};
            case CUSTOM -> new RoleType[]{SUPER_ADMIN, ORGANIZATION_OWNER, ORGANIZATION_ADMIN};
        };
    }

    /**
     * Vérifie si ce rôle est supérieur à un autre rôle
     */
    public boolean isSuperiorTo(RoleType otherRole) {
        return this.priority > otherRole.priority;
    }

    /**
     * Vérifie si ce rôle est inférieur à un autre rôle
     */
    public boolean isInferiorTo(RoleType otherRole) {
        return this.priority < otherRole.priority;
    }

    /**
     * Vérifie si ce rôle a le même niveau qu'un autre rôle
     */
    public boolean isSameLevelAs(RoleType otherRole) {
        return this.priority == otherRole.priority;
    }

    /**
     * Trouve un type de rôle par son code
     */
    public static RoleType fromCode(String code) {
        for (RoleType roleType : RoleType.values()) {
            if (roleType.getCode().equals(code)) {
                return roleType;
            }
        }
        return null;
    }

    /**
     * Obtient tous les types de rôles système
     */
    public static RoleType[] getSystemRoles() {
        return java.util.Arrays.stream(RoleType.values())
            .filter(RoleType::isSystemRole)
            .toArray(RoleType[]::new);
    }

    /**
     * Obtient tous les types de rôles organisationnels (non-système)
     */
    public static RoleType[] getOrganizationalRoles() {
        return java.util.Arrays.stream(RoleType.values())
            .filter(roleType -> !roleType.isSystemRole() && roleType != CUSTOM)
            .toArray(RoleType[]::new);
    }

    /**
     * Obtient tous les types de rôles de personnel
     */
    public static RoleType[] getPersonnelRoles() {
        return java.util.Arrays.stream(RoleType.values())
            .filter(RoleType::isPersonnel)
            .toArray(RoleType[]::new);
    }

    /**
     * Obtient la description complète du rôle
     */
    public String getFullDescription() {
        return String.format("%s - %s (Priorité: %d)", displayName, description, priority);
    }

    /**
     * Vérifie si ce rôle peut modifier un autre rôle
     */
    public boolean canModifyRole(RoleType targetRole) {
        // Les rôles système ne peuvent pas être modifiés sauf par SUPER_ADMIN
        if (targetRole.isSystemRole() && this != SUPER_ADMIN) {
            return false;
        }

        // Un rôle peut modifier les rôles de priorité inférieure
        return this.isSuperiorTo(targetRole);
    }

    /**
     * Vérifie si ce rôle peut assigner un autre rôle
     */
    public boolean canAssignRole(RoleType targetRole) {
        // SUPER_ADMIN peut assigner tous les rôles
        if (this == SUPER_ADMIN) {
            return true;
        }

        // Les autres rôles ne peuvent pas assigner SUPER_ADMIN
        if (targetRole == SUPER_ADMIN) {
            return false;
        }

        // Un rôle peut assigner des rôles de priorité inférieure ou égale (sauf pour lui-même)
        return this.priority >= targetRole.priority && this != targetRole;
    }

    @Override
    public String toString() {
        return displayName;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\SubscriptionStatus.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

public enum SubscriptionStatus {
    @JsonProperty("ACTIVE")
    ACTIVE,

    @JsonProperty("SUSPENDED")
    SUSPENDED,

    @JsonProperty("EXPIRED")
    EXPIRED,

    @JsonProperty("CANCELLED")
    CANCELLED,

    @JsonProperty("PENDING_PAYMENT")
    PENDING_PAYMENT
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\TimeSlot.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TimeSlot {
    @JsonProperty("start_time")
    private LocalTime startTime;

    @JsonProperty("end_time")
    private LocalTime endTime;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\UserType.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Getter;

/**
 * Énumération des types d'utilisateurs dans le système
 */
@Getter
public enum UserType {
    /**
     * Super Administrateur - Gestionnaire de la plateforme
     */
    @JsonProperty("SUPER_ADMIN")
    SUPER_ADMIN("SUPER_ADMIN", "Super Administrateur", "Gestionnaire de la plateforme avec tous les privilèges", true, 100),

    /**
     * Propriétaire d'organisation - Créateur et gestionnaire d'organisation
     */
    @JsonProperty("ORGANIZATION_OWNER")
    ORGANIZATION_OWNER("ORGANIZATION_OWNER", "Propriétaire d'Organisation", "Propriétaire et gestionnaire principal de l'organisation", false, 90),

    /**
     * Administrateur d'organisation - Administrateur de l'organisation
     */
    @JsonProperty("ORGANIZATION_ADMIN")
    ORGANIZATION_ADMIN("ORGANIZATION_ADMIN", "Administrateur d'Organisation", "Administrateur avec droits étendus dans l'organisation", false, 80),

    /**
     * Manager d'agence - Gestionnaire d'agence
     */
    @JsonProperty("AGENCY_MANAGER")
    AGENCY_MANAGER("AGENCY_MANAGER", "Manager d'Agence", "Gestionnaire responsable d'une agence", false, 70),

    /**
     * Comptable - Gestionnaire financier
     */
    @JsonProperty("ACCOUNTANT")
    ACCOUNTANT("ACCOUNTANT", "Comptable", "Responsable de la gestion financière et comptable", false, 60),

    /**
     * Gestionnaire de paiements - Responsable des paiements
     */
    @JsonProperty("PAYMENT_MANAGER")
    PAYMENT_MANAGER("PAYMENT_MANAGER", "Gestionnaire de Paiements", "Responsable du traitement des paiements", false, 55),

    /**
     * Agent de location - Personnel de location
     */
    @JsonProperty("RENTAL_AGENT")
    RENTAL_AGENT("RENTAL_AGENT", "Agent de Location", "Agent responsable des locations et du service client", false, 50),

    /**
     * Mécanicien - Responsable de la maintenance
     */
    @JsonProperty("MECHANIC")
    MECHANIC("MECHANIC", "Mécanicien", "Responsable de la maintenance et réparation des véhicules", false, 40),

    /**
     * Chauffeur - Conducteur de véhicules
     */
    @JsonProperty("DRIVER")
    DRIVER("DRIVER", "Chauffeur", "Chauffeur professionnel assigné aux missions", false, 30),

    /**
     * Client - Utilisateur final
     */
    @JsonProperty("CLIENT")
    CLIENT("CLIENT", "Client", "Utilisateur final qui loue des véhicules", false, 10);

    private final String code;
    private final String displayName;
    private final String description;
    private final boolean isSystemAdmin;
    private final int hierarchyLevel;

    UserType(String code, String displayName, String description, boolean isSystemAdmin, int hierarchyLevel) {
        this.code = code;
        this.displayName = displayName;
        this.description = description;
        this.isSystemAdmin = isSystemAdmin;
        this.hierarchyLevel = hierarchyLevel;
    }

    /**
     * Obtient le niveau hiérarchique de ce type d'utilisateur
     * Plus le niveau est élevé, plus l'utilisateur a d'autorité
     */
    public int getHierarchyLevel() {
        return this.hierarchyLevel;
    }

    /**
     * Vérifie si ce type d'utilisateur est un administrateur système
     */
    public boolean isSystemAdmin() {
        return this.isSystemAdmin;
    }

    /**
     * Vérifie si ce type d'utilisateur est du personnel
     */
    public boolean isPersonnel() {
        return this == AGENCY_MANAGER || this == RENTAL_AGENT || this == DRIVER ||
            this == MECHANIC || this == ACCOUNTANT || this == PAYMENT_MANAGER;
    }

    /**
     * Vérifie si ce type d'utilisateur est un gestionnaire
     */
    public boolean isManager() {
        return this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN || this == AGENCY_MANAGER;
    }

    /**
     * Vérifie si ce type d'utilisateur peut gérer d'autres utilisateurs
     */
    public boolean canManageUsers() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER ||
            this == ORGANIZATION_ADMIN || this == AGENCY_MANAGER;
    }

    /**
     * Vérifie si ce type d'utilisateur nécessite une agence assignée
     */
    public boolean requiresAgency() {
        return this == AGENCY_MANAGER || this == RENTAL_AGENT || this == DRIVER || this == MECHANIC;
    }

    /**
     * Vérifie si ce type d'utilisateur peut créer des organisations
     */
    public boolean canCreateOrganizations() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER;
    }

    /**
     * Vérifie si ce type d'utilisateur peut accéder aux rapports financiers
     */
    public boolean canAccessFinancialReports() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER ||
            this == ORGANIZATION_ADMIN || this == ACCOUNTANT;
    }

    /**
     * Vérifie si ce type d'utilisateur peut traiter les paiements
     */
    public boolean canProcessPayments() {
        return this == SUPER_ADMIN || this == ORGANIZATION_OWNER || this == ORGANIZATION_ADMIN ||
            this == AGENCY_MANAGER || this == RENTAL_AGENT || this == ACCOUNTANT || this == PAYMENT_MANAGER;
    }

    /**
     * Vérifie si ce type d'utilisateur est supérieur hiérarchiquement à un autre
     */
    public boolean isSuperiorTo(UserType otherType) {
        return this.hierarchyLevel > otherType.hierarchyLevel;
    }

    /**
     * Vérifie si ce type d'utilisateur est inférieur hiérarchiquement à un autre
     */
    public boolean isInferiorTo(UserType otherType) {
        return this.hierarchyLevel < otherType.hierarchyLevel;
    }

    /**
     * Vérifie si ce type d'utilisateur est au même niveau hiérarchique qu'un autre
     */
    public boolean isSameLevelAs(UserType otherType) {
        return this.hierarchyLevel == otherType.hierarchyLevel;
    }

    /**
     * Vérifie si ce type d'utilisateur peut gérer un autre type d'utilisateur
     */
    public boolean canManage(UserType otherType) {
        // SUPER_ADMIN peut gérer tout le monde
        if (this == SUPER_ADMIN) {
            return true;
        }

        // Personne ne peut gérer SUPER_ADMIN sauf SUPER_ADMIN lui-même
        if (otherType == SUPER_ADMIN) {
            return false;
        }

        // Sinon, on peut gérer les types de niveau inférieur
        return this.isSuperiorTo(otherType);
    }

    /**
     * Obtient le RoleType correspondant à ce UserType
     */
    public RoleType getCorrespondingRoleType() {
        return switch (this) {
            case SUPER_ADMIN -> RoleType.SUPER_ADMIN;
            case ORGANIZATION_OWNER -> RoleType.ORGANIZATION_OWNER;
            case ORGANIZATION_ADMIN -> RoleType.ORGANIZATION_ADMIN;
            case AGENCY_MANAGER -> RoleType.AGENCY_MANAGER;
            case RENTAL_AGENT -> RoleType.RENTAL_AGENT;
            case DRIVER -> RoleType.DRIVER;
            case ACCOUNTANT -> RoleType.ACCOUNTANT;
            case PAYMENT_MANAGER -> RoleType.PAYMENT_MANAGER;
            case MECHANIC -> RoleType.MECHANIC;
            case CLIENT -> RoleType.CLIENT;
        };
    }

    /**
     * Trouve un type d'utilisateur par son code
     */
    public static UserType fromCode(String code) {
        for (UserType userType : UserType.values()) {
            if (userType.getCode().equals(code)) {
                return userType;
            }
        }
        return null;
    }

    /**
     * Trouve un type d'utilisateur par son niveau hiérarchique
     */
    public static UserType fromHierarchyLevel(int level) {
        for (UserType userType : UserType.values()) {
            if (userType.getHierarchyLevel() == level) {
                return userType;
            }
        }
        return null;
    }

    /**
     * Obtient tous les types d'utilisateurs personnel
     */
    public static UserType[] getPersonnelTypes() {
        return java.util.Arrays.stream(UserType.values())
            .filter(UserType::isPersonnel)
            .toArray(UserType[]::new);
    }

    /**
     * Obtient tous les types d'utilisateurs gestionnaires
     */
    public static UserType[] getManagerTypes() {
        return java.util.Arrays.stream(UserType.values())
            .filter(UserType::isManager)
            .toArray(UserType[]::new);
    }

    /**
     * Obtient tous les types d'utilisateurs qui nécessitent une agence
     */
    public static UserType[] getAgencyRequiredTypes() {
        return java.util.Arrays.stream(UserType.values())
            .filter(UserType::requiresAgency)
            .toArray(UserType[]::new);
    }

    /**
     * Obtient tous les types d'utilisateurs triés par niveau hiérarchique (décroissant)
     */
    public static UserType[] getByHierarchyDescending() {
        return java.util.Arrays.stream(UserType.values())
            .sorted((a, b) -> Integer.compare(b.hierarchyLevel, a.hierarchyLevel))
            .toArray(UserType[]::new);
    }

    /**
     * Obtient tous les types d'utilisateurs triés par niveau hiérarchique (croissant)
     */
    public static UserType[] getByHierarchyAscending() {
        return java.util.Arrays.stream(UserType.values())
            .sorted((a, b) -> Integer.compare(a.hierarchyLevel, b.hierarchyLevel))
            .toArray(UserType[]::new);
    }

    @Override
    public String toString() {
        return displayName;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\dto\WorkingHours.java ---

```java
package inc.yowyob.rental_api_reactive.application.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class WorkingHours {
    @JsonProperty("monday")
    private TimeSlot monday;

    @JsonProperty("tuesday")
    private TimeSlot tuesday;

    @JsonProperty("wednesday")
    private TimeSlot wednesday;

    @JsonProperty("thursday")
    private TimeSlot thursday;

    @JsonProperty("friday")
    private TimeSlot friday;

    @JsonProperty("saturday")
    private TimeSlot saturday;

    @JsonProperty("sunday")
    private TimeSlot sunday;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\AgencyReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.Agency;
import inc.yowyob.rental_api_reactive.persistence.entity.Organization;
import inc.yowyob.rental_api_reactive.persistence.repository.AgencyReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.OrganizationReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.mapper.AgencyMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Service réactif pour la gestion des agences
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AgencyReactiveService {

    private final AgencyReactiveRepository agencyRepository;
    private final OrganizationReactiveRepository organizationRepository;
    private final AgencyMapper agencyMapper;
    private final MultiTenantReactiveService multiTenantService;
    private final SubscriptionValidationReactiveService subscriptionValidationService;

    /**
     * Crée une nouvelle agence
     */
    public Mono<AgencyResponse> createAgency(CreateAgencyRequest createRequest, UUID createdBy) {
        log.info("Creating agency: {} for organization: {}",
            createRequest.getName(), createRequest.getOrganizationId());

        return validateAgencyCreation(createRequest.getOrganizationId())
            .then(checkAgencyNameUniqueness(createRequest.getOrganizationId(), createRequest.getName()))
            .then(organizationRepository.findById(createRequest.getOrganizationId()))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                Agency agency = createAgencyFromRequest(createRequest, createdBy);
                return agencyRepository.save(agency)
                    .flatMap(savedAgency -> {
                        // Incrémenter le compteur d'agences de l'organisation
                        organization.incrementAgencies();
                        return organizationRepository.save(organization)
                            .then(Mono.just(savedAgency));
                    });
            })
            .map(agencyMapper::toResponse)
            .doOnSuccess(response -> log.info("Agency created successfully: {}", response.getId()))
            .doOnError(error -> log.error("Error creating agency: {}", error.getMessage()));
    }

    /**
     * Met à jour une agence
     */
    public Mono<AgencyResponse> updateAgency(UUID agencyId, UpdateAgencyRequest updateRequest, UUID updatedBy) {
        log.info("Updating agency: {}", agencyId);

        return multiTenantService.validateAgencyAccess(agencyId, updatedBy)
            .then(agencyRepository.findById(agencyId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Agence non trouvée")))
            .flatMap(agency -> {
                updateAgencyFromRequest(agency, updateRequest, updatedBy);
                return agencyRepository.save(agency);
            })
            .map(agencyMapper::toResponse)
            .doOnSuccess(response -> log.info("Agency updated successfully: {}", response.getId()))
            .doOnError(error -> log.error("Error updating agency {}: {}", agencyId, error.getMessage()));
    }

    /**
     * Trouve une agence par ID
     */
    public Mono<AgencyResponse> findById(UUID agencyId) {
        log.debug("Finding agency by ID: {}", agencyId);

        return agencyRepository.findById(agencyId)
            .map(agencyMapper::toResponse)
            .doOnNext(agency -> log.debug("Found agency: {}", agency.getName()));
    }

    /**
     * Trouve toutes les agences d'une organisation
     */
    public Flux<AgencyResponse> findByOrganizationId(UUID organizationId) {
        log.debug("Finding agencies for organization: {}", organizationId);

        return agencyRepository.findByOrganizationId(organizationId)
            .map(agencyMapper::toResponse)
            .doOnNext(agency -> log.debug("Found agency: {}", agency.getName()));
    }

    /**
     * Trouve les agences actives d'une organisation
     */
    public Flux<AgencyResponse> findActiveByOrganizationId(UUID organizationId) {
        log.debug("Finding active agencies for organization: {}", organizationId);

        return agencyRepository.findActiveByOrganizationId(organizationId)
            .map(agencyMapper::toResponse)
            .doOnNext(agency -> log.debug("Found active agency: {}", agency.getName()));
    }

    /**
     * Trouve les agences par gestionnaire
     */
    public Flux<AgencyResponse> findByManagerId(UUID managerId) {
        log.debug("Finding agencies for manager: {}", managerId);

        return agencyRepository.findByManagerId(managerId)
            .map(agencyMapper::toResponse)
            .doOnNext(agency -> log.debug("Found agency managed by {}: {}", managerId, agency.getName()));
    }

    /**
     * Trouve les agences par ville et pays
     */
    public Flux<AgencyResponse> findByCityAndCountry(String city, String country) {
        log.debug("Finding agencies in {} - {}", city, country);

        return agencyRepository.findByCityAndCountry(city, country)
            .map(agencyMapper::toResponse)
            .doOnNext(agency -> log.debug("Found agency in {}: {}", city, agency.getName()));
    }

    /**
     * Supprime une agence (soft delete)
     */
    public Mono<Void> deleteAgency(UUID agencyId, UUID deletedBy) {
        log.info("Deleting agency: {}", agencyId);

        return multiTenantService.validateAgencyAccess(agencyId, deletedBy)
            .then(agencyRepository.findById(agencyId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Agence non trouvée")))
            .flatMap(agency -> {
                // Vérifier qu'aucun véhicule ou chauffeur n'est actif
                return validateAgencyDeletion(agencyId)
                    .then(organizationRepository.findById(agency.getOrganizationId()))
                    .flatMap(organization -> {
                        // Soft delete de l'agence
                        agency.setIsActive(false);

                        // Décrémenter le compteur d'agences de l'organisation
                        organization.decrementAgencies();

                        return agencyRepository.save(agency)
                            .then(organizationRepository.save(organization))
                            .then();
                    });
            })
            .doOnSuccess(v -> log.info("Agency deleted successfully: {}", agencyId))
            .doOnError(error -> log.error("Error deleting agency {}: {}", agencyId, error.getMessage()));
    }

    /**
     * Active/désactive une agence
     */
    public Mono<AgencyResponse> toggleAgencyStatus(UUID agencyId, boolean isActive, UUID updatedBy) {
        log.info("Toggling agency status: {} to {}", agencyId, isActive);

        return multiTenantService.validateAgencyAccess(agencyId, updatedBy)
            .then(agencyRepository.findById(agencyId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Agence non trouvée")))
            .flatMap(agency -> {
                agency.setIsActive(isActive);
                agency.preUpdate();
                return agencyRepository.save(agency);
            })
            .map(agencyMapper::toResponse)
            .doOnSuccess(response -> log.info("Agency status toggled: {} - {}",
                response.getId(), response.getIsActive()));
    }

    /**
     * Assigne un gestionnaire à une agence
     */
    public Mono<AgencyResponse> assignManager(UUID agencyId, UUID managerId, UUID assignedBy) {
        log.info("Assigning manager {} to agency {}", managerId, agencyId);

        return multiTenantService.validateAgencyAccess(agencyId, assignedBy)
            .then(multiTenantService.validateUserAccess(managerId, assignedBy))
            .then(agencyRepository.findById(agencyId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Agence non trouvée")))
            .flatMap(agency -> {
                agency.setManagerId(managerId);
                agency.preUpdate();
                return agencyRepository.save(agency);
            })
            .map(agencyMapper::toResponse)
            .doOnSuccess(response -> log.info("Manager assigned to agency: {}", response.getId()));
    }

    /**
     * Met à jour les statistiques d'une agence
     */
    public Mono<AgencyResponse> updateAgencyStatistics(UUID agencyId, AgencyStatisticsRequest statsRequest) {
        log.debug("Updating statistics for agency: {}", agencyId);

        return agencyRepository.findById(agencyId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Agence non trouvée")))
            .flatMap(agency -> {
                if (statsRequest.getVehicleStats() != null) {
                    agency.updateVehicleStats(
                        statsRequest.getVehicleStats().getTotal(),
                        statsRequest.getVehicleStats().getActive()
                    );
                }

                if (statsRequest.getDriverStats() != null) {
                    agency.updateDriverStats(
                        statsRequest.getDriverStats().getTotal(),
                        statsRequest.getDriverStats().getActive()
                    );
                }

                if (statsRequest.getPersonnelCount() != null) {
                    agency.updatePersonnelCount(statsRequest.getPersonnelCount());
                }

                if (statsRequest.getMonthlyRevenue() != null) {
                    agency.updateMonthlyRevenue(statsRequest.getMonthlyRevenue());
                }

                return agencyRepository.save(agency);
            })
            .map(agencyMapper::toResponse)
            .doOnSuccess(response -> log.debug("Statistics updated for agency: {}", response.getId()));
    }

    /**
     * Compte les agences d'une organisation
     */
    public Mono<Long> countByOrganizationId(UUID organizationId) {
        return agencyRepository.countByOrganizationId(organizationId);
    }

    /**
     * Compte les agences actives d'une organisation
     */
    public Mono<Long> countActiveByOrganizationId(UUID organizationId) {
        return agencyRepository.countActiveByOrganizationId(organizationId);
    }

    /**
     * Vérifie si une organisation peut créer une nouvelle agence
     */
    public Mono<Boolean> canCreateAgency(UUID organizationId) {
        return subscriptionValidationService.validateAgencyCreationLimit(organizationId);
    }

    /**
     * Trouve les agences avec réservation en ligne
     */
    public Flux<AgencyResponse> findAgenciesWithOnlineBooking() {
        return agencyRepository.findAgenciesWithOnlineBooking()
            .map(agencyMapper::toResponse);
    }

    /**
     * Trouve les agences dans une zone géographique
     */
    public Flux<AgencyResponse> findAgenciesInBounds(double minLat, double maxLat, double minLng, double maxLng) {
        return agencyRepository.findAgenciesInBounds(minLat, maxLat, minLng, maxLng)
            .map(agencyMapper::toResponse);
    }

    /**
     * Obtient les statistiques d'une agence
     */
    public Mono<AgencyStatisticsResponse> getAgencyStatistics(UUID agencyId) {
        return agencyRepository.findById(agencyId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Agence non trouvée")))
            .map(this::buildAgencyStatistics);
    }

    // === MÉTHODES PRIVÉES ===

    /**
     * Valide la création d'une agence
     */
    private Mono<Void> validateAgencyCreation(UUID organizationId) {
        return subscriptionValidationService.validateAgencyCreationLimit(organizationId)
            .flatMap(canCreate -> {
                if (!canCreate) {
                    return Mono.error(new IllegalArgumentException(
                        "Limite d'agences atteinte pour cette organisation"));
                }
                return Mono.empty();
            });
    }

    /**
     * Vérifie l'unicité du nom d'agence dans l'organisation
     */
    private Mono<Void> checkAgencyNameUniqueness(UUID organizationId, String name) {
        return agencyRepository.countByOrganizationIdAndName(organizationId, name)
            .flatMap(count -> {
                if (count > 0) {
                    return Mono.error(new IllegalArgumentException(
                        "Une agence avec ce nom existe déjà dans cette organisation"));
                }
                return Mono.empty();
            });
    }

    /**
     * Crée une agence à partir de la requête
     */
    private Agency createAgencyFromRequest(CreateAgencyRequest request, UUID createdBy) {
        Agency agency = new Agency(
            request.getOrganizationId(),
            request.getName(),
            request.getAddress(),
            request.getCity()
        );

        // Informations de base
        agency.setDescription(request.getDescription());
        agency.setCountry(request.getCountry() != null ? request.getCountry() : "CM");
        agency.setPostalCode(request.getPostalCode());
        agency.setRegion(request.getRegion());
        agency.setPhone(request.getPhone());
        agency.setEmail(request.getEmail());

        // Géolocalisation
        if (request.getLatitude() != null && request.getLongitude() != null) {
            agency.setLatitude(request.getLatitude());
            agency.setLongitude(request.getLongitude());
        }

        // Géofencing
        agency.setGeofenceZoneId(request.getGeofenceZoneId());
        agency.setGeofenceRadius(request.getGeofenceRadius());

        // Configuration
        agency.setIs24Hours(request.getIs24Hours() != null ? request.getIs24Hours() : false);
        agency.setManagerId(request.getManagerId());
        agency.setTimezone(request.getTimezone() != null ? request.getTimezone() : "Africa/Douala");
        agency.setCurrency(request.getCurrency() != null ? request.getCurrency() : "XAF");
        agency.setLanguage(request.getLanguage() != null ? request.getLanguage() : "fr");

        // Paramètres business
        if (request.getBusinessSettings() != null) {
            agency.setAllowOnlineBooking(request.getBusinessSettings().getAllowOnlineBooking());
            agency.setRequireDeposit(request.getBusinessSettings().getRequireDeposit());
            agency.setDepositPercentage(request.getBusinessSettings().getDepositPercentage());
            agency.setMinRentalHours(request.getBusinessSettings().getMinRentalHours());
            agency.setMaxAdvanceBookingDays(request.getBusinessSettings().getMaxAdvanceBookingDays());
        }

        // Horaires de travail (à stocker en JSON)
        if (request.getWorkingHours() != null) {
            agency.setWorkingHours(convertWorkingHoursToJson(request.getWorkingHours()));
        }

        return agency;
    }

    /**
     * Met à jour une agence à partir de la requête
     */
    private void updateAgencyFromRequest(Agency agency, UpdateAgencyRequest request, UUID updatedBy) {
        if (request.getName() != null) agency.setName(request.getName());
        if (request.getDescription() != null) agency.setDescription(request.getDescription());
        if (request.getAddress() != null) agency.setAddress(request.getAddress());
        if (request.getCity() != null) agency.setCity(request.getCity());
        if (request.getCountry() != null) agency.setCountry(request.getCountry());
        if (request.getPostalCode() != null) agency.setPostalCode(request.getPostalCode());
        if (request.getRegion() != null) agency.setRegion(request.getRegion());
        if (request.getPhone() != null) agency.setPhone(request.getPhone());
        if (request.getEmail() != null) agency.setEmail(request.getEmail());

        // Géolocalisation
        if (request.getLatitude() != null) agency.setLatitude(request.getLatitude());
        if (request.getLongitude() != null) agency.setLongitude(request.getLongitude());

        // Configuration
        if (request.getIs24Hours() != null) agency.setIs24Hours(request.getIs24Hours());
        if (request.getManagerId() != null) agency.setManagerId(request.getManagerId());
        if (request.getTimezone() != null) agency.setTimezone(request.getTimezone());

        // Paramètres business
        if (request.getBusinessSettings() != null) {
            if (request.getBusinessSettings().getAllowOnlineBooking() != null) {
                agency.setAllowOnlineBooking(request.getBusinessSettings().getAllowOnlineBooking());
            }
            if (request.getBusinessSettings().getRequireDeposit() != null) {
                agency.setRequireDeposit(request.getBusinessSettings().getRequireDeposit());
            }
            if (request.getBusinessSettings().getDepositPercentage() != null) {
                agency.setDepositPercentage(request.getBusinessSettings().getDepositPercentage());
            }
        }

        // Horaires de travail
        if (request.getWorkingHours() != null) {
            agency.setWorkingHours(convertWorkingHoursToJson(request.getWorkingHours()));
        }

        agency.preUpdate();
    }

    /**
     * Valide la suppression d'une agence
     */
    private Mono<Void> validateAgencyDeletion(UUID agencyId) {
        // Vérifier qu'il n'y a pas de véhicules actifs
        // Vérifier qu'il n'y a pas de chauffeurs actifs
        // Vérifier qu'il n'y a pas de locations en cours
        // TODO: Implémenter les vérifications avec les autres services
        return Mono.empty();
    }

    /**
     * Construit les statistiques d'une agence
     */
    private AgencyStatisticsResponse buildAgencyStatistics(Agency agency) {
        return AgencyStatisticsResponse.builder()
            .agencyId(agency.getId())
            .totalVehicles(agency.getTotalVehicles())
            .activeVehicles(agency.getActiveVehicles())
            .totalDrivers(agency.getTotalDrivers())
            .activeDrivers(agency.getActiveDrivers())
            .totalPersonnel(agency.getTotalPersonnel())
            .totalRentals(agency.getTotalRentals())
            .monthlyRevenue(agency.getMonthlyRevenue())
            .vehicleUtilizationRate(agency.getVehicleUtilizationRate())
            .driverActivityRate(agency.getDriverActivityRate())
            .lastUpdated(agency.getUpdatedAt())
            .build();
    }

    /**
     * Convertit les horaires de travail en JSON
     */
    private String convertWorkingHoursToJson(Object workingHours) {
        // TODO: Implémenter la conversion JSON
        // Utiliser ObjectMapper pour convertir en JSON
        return "{}"; // Placeholder
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\AuthReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.config.AppProperties;
import inc.yowyob.rental_api_reactive.infrastructure.security.jwt.JwtReactiveTokenProvider;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Service réactif d'authentification
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class AuthReactiveService {

    private final UserReactiveRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtReactiveTokenProvider jwtTokenProvider;
    private final AppProperties appProperties;
    private final PersonnelReactiveService personnelService;

    // Types d'utilisateurs considérés comme personnel
    private static final List<UserType> PERSONNEL_TYPES = Arrays.asList(
        UserType.AGENCY_MANAGER,
        UserType.RENTAL_AGENT
    );

    /**
     * Inscription d'un nouvel utilisateur
     */
    public Mono<AuthResponse> register(RegisterRequest registerRequest) {
        log.info("Registering new user: {}", registerRequest.getEmail());

        return userRepository.countByEmail(registerRequest.getEmail())
            .flatMap(count -> {
                if (count > 0) {
                    return Mono.error(new IllegalArgumentException("Email already exists"));
                }

                // Créer le nouvel utilisateur
                User user = new User();
                user.setId(UUID.randomUUID());
                user.setEmail(registerRequest.getEmail());
                user.setPassword(passwordEncoder.encode(registerRequest.getPassword()));
                user.setFirstName(registerRequest.getFirstName());
                user.setLastName(registerRequest.getLastName());
                user.setPhone(registerRequest.getPhone());
                user.setUserType(registerRequest.getUserType());
                user.setOrganizationId(registerRequest.getOrganizationId());
                user.setAgencyId(registerRequest.getAgencyId());
                user.setIsActive(true);
                user.setIsEmailVerified(false);
                user.setIsPhoneVerified(false);
                user.setCreatedAt(LocalDateTime.now());
                user.setUpdatedAt(LocalDateTime.now());

                // Générer token de vérification email
                user.setEmailVerificationToken(UUID.randomUUID().toString());

                return userRepository.save(user)
                    .flatMap(savedUser -> generateAuthResponse(savedUser))
                    .doOnSuccess(response -> log.info("User registered successfully: {}", registerRequest.getEmail()));
            });
    }

    /**
     * Connexion d'un utilisateur
     */
    public Mono<AuthResponse> login(LoginRequest loginRequest) {
        log.info("Login attempt for email: {}", loginRequest.getEmail());

        return userRepository.findByEmail(loginRequest.getEmail())
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Invalid email or password")))
            .flatMap(user -> {
                // Réinitialiser les tentatives échouées
                user.setLastLoginAt(LocalDateTime.now());
                user.setUpdatedAt(LocalDateTime.now());

                return userRepository.save(user)
                    .flatMap(savedUser -> {
                        // Vérifier si c'est du personnel
                        if (PERSONNEL_TYPES.contains(savedUser.getUserType())) {
                            return generatePersonnelAuthResponse(savedUser);
                        } else {
                            return generateAuthResponse(savedUser);
                        }
                    })
                    .doOnSuccess(response -> log.info("User logged in successfully: {}", loginRequest.getEmail()));
            });
    }

    /**
     * Génère une réponse d'authentification spécifique pour le personnel
     * avec informations de redirection vers l'agence
     */
    private Mono<AuthResponse> generatePersonnelAuthResponse(User user) {
        return Mono.zip(
            jwtTokenProvider.generateToken(user),
            jwtTokenProvider.generateRefreshToken(user),
            personnelService.getPersonnelAgencyInfo(user.getId())
        ).map(tuple -> {
            String accessToken = tuple.getT1();
            String refreshToken = tuple.getT2();
            AgencyRedirectInfo agencyInfo = tuple.getT3();

            UserResponse userResponse = mapToUserResponse(user);

            AuthResponse authResponse = AuthResponse.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .tokenType("Bearer")
                .expiresIn(appProperties.getJwt().getExpiration() / 1000)
                .user(userResponse)
                .build();

            // Construire l'URL de redirection
            if (agencyInfo.getAgencyId() != null) {
                String redirectUrl = String.format("/dashboard/agencies/%s", agencyInfo.getAgencyId());
                agencyInfo.setRedirectUrl(redirectUrl);
            } else {
                // Personnel non assigné à une agence - redirection vers organisation
                String redirectUrl = String.format("/dashboard/organizations/%s/unassigned-personnel",
                    agencyInfo.getOrganizationId());
                agencyInfo.setRedirectUrl(redirectUrl);
            }

            return authResponse;
        });
    }

    /**
     * Renouvellement du token
     */
    public Mono<AuthResponse> refreshToken(RefreshTokenRequest refreshRequest) {
        log.info("Refreshing token");

        return jwtTokenProvider.validateToken(refreshRequest.getRefreshToken())
            .flatMap(isValid -> {
                if (!isValid) {
                    return Mono.error(new IllegalArgumentException("Invalid refresh token"));
                }

                return jwtTokenProvider.getUserIdFromToken(refreshRequest.getRefreshToken())
                    .flatMap(userRepository::findById)
                    .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
                    .flatMap(user -> {
                        // Vérifier si c'est du personnel pour la réponse appropriée
                        if (PERSONNEL_TYPES.contains(user.getUserType())) {
                            return generatePersonnelAuthResponse(user);
                        } else {
                            return generateAuthResponse(user);
                        }
                    });
            });
    }

    /**
     * Changement de mot de passe
     */
    public Mono<ApiResponse<String>> changePassword(ChangePasswordRequest changeRequest, UUID userId) {
        log.info("Changing password for user: {}", userId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .flatMap(user -> {
                // Vérifier l'ancien mot de passe
                if (!passwordEncoder.matches(changeRequest.getCurrentPassword(), user.getPassword())) {
                    return Mono.error(new IllegalArgumentException("Current password is incorrect"));
                }

                // Mettre à jour avec le nouveau mot de passe
                user.setPassword(passwordEncoder.encode(changeRequest.getNewPassword()));
                user.setUpdatedAt(LocalDateTime.now());

                return userRepository.save(user)
                    .then(Mono.just(ApiResponse.<String>builder()
                        .success(true)
                        .message("Password changed successfully")
                        .data("Password updated")
                        .build()));
            });
    }

    /**
     * Demande de réinitialisation de mot de passe
     */
    public Mono<ApiResponse<String>> forgotPassword(ForgotPasswordRequest forgotRequest) {
        log.info("Password reset requested for email: {}", forgotRequest.getEmail());

        return userRepository.findByEmail(forgotRequest.getEmail())
            .flatMap(user -> {
                // Générer token de réinitialisation
                String resetToken = UUID.randomUUID().toString();
                user.setPasswordResetToken(resetToken);
                user.setUpdatedAt(LocalDateTime.now());

                return userRepository.save(user)
                    .then(Mono.just(ApiResponse.<String>builder()
                        .success(true)
                        .message("Password reset instructions sent to your email")
                        .data(resetToken) // En production, envoyer par email
                        .build()));
            })
            .switchIfEmpty(Mono.just(ApiResponse.<String>builder()
                .success(true)
                .message("If the email exists, you will receive reset instructions")
                .data(null)
                .build()));
    }

    /**
     * Réinitialisation du mot de passe
     */
    public Mono<ApiResponse<String>> resetPassword(ResetPasswordRequest resetRequest) {
        log.info("Resetting password with token");

        return userRepository.findByPasswordResetToken(resetRequest.getToken())
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Invalid or expired reset token")))
            .flatMap(user -> {

                // Mettre à jour le mot de passe
                user.setPassword(passwordEncoder.encode(resetRequest.getNewPassword()));
                user.setPasswordResetToken(null);
                user.setUpdatedAt(LocalDateTime.now());

                return userRepository.save(user)
                    .then(Mono.just(ApiResponse.<String>builder()
                        .success(true)
                        .message("Password reset successfully")
                        .data("Password updated")
                        .build()));
            });
    }

    /**
     * Vérification d'email
     */
    public Mono<ApiResponse<String>> verifyEmail(String token) {
        log.info("Verifying email with token");

        return userRepository.findByEmailVerificationToken(token)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Invalid verification token")))
            .flatMap(user -> {

                // Marquer l'email comme vérifié
                user.setIsEmailVerified(true);
                user.setEmailVerificationToken(null);
                user.setUpdatedAt(LocalDateTime.now());

                return userRepository.save(user)
                    .then(Mono.just(ApiResponse.<String>builder()
                        .success(true)
                        .message("Email verified successfully")
                        .data("Email verified")
                        .build()));
            });
    }

    /**
     * Récupération du profil utilisateur connecté
     */
    public Mono<ApiResponse<UserResponse>> getCurrentUser(UUID userId) {
        log.info("Getting current user profile: {}", userId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .map(user -> {
                UserResponse userResponse = mapToUserResponse(user);
                return ApiResponse.<UserResponse>builder()
                    .success(true)
                    .message("User profile retrieved successfully")
                    .data(userResponse)
                    .build();
            });
    }

    /**
     * Génère une réponse d'authentification avec tokens (utilisateurs classiques)
     */
    private Mono<AuthResponse> generateAuthResponse(User user) {
        return Mono.zip(
            jwtTokenProvider.generateToken(user),
            jwtTokenProvider.generateRefreshToken(user)
        ).map(tuple -> {
            String accessToken = tuple.getT1();
            String refreshToken = tuple.getT2();

            UserResponse userResponse = mapToUserResponse(user);

            AuthResponse authResponse = AuthResponse.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .tokenType("Bearer")
                .expiresIn(appProperties.getJwt().getExpiration() / 1000)
                .user(userResponse)
                .build();

            authResponse.setIsPersonnel(false);
            authResponse.setAgencyRedirectInfo(null);

            return authResponse;
        });
    }

    /**
     * Mappe une entité User vers UserResponse
     */
    private UserResponse mapToUserResponse(User user) {
        return UserResponse.builder()
            .id(user.getId())
            .email(user.getEmail())
            .firstName(user.getFirstName())
            .lastName(user.getLastName())
            .fullName(user.getFullName())
            .phone(user.getPhone())
            .userType(user.getUserType())
            .organizationId(user.getOrganizationId())
            .agencyId(user.getAgencyId())
            .profilePicture(user.getProfilePicture())
            .isEmailVerified(user.getIsEmailVerified())
            .isPhoneVerified(user.getIsPhoneVerified())
            .preferredLanguage(user.getPreferredLanguage())
            .timezone(user.getTimezone())
            .lastLoginAt(user.getLastLoginAt())
            .createdAt(user.getCreatedAt())
            .isActive(user.getIsActive())
            .address(user.getAddress())
            .city(user.getCity())
            .country(user.getCountry())
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\AuthorizationReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.dto.RoleType;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.SecurityContext;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.repository.UserRoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class AuthorizationReactiveService {

    private final UserRoleReactiveRepository userRoleRepository;
    private final RoleReactiveRepository roleRepository;
    private final PermissionReactiveService permissionService;

    /**
     * Vérifie si un utilisateur a une permission spécifique
     */
    public Mono<Boolean> hasPermission(UUID userId, String resource, String action) {
        String permission = resource + "_" + action;
        log.debug("Checking permission {}_{} for user: {}", resource, action, userId);

        return permissionService.hasPermission(userId, permission);
    }

    /**
     * Vérifie si un utilisateur peut accéder à une organisation
     */
    public Mono<Boolean> canAccessOrganization(UUID userId, UUID organizationId) {
        log.debug("Checking organization access for user {} to organization {}", userId, organizationId);

        return userRoleRepository.findActiveByUserId(userId)
            .any(userRole -> organizationId.equals(userRole.getOrganizationId()));
    }

    /**
     * Vérifie si un utilisateur peut accéder à une agence
     */
    public Mono<Boolean> canAccessAgency(UUID userId, UUID agencyId) {
        log.debug("Checking agency access for user {} to agency {}", userId, agencyId);

        return userRoleRepository.findActiveByUserId(userId)
            .any(userRole -> agencyId.equals(userRole.getAgencyId()) || userRole.getAgencyId() == null);
    }

    /**
     * Construit le contexte de sécurité pour un utilisateur
     */
    public Mono<SecurityContext> buildSecurityContext(User user) {
        log.debug("Building security context for user: {}", user.getId());

        return Mono.zip(
            getUserPermissions(user.getId()),
            getUserRoles(user.getId()),
            getUserOrganizations(user.getId())
        ).map(tuple -> SecurityContext.builder()
            .userId(user.getId())
            .email(user.getEmail())
            .organizationId(user.getOrganizationId())
            .permissions(tuple.getT1())
            .roles(tuple.getT2())
            .organizations(tuple.getT3())
            .isSuperAdmin(isSuperAdmin(tuple.getT2()))
            .build());
    }

    /**
     * Vérifie si un utilisateur est super administrateur
     */
    public Mono<Boolean> isSuperAdmin(UUID userId) {
        return getUserRoles(userId)
            .map(this::isSuperAdmin);
    }

    /**
     * Vérifie les permissions hiérarchiques
     */
    public Mono<Boolean> hasHierarchicalPermission(UUID userId, String permission, UUID targetOrganizationId) {
        log.debug("Checking hierarchical permission {} for user {} in organization {}",
            permission, userId, targetOrganizationId);

        return userRoleRepository.findActiveByUserId(userId)
            .flatMap(userRole -> roleRepository.findById(userRole.getRoleId()))
            .filter(Objects::nonNull)
            .any(role -> {
                // Super admin a toutes les permissions
                if (RoleType.SUPER_ADMIN.equals(role.getRoleType())) {
                    return true;
                }

                // Organization owner peut tout faire dans son organisation
                if (RoleType.ORGANIZATION_OWNER.equals(role.getRoleType()) &&
                    targetOrganizationId.equals(role.getOrganizationId())) {
                    return true;
                }

                // Vérifier la permission spécifique
                return role.getPermissions() != null && role.getPermissions().contains(permission);
            });
    }

    private Mono<Set<String>> getUserPermissions(UUID userId) {
        return userRoleRepository.findActiveByUserId(userId)
            .flatMap(userRole -> roleRepository.findById(userRole.getRoleId()))
            .filter(Objects::nonNull)
            .map(role -> role.getPermissions())
            .reduce(new HashSet<>(), (acc, permissions) -> {
                if (permissions != null) {
                    acc.addAll(permissions);
                }
                return acc;
            });
    }

    private Mono<Set<String>> getUserRoles(UUID userId) {
        return userRoleRepository.findActiveByUserId(userId)
            .flatMap(userRole -> roleRepository.findById(userRole.getRoleId()))
            .filter(Objects::nonNull)
            .map(role -> role.getRoleType().name())
            .collect(HashSet::new, Set::add);
    }

    private Mono<Set<UUID>> getUserOrganizations(UUID userId) {
        return userRoleRepository.findActiveByUserId(userId)
            .map(userRole -> userRole.getOrganizationId())
            .collect(HashSet::new, Set::add);
    }

    private boolean isSuperAdmin(Set<String> roles) {
        return roles.contains(RoleType.SUPER_ADMIN.name());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\DriverReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.dto.UserType;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.CreateDriverRequest;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.DriverResponse;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.UpdateDriverRequest;
import inc.yowyob.rental_api_reactive.persistence.entity.Driver;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.mapper.DriverMapper;
import inc.yowyob.rental_api_reactive.persistence.repository.DriverReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.NoSuchElementException;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class DriverReactiveService {

    private final DriverReactiveRepository driverReactiveRepository;
    private final UserReactiveRepository userReactiveRepository;
    private final DriverMapper driverMapper;
    private final SubscriptionValidationReactiveService subscriptionValidationService;

    /**
     * Crée un nouveau profil de chauffeur pour un utilisateur existant.
     *
     * @param createDto DTO contenant les informations de création.
     * @param createdBy ID de l'utilisateur effectuant la création.
     * @return Le DTO du chauffeur nouvellement créé, encapsulé dans un Mono.
     */
    @Transactional // Utilisez @Transactional pour les opérations en base de données.
    public Mono<DriverResponse> createDriver(CreateDriverRequest createDto, UUID createdBy) {
        log.info("Creating driver for user ID {} by user {}", createDto.getUserId(), createdBy);

        // 1. Valider les données d'entrée. Cette étape est *cruciale*.
        if (createDto.getUserId() == null) {
            return Mono.error(new IllegalArgumentException("User ID cannot be null."));
        }
        if (createDto.getOrganizationId() == null) {
            return Mono.error(new IllegalArgumentException("Organization ID cannot be null."));
        }
        if (createDto.getAge() < 18) {
            return Mono.error(new IllegalArgumentException("Driver must be at least 18 years old."));
        }
        // Ajoutez d'autres validations ici si nécessaire (ex: format de licenseNumber).

        // 2. Vérifier que l'utilisateur existe.
        // Utilisez flatMap pour enchaîner l'opération si l'utilisateur existe.
        return userReactiveRepository.findById(createDto.getUserId())
                .switchIfEmpty(
                        Mono.error(new NoSuchElementException("User not found with ID: " + createDto.getUserId())))
                .flatMap(user -> {
                    // Vérifier que l'utilisateur est de type personnel pour la création d'un driver
                    if (user.getUserType() != UserType.DRIVER) {
                        return Mono.error(new IllegalArgumentException(
                                "User with ID " + createDto.getUserId() + " is not a staff member."));
                    }
                    // 3. Vérifier si cet utilisateur est déjà un chauffeur (utiliser flatMap)
                    return driverReactiveRepository.findByUserId(createDto.getUserId())
                            .flatMap(existingDriver -> Mono
                                    .error(new IllegalStateException("This user is already registered as a driver.")))
                            .switchIfEmpty(Mono.just(user)) // Si le pilote n'existe pas, on continue avec
                                                            // l'utilisateur.
                            // 4. Valider la limite de création de chauffeurs (si une organisation est
                            // fournie)
                            .flatMap(userFromStep2 -> {
                                if (createDto.getOrganizationId() != null) {
                                    return subscriptionValidationService
                                            .validateDriverCreationLimit(createDto.getOrganizationId())
                                            .flatMap(canCreate -> {
                                                if (!canCreate) {
                                                    return Mono.error(new IllegalStateException(
                                                            "Driver creation limit reached for this organization."));
                                                }
                                                return Mono.just(userFromStep2);
                                            });
                                }
                                return Mono.just(userFromStep2); // Continue si aucune organisation n'est fournie
                            })

                            // 5. Créer l'entité Driver
                            .flatMap(user -> {
                                Driver driver = Driver.builder()
                                        .driverId(UUID.randomUUID())
                                        .userId(createDto.getUserId())
                                        .organizationId(createDto.getOrganizationId())
                                        .agencyId(createDto.getAgencyId())
                                        .dateOfBirth(createDto.getDateOfBirth())
                                        .licenseNumber(createDto.getLicenseNumber())
                                        .licenseType(createDto.getLicenseType())
                                        .licenseExpiry(createDto.getLicenseExpiry())
                                        .experience(createDto.getExperience())
                                        .employeeId(createDto.getEmployeeId())
                                        .cni(createDto.getCni())
                                        .position(createDto.getPosition())
                                        .department(createDto.getDepartment())
                                        .staffStatus(createDto.getStaffStatus())
                                        .hourlyRate(createDto.getHourlyRate())
                                        .workingHours(createDto.getWorkingHours())
                                        .hireDate(createDto.getHireDate())
                                        .createdAt(LocalDateTime.now())
                                        .updatedAt(LocalDateTime.now())
                                        .statusUpdatedBy(createdBy) // L'initiateur du statut
                                        .build();

                                return driverReactiveRepository.save(driver);
                            })
                            // 6. Mapper vers le DTO et retourner
                            .flatMap(savedDriver -> {
                                return userReactiveRepository.findById(savedDriver.getUserId()) // Récupérer
                                                                                                // l'utilisateur associé
                                                                                                // pour le mappage
                                        .map(user -> driverMapper.toDto(savedDriver, user));
                            })

                            .doOnSuccess(
                                    s -> log.info("Driver created successfully for user ID {}", createDto.getUserId()))
                            .doOnError(e -> log.warn("Could not create driver for user ID {} because {}",
                                    createDto.getUserId(), e.getMessage()))
                            .onErrorResume(throwable -> Mono.error(throwable)); // Propager l'erreur
                });
    }

    /**
     * Récupère un chauffeur par son ID.
     *
     * @param driverId L'ID du chauffeur.
     * @return Le DTO complet du chauffeur, encapsulé dans un Mono.
     */
    public Mono<DriverResponse> getDriverById(UUID driverId) {
        log.info("Fetching driver with ID {}", driverId);
        // Utilisez flatMap pour enchaîner les opérations
        return driverReactiveRepository.findById(driverId)
                .switchIfEmpty(Mono.error(new NoSuchElementException("Driver not found with ID: " + driverId)))
                .flatMap(driver -> userRepository.findById(driver.getUserId())
                        .switchIfEmpty(Mono.error(
                                new NoSuchElementException("Associated user not found for driver ID: " + driverId)))
                        .map(user -> buildFullDriverDto(driver, user)))
                .doOnSuccess(response -> log.info("Driver details retrieved: {}", driverId))
                .doOnError(error -> log.error("Failed to get driver: {}", driverId, error));
    }

    /**
     * Met à jour les informations d'un chauffeur existant.
     *
     * @param driverId  L'ID du chauffeur à mettre à jour.
     * @param updateDto DTO contenant les champs à modifier.
     * @param updatedBy ID de l'utilisateur qui effectue la mise à jour.
     * @return Le DTO du chauffeur mis à jour, encapsulé dans un Mono.
     */
    @Transactional
    public Mono<DriverResponse> updateDriver(UUID driverId, UpdateDriverRequest updateDto, UUID updatedBy) {
        log.info("Updating driver {} by user {}", driverId, updatedBy);

        // 1. Trouver le chauffeur
        return driverReactiveRepository.findById(driverId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Driver not found with ID: ")))
                .flatMap(driver -> {
                    // 2. Mettre à jour les champs (seulement ceux qui sont fournis)
                    if (updateDto.getPosition() != null)
                        driver.setPosition(updateDto.getPosition());
                    if (updateDto.getDepartment() != null)
                        driver.setDepartment(updateDto.getDepartment());
                    if (updateDto.getStaffStatus() != null)
                        driver.setStaffStatus(updateDto.getStaffStatus());
                    if (updateDto.getHourlyRate() != null)
                        driver.setHourlyRate(updateDto.getHourlyRate());
                    if (updateDto.getWorkingHours() != null)
                        driver.setWorkingHours(updateDto.getWorkingHours());
                    if (updateDto.getDateOfBirth() != null)
                        driver.setDateOfBirth(updateDto.getDateOfBirth());
                    if (updateDto.getLicenseNumber() != null)
                        driver.setLicenseNumber(updateDto.getLicenseNumber());
                    if (updateDto.getLicenseType() != null)
                        driver.setLicenseType(updateDto.getLicenseType());
                    if (updateDto.getLicenseExpiry() != null)
                        driver.setLicenseExpiry(updateDto.getLicenseExpiry());
                    if (updateDto.getExperience() != null)
                        driver.setExperience(updateDto.getExperience());

                    if (updateDto.getLocation() != null) {
                        driver.setLocation(updateDto.getLocation());
                    }
                    if (updateDto.getIdCardUrl() != null) {
                        driver.setIdCardUrl(updateDto.getIdCardUrl());
                    }
                    if (updateDto.getDriverLicenseUrl() != null) {
                        driver.setDriverLicenseUrl(updateDto.getDriverLicenseUrl());
                    }
                    if (updateDto.getAssignedVehicleIds() != null) {
                        driver.setAssignedVehicleIds(updateDto.getAssignedVehicleIds());
                    }
                    if (updateDto.getAvailable() != null) {
                        driver.setAvailable(updateDto.getAvailable());
                    }
                    if (updateDto.getRating() != null) {
                        driver.setRating(updateDto.getRating());
                    }
                    if (updateDto.getInsuranceProvider() != null) {
                        driver.setInsuranceProvider(updateDto.getInsuranceProvider());
                    }
                    if (updateDto.getInsurancePolicy() != null) {
                        driver.setInsurancePolicy(updateDto.getInsurancePolicy());
                    }
                    if (updateDto.getStatus() != null) {
                        driver.setStatus(updateDto.getStatus());
                        driver.setStatusUpdatedAt(LocalDateTime.now());
                        driver.setStatusUpdatedBy(updatedBy);
                    }

                    driver.setUpdatedAt(LocalDateTime.now());

                    // 3. Sauvegarder les modifications
                    return driverReactiveRepository.save(driver)
                            .flatMap(savedDriver -> userRepository.findById(savedDriver.getUserId()) // Retrieve user to
                                                                                                     // build response
                                    .map(user -> driverMapper.toDto(savedDriver, user)));
                })
                .doOnSuccess(response -> log.info("Driver {} updated successfully.", driverId))
                .doOnError(e -> log.warn("Could not update driver {} because {}", driverId, e.getMessage()))
                .onErrorResume(throwable -> Mono.error(throwable)); // Propager l'erreur
    }

    /**
     * Supprime un chauffeur.
     *
     * @param driverId L'ID du chauffeur à supprimer.
     */
    @Transactional
    public Mono<Void> deleteDriver(UUID driverId) {
        log.info("Deleting driver with ID {}", driverId);

        // Utilisez flatMap pour enchaîner les opérations
        return driverReactiveRepository.findById(driverId)
                .switchIfEmpty(Mono.error(new NoSuchElementException("Driver not found with ID: " + driverId)))
                .flatMap(driver -> driverReactiveRepository.delete(driver)) // Supprimer l'entité
                .doOnSuccess(v -> log.info("Driver with ID {} deleted successfully", driverId))
                .doOnError(error -> log.error("Failed to delete driver: {}", driverId, error));
    }

    // Méthode permettant de récupérer plusieurs chauffeurs
    public Flux<DriverResponse> getAllDrivers() {
        return ((Flux<DriverResponse>) driverReactiveRepository.findAll())
                .flatMap(driver -> userRepository.findById(driver.getUserId()) // Récupérer l'utilisateur associé
                        .map(user -> buildFullDriverDto(driver, user)));
    }

    /**
     * Méthode privée pour centraliser la construction du DTO complet
     */
    private DriverResponse buildFullDriverDto(Driver driver, User user) {
        return driverMapper.toDto(driver, user);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\MultiTenantReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.SecurityContext;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.TenantFilter;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.AgencyReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.OrganizationReactiveRepository;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.UUID;

/**
 * Service réactif pour la gestion multi-tenant
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class MultiTenantReactiveService {

    private final UserReactiveRepository userRepository;
    private final AgencyReactiveRepository agencyRepository;
    private final OrganizationReactiveRepository organizationRepository;
    private final AuthorizationReactiveService authorizationService;

    /**
     * Valide l'accès d'un utilisateur à une organisation
     */
    public Mono<Void> validateOrganizationAccess(UUID organizationId, UUID userId) {
        log.debug("Validating organization access for user {} to organization {}", userId, organizationId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .flatMap(user -> {
                // Super admin a accès à tout
                if (user.getUserType() == UserType.SUPER_ADMIN) {
                    return Mono.empty();
                }

                // Vérifier que l'utilisateur appartient à l'organisation
                if (!organizationId.equals(user.getOrganizationId())) {
                    return Mono.error(new SecurityException("Accès refusé à cette organisation"));
                }

                return Mono.empty();
            })
            .then()
            .doOnSuccess(v -> log.debug("Organization access validated for user {}", userId))
            .doOnError(error -> log.warn("Organization access denied for user {}: {}", userId, error.getMessage()));
    }

    /**
     * Valide l'accès d'un utilisateur à une agence
     */
    public Mono<Void> validateAgencyAccess(UUID agencyId, UUID userId) {
        log.debug("Validating agency access for user {} to agency {}", userId, agencyId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .flatMap(user -> {
                // Super admin a accès à tout
                if (user.getUserType() == UserType.SUPER_ADMIN) {
                    return Mono.empty();
                }

                return agencyRepository.findById(agencyId)
                    .switchIfEmpty(Mono.error(new SecurityException("Agence non trouvée")))
                    .flatMap(agency -> {
                        // Propriétaire d'organisation a accès à toutes ses agences
                        if (user.getUserType() == UserType.ORGANIZATION_OWNER &&
                            agency.getOrganizationId().equals(user.getOrganizationId())) {
                            return Mono.empty();
                        }

                        // Manager d'agence a accès à son agence
                        if (user.getUserType() == UserType.AGENCY_MANAGER &&
                            agencyId.equals(user.getAgencyId())) {
                            return Mono.empty();
                        }

                        // Agent de location a accès à son agence
                        if (user.getUserType() == UserType.RENTAL_AGENT &&
                            agencyId.equals(user.getAgencyId())) {
                            return Mono.empty();
                        }

                        // Vérifier que l'utilisateur appartient à la même organisation que l'agence
                        if (!agency.getOrganizationId().equals(user.getOrganizationId())) {
                            return Mono.error(new SecurityException("Accès refusé à cette agence"));
                        }

                        return Mono.empty();
                    });
            })
            .then()
            .doOnSuccess(v -> log.debug("Agency access validated for user {}", userId))
            .doOnError(error -> log.warn("Agency access denied for user {}: {}", userId, error.getMessage()));
    }

    /**
     * Valide l'accès d'un utilisateur à un autre utilisateur (pour modification)
     */
    public Mono<Void> validateUserAccess(UUID targetUserId, UUID requesterId) {
        log.debug("Validating user access from {} to {}", requesterId, targetUserId);

        return userRepository.findById(requesterId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur demandeur non trouvé")))
            .zipWith(userRepository.findById(targetUserId)
                .switchIfEmpty(Mono.error(new SecurityException("Utilisateur cible non trouvé"))))
            .flatMap(tuple -> {
                User requester = tuple.getT1();
                User target = tuple.getT2();

                // Super admin a accès à tout
                if (requester.getUserType() == UserType.SUPER_ADMIN) {
                    return Mono.empty();
                }

                // Un utilisateur peut toujours se modifier lui-même
                if (requesterId.equals(targetUserId)) {
                    return Mono.empty();
                }

                // Propriétaire d'organisation peut modifier les utilisateurs de son organisation
                if (requester.getUserType() == UserType.ORGANIZATION_OWNER &&
                    requester.getOrganizationId().equals(target.getOrganizationId())) {
                    return Mono.empty();
                }

                // Manager d'agence peut modifier les utilisateurs de son agence
                if (requester.getUserType() == UserType.AGENCY_MANAGER &&
                    requester.getAgencyId() != null &&
                    requester.getAgencyId().equals(target.getAgencyId())) {
                    return Mono.empty();
                }

                // Vérifier que les utilisateurs appartiennent à la même organisation
                if (!requester.getOrganizationId().equals(target.getOrganizationId())) {
                    return Mono.error(new SecurityException("Accès refusé à cet utilisateur"));
                }

                return Mono.error(new SecurityException("Permissions insuffisantes"));
            })
            .then()
            .doOnSuccess(v -> log.debug("User access validated from {} to {}", requesterId, targetUserId))
            .doOnError(error -> log.warn("User access denied from {} to {}: {}",
                requesterId, targetUserId, error.getMessage()));
    }

    /**
     * Obtient l'organisation d'un utilisateur
     */
    public Mono<UUID> getUserOrganizationId(UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .map(User::getOrganizationId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur sans organisation")));
    }

    /**
     * Obtient l'agence d'un utilisateur
     */
    public Mono<UUID> getUserAgencyId(UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .map(User::getAgencyId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur sans agence")));
    }

    /**
     * Vérifie si un utilisateur peut créer une agence
     */
    public Mono<Boolean> canCreateAgency(UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .map(user -> user.getUserType() == UserType.SUPER_ADMIN ||
                user.getUserType() == UserType.ORGANIZATION_OWNER);
    }

    /**
     * Vérifie si un utilisateur peut modifier une organisation
     */
    public Mono<Boolean> canModifyOrganization(UUID organizationId, UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .map(user -> {
                if (user.getUserType() == UserType.SUPER_ADMIN) {
                    return true;
                }

                return user.getUserType() == UserType.ORGANIZATION_OWNER &&
                    organizationId.equals(user.getOrganizationId());
            });
    }

    /**
     * Vérifie si un utilisateur peut supprimer une agence
     */
    public Mono<Boolean> canDeleteAgency(UUID agencyId, UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .flatMap(user -> {
                if (user.getUserType() == UserType.SUPER_ADMIN) {
                    return Mono.just(true);
                }

                if (user.getUserType() != UserType.ORGANIZATION_OWNER) {
                    return Mono.just(false);
                }

                return agencyRepository.findById(agencyId)
                    .switchIfEmpty(Mono.error(new SecurityException("Agence non trouvée")))
                    .map(agency -> agency.getOrganizationId().equals(user.getOrganizationId()));
            });
    }

    /**
     * Filtre les données selon l'organisation de l'utilisateur
     */
    public Mono<UUID> getFilterOrganizationId(UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .map(user -> {
                // Super admin peut voir toutes les organisations (retourne null pour pas de filtre)
                if (user.getUserType() == UserType.SUPER_ADMIN) {
                    return null;
                }

                return user.getOrganizationId();
            });
    }

    /**
     * Vérifie si un utilisateur a les permissions pour une action spécifique
     */
    public Mono<Boolean> hasPermission(UUID userId, String resource, String action) {
        log.debug("Checking permission {}_{} for user {}", resource, action, userId);

        return authorizationService.hasPermission(userId, resource, action)
            .doOnNext(hasPermission -> log.debug("User {} has permission {}_{}: {}",
                userId, resource, action, hasPermission));
    }

    /**
     * Vérifie l'isolation des données entre organisations
     */
    public Mono<Void> validateDataIsolation(UUID resourceOrganizationId, UUID userOrganizationId) {
        if (resourceOrganizationId == null || userOrganizationId == null) {
            return Mono.error(new SecurityException("IDs d'organisation manquants"));
        }

        if (!resourceOrganizationId.equals(userOrganizationId)) {
            return Mono.error(new SecurityException("Violation de l'isolation des données"));
        }

        return Mono.empty();
    }

    /**
     * Obtient le contexte de sécurité pour un utilisateur
     */
    public Mono<SecurityContext> getSecurityContext(UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .map(user -> SecurityContext.builder()
                .userId(user.getId())
                .userType(user.getUserType())
                .organizationId(user.getOrganizationId())
                .agencyId(user.getAgencyId())
                .email(user.getEmail())
                .fullName(user.getFullName())
                .isActive(user.getIsActive())
                .isEmailVerified(user.getIsEmailVerified())
                .build());
    }

    /**
     * Applique les filtres multi-tenant pour les requêtes
     */
    public Mono<TenantFilter> getTenantFilter(UUID userId) {
        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new SecurityException("Utilisateur non trouvé")))
            .map(user -> {
                TenantFilter.TenantFilterBuilder builder = TenantFilter.builder()
                    .userId(user.getId())
                    .userType(user.getUserType());

                // Super admin voit tout
                if (user.getUserType() == UserType.SUPER_ADMIN) {
                    builder.isGlobalAccess(true);
                } else {
                    builder.organizationId(user.getOrganizationId());

                    // Si l'utilisateur est lié à une agence spécifique
                    if (user.getAgencyId() != null &&
                        (user.getUserType() == UserType.AGENCY_MANAGER ||
                            user.getUserType() == UserType.RENTAL_AGENT)) {
                        builder.agencyId(user.getAgencyId());
                        builder.isAgencyRestricted(true);
                    }
                }

                return builder.build();
            });
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\OnboardingReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.*;
import inc.yowyob.rental_api_reactive.persistence.repository.*;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Service d'onboarding
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class OnboardingReactiveService {

    private final OnboardingSessionReactiveRepository onboardingRepository;
    private final UserReactiveRepository userRepository;
    private final OrganizationReactiveRepository organizationRepository;
    private final SubscriptionPlanReactiveRepository subscriptionPlanRepository;
    private final OrganizationSubscriptionReactiveRepository orgSubscriptionRepository;
    private final PasswordEncoder passwordEncoder;
    private final ObjectMapper objectMapper;

    /**
     * Démarre une nouvelle session d'onboarding
     */
    public Mono<OnboardingResponse> startOnboarding() {
        log.info("Starting new onboarding session");

        OnboardingSession session = new OnboardingSession();

        return onboardingRepository.save(session)
            .map(this::mapToResponse)
            .doOnSuccess(response -> log.info("Onboarding session started: {}", response.getSessionToken()));
    }

    /**
     * Sauvegarde les informations du propriétaire (Étape 1)
     */
    public Mono<OnboardingResponse> saveOwnerInfo(String sessionToken, OnboardingOwnerRequest ownerRequest) {
        log.info("Saving owner info for session: {}", sessionToken);

        return findSessionByToken(sessionToken)
            .flatMap(session -> {
                try {
                    // Valider que c'est la bonne étape
                    if (session.getCurrentStep() != 1) {
                        return Mono.error(new IllegalStateException("Étape d'onboarding incorrecte"));
                    }

                    // Vérifier que l'email n'existe pas déjà
                    return userRepository.countByEmail(ownerRequest.getEmail())
                        .flatMap(count -> {
                            if (count > 0) {
                                return Mono.error(new IllegalArgumentException("Cet email est déjà utilisé"));
                            }

                            Mono.fromCallable(() -> {
                                String ownerInfoJson = objectMapper.writeValueAsString(ownerRequest);

                                session.setOwnerInfo(ownerInfoJson);
                                session.nextStep();

                                return session;
                            });

                            return onboardingRepository.save(session);
                        });
                } catch (Exception e) {
                    return Mono.error(new RuntimeException("Erreur lors de la sérialisation", e));
                }
            })
            .map(this::mapToResponse)
            .doOnSuccess(response -> log.info("Owner info saved for session: {}", sessionToken));
    }

    /**
     * Sauvegarde les informations de l'organisation (Étape 2)
     */
    public Mono<OnboardingResponse> saveOrganizationInfo(String sessionToken, OnboardingOrganizationRequest orgRequest) {
        log.info("Saving organization info for session: {}", sessionToken);

        return findSessionByToken(sessionToken)
            .flatMap(session -> {
                try {
                    // Valider que c'est la bonne étape
                    if (session.getCurrentStep() != 2) {
                        return Mono.error(new IllegalStateException("Étape d'onboarding incorrecte"));
                    }

                    // Vérifier que le nom d'organisation n'existe pas
                    return organizationRepository.existsByName(orgRequest.getName())
                        .flatMap(exists -> {
                            if (exists) {
                                return Mono.error(new IllegalArgumentException("Ce nom d'organisation existe déjà"));
                            }

                             Mono.fromCallable(() -> {
                                String orgInfoJson = objectMapper.writeValueAsString(orgRequest);

                                session.setOrganizationInfo(orgInfoJson);
                                session.nextStep();

                                return session;
                            });

                            return onboardingRepository.save(session);
                        });
                } catch (Exception e) {
                    return Mono.error(new RuntimeException("Erreur lors de la sérialisation", e));
                }
            })
            .map(this::mapToResponse)
            .doOnSuccess(response -> log.info("Organization info saved for session: {}", sessionToken));
    }

    /**
     * Sauvegarde les informations d'abonnement (Étape 3)
     */
    public Mono<OnboardingResponse> saveSubscriptionInfo(String sessionToken, OnboardingSubscriptionRequest subscriptionRequest) {
        log.info("Saving subscription info for session: {}", sessionToken);

        return findSessionByToken(sessionToken)
            .flatMap(session -> {
                try {
                    // Valider que c'est la bonne étape
                    if (session.getCurrentStep() != 3) {
                        return Mono.error(new IllegalStateException("Étape d'onboarding incorrecte"));
                    }

                    // Vérifier que le plan d'abonnement existe
                    return subscriptionPlanRepository.findById(subscriptionRequest.getSubscriptionPlanId())
                        .switchIfEmpty(Mono.error(new IllegalArgumentException("Plan d'abonnement non trouvé")))
                        .flatMap(plan -> {

                            Mono.fromCallable(() -> {
                                String subscriptionInfoJson = objectMapper.writeValueAsString(subscriptionRequest);

                                session.setSubscriptionInfo(subscriptionInfoJson);
                                session.nextStep();

                                return session;
                            });

                            return onboardingRepository.save(session);
                        });
                } catch (Exception e) {
                    return Mono.error(new RuntimeException("Erreur lors de la sérialisation", e));
                }
            })
            .map(this::mapToResponse)
            .doOnSuccess(response -> log.info("Subscription info saved for session: {}", sessionToken));
    }

    /**
     * Finalise l'onboarding en créant l'utilisateur et l'organisation
     */
    @Transactional
    public Mono<OnboardingCompletionResponse> completeOnboarding(String sessionToken) {
        log.info("Completing onboarding for session: {}", sessionToken);

        return findSessionByToken(sessionToken)
            .flatMap(session -> {
                try {
                    // Vérifier que toutes les étapes sont complétées
                    if (session.getCurrentStep() != 3 || session.getOwnerInfo() == null ||
                        session.getOrganizationInfo() == null || session.getSubscriptionInfo() == null) {
                        return Mono.error(new IllegalStateException("Toutes les étapes doivent être complétées"));
                    }

                    // Désérialiser les informations
                    OnboardingOwnerRequest ownerInfo = objectMapper.readValue(session.getOwnerInfo(), OnboardingOwnerRequest.class);
                    OnboardingOrganizationRequest orgInfo = objectMapper.readValue(session.getOrganizationInfo(), OnboardingOrganizationRequest.class);
                    OnboardingSubscriptionRequest subscriptionInfo = objectMapper.readValue(session.getSubscriptionInfo(), OnboardingSubscriptionRequest.class);

                    // Étape 1: Créer l'organisation
                    return createOrganization(orgInfo, subscriptionInfo)
                        .flatMap(organization ->
                            // Étape 2: Créer l'utilisateur propriétaire
                            createOwnerUser(ownerInfo, organization.getId())
                                .flatMap(user ->
                                    // Étape 3: Créer l'abonnement
                                    createOrganizationSubscription(organization.getId(), subscriptionInfo)
                                        .flatMap(subscription ->
                                            // Étape 4: Finaliser la session
                                            completeSession(session, user.getId(), organization.getId())
                                                .map(completedSession -> buildCompletionResponse(user, organization, subscription))
                                        )
                                )
                        );

                } catch (Exception e) {
                    return Mono.error(new RuntimeException("Erreur lors de la finalisation", e));
                }
            })
            .doOnSuccess(response -> log.info("Onboarding completed successfully for organization: {}", response.getOrganization().getId()))
            .doOnError(error -> log.error("Error completing onboarding for session {}: {}", sessionToken, error.getMessage()));
    }

    /**
     * Récupère l'état d'une session d'onboarding
     */
    public Mono<OnboardingResponse> getOnboardingStatus(String sessionToken) {
        return findSessionByToken(sessionToken)
            .map(this::mapToResponse);
    }

    // === MÉTHODES PRIVÉES ===

    /**
     * Trouve une session par token
     */
    private Mono<OnboardingSession> findSessionByToken(String sessionToken) {
        return onboardingRepository.findBySessionToken(sessionToken)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Session d'onboarding non trouvée")))
            .flatMap(session -> {
                if (session.getExpiresAt().isBefore(LocalDateTime.now())) {
                    return Mono.error(new IllegalArgumentException("Session d'onboarding expirée"));
                }
                return Mono.just(session);
            });
    }

    /**
     * Crée l'organisation
     */
    private Mono<Organization> createOrganization(OnboardingOrganizationRequest orgInfo, OnboardingSubscriptionRequest subscriptionInfo) {
        return subscriptionPlanRepository.findById(subscriptionInfo.getSubscriptionPlanId())
            .flatMap(plan -> {
                Organization organization = new Organization(
                    orgInfo.getName(),
                    orgInfo.getOrganizationType(),
                    null // ownerId sera défini après la création de l'utilisateur
                );

                // Informations de base
                organization.setDescription(orgInfo.getDescription());
                organization.setAddress(orgInfo.getAddress());
                organization.setCity(orgInfo.getCity());
                organization.setCountry(orgInfo.getCountry() != null ? orgInfo.getCountry() : "CM");
                organization.setPostalCode(orgInfo.getPostalCode());
                organization.setRegion(orgInfo.getRegion());
                organization.setPhone(orgInfo.getPhone());
                organization.setEmail(orgInfo.getEmail());
                organization.setWebsite(orgInfo.getWebsite());

                // Informations légales
                organization.setRegistrationNumber(orgInfo.getRegistrationNumber());
                organization.setTaxNumber(orgInfo.getTaxNumber());
                organization.setBusinessLicense(orgInfo.getBusinessLicense());

                // Limites selon le plan d'abonnement
                organization.setMaxAgencies(plan.getMaxAgencies());
                organization.setMaxVehicles(plan.getMaxVehicles());
                organization.setMaxDrivers(plan.getMaxDrivers());
                organization.setMaxUsers(plan.getMaxUsers());

                // Configuration par défaut
                organization.setCurrency(orgInfo.getCurrency() != null ? orgInfo.getCurrency() : "XAF");
                organization.setTimezone(orgInfo.getTimezone() != null ? orgInfo.getTimezone() : "Africa/Douala");
                organization.setLanguage(orgInfo.getLanguage() != null ? orgInfo.getLanguage() : "fr");

                // Branding
                organization.setPrimaryColor(orgInfo.getPrimaryColor());
                organization.setSecondaryColor(orgInfo.getSecondaryColor());

                return organizationRepository.save(organization);
            });
    }

    /**
     * Crée l'utilisateur propriétaire
     */
    private Mono<User> createOwnerUser(OnboardingOwnerRequest ownerInfo, UUID organizationId) {
        User owner = new User();
        owner.setId(UUID.randomUUID());
        owner.setEmail(ownerInfo.getEmail());
        owner.setPassword(passwordEncoder.encode(ownerInfo.getPassword()));
        owner.setFirstName(ownerInfo.getFirstName());
        owner.setLastName(ownerInfo.getLastName());
        owner.setPhone(ownerInfo.getPhone());
        owner.setUserType(UserType.ORGANIZATION_OWNER);
        owner.setOrganizationId(organizationId);
        owner.setAddress(ownerInfo.getAddress());
        owner.setCity(ownerInfo.getCity());
        owner.setCountry(ownerInfo.getCountry() != null ? ownerInfo.getCountry() : "CM");
        owner.setIsActive(true);
        owner.setIsEmailVerified(false);
        owner.setCreatedAt(LocalDateTime.now());
        owner.setUpdatedAt(LocalDateTime.now());

        return userRepository.save(owner)
            .flatMap(savedUser -> {
                // Mettre à jour l'organisation avec l'ID du propriétaire
                return organizationRepository.findById(organizationId)
                    .flatMap(organization -> {
                        organization.setOwnerId(savedUser.getId());
                        organization.incrementAgencies(); // L'utilisateur compte comme +1 utilisateur
                        return organizationRepository.save(organization)
                            .then(Mono.just(savedUser));
                    });
            });
    }

    /**
     * Crée l'abonnement de l'organisation
     */
    private Mono<OrganizationSubscription> createOrganizationSubscription(UUID organizationId, OnboardingSubscriptionRequest subscriptionInfo) {
        return subscriptionPlanRepository.findById(subscriptionInfo.getSubscriptionPlanId())
            .flatMap(plan -> {
                OrganizationSubscription subscription = new OrganizationSubscription(
                    organizationId,
                    plan.getId(),
                    plan.getPrice(),
                    subscriptionInfo.getPaymentMethod()
                );

                // Configuration des dates
                LocalDateTime now = LocalDateTime.now();
                subscription.setStartDate(now);
                subscription.setEndDate(now.plusDays(plan.getDurationDays()));
                subscription.setNextBillingDate(now.plusDays(plan.getDurationDays()));

                // Informations de paiement
                subscription.setPaymentReference(subscriptionInfo.getPaymentReference());
                subscription.setAutoRenew(subscriptionInfo.getAutoRenew() != null ? subscriptionInfo.getAutoRenew() : true);

                return orgSubscriptionRepository.save(subscription)
                    .flatMap(savedSubscription -> {
                        // Mettre à jour l'organisation avec les informations d'abonnement
                        return organizationRepository.findById(organizationId)
                            .flatMap(organization -> {
                                organization.updateSubscription(
                                    plan.getId(),
                                    savedSubscription.getEndDate(),
                                    savedSubscription.getAutoRenew()
                                );
                                return organizationRepository.save(organization)
                                    .then(Mono.just(savedSubscription));
                            });
                    });
            });
    }

    /**
     * Finalise la session d'onboarding
     */
    private Mono<OnboardingSession> completeSession(OnboardingSession session, UUID userId, UUID organizationId) {
        session.complete(organizationId);
        session.setUserId(userId);
        return onboardingRepository.save(session);
    }

    /**
     * Construit la réponse de finalisation
     */
    private OnboardingCompletionResponse buildCompletionResponse(User user, Organization organization, OrganizationSubscription subscription) {
        return OnboardingCompletionResponse.builder()
            .success(true)
            .message("Onboarding complété avec succès")
            .user(UserResponse.builder()
                .id(user.getId())
                .email(user.getEmail())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .userType(user.getUserType())
                .organizationId(user.getOrganizationId())
                .isActive(user.getIsActive())
                .createdAt(user.getCreatedAt())
                .build())
            .organization(OrganizationResponse.builder()
                .id(organization.getId())
                .name(organization.getName())
                .organizationType(organization.getOrganizationType())
                .description(organization.getDescription())
                .ownerId(organization.getOwnerId())
                .email(organization.getEmail())
                .phone(organization.getPhone())
                .fullAddress(organization.getFullAddress())
                .isActive(organization.getIsActive())
                .isVerified(organization.getIsVerified())
                .maxAgencies(organization.getMaxAgencies())
                .maxVehicles(organization.getMaxVehicles())
                .maxDrivers(organization.getMaxDrivers())
                .maxUsers(organization.getMaxUsers())
                .createdAt(organization.getCreatedAt())
                .build())
            .subscription(SubscriptionResponse.builder()
                .id(subscription.getId())
                .organizationId(subscription.getOrganizationId())
                .subscriptionPlanId(subscription.getSubscriptionPlanId())
                .status(subscription.getStatus())
                .startDate(subscription.getStartDate())
                .endDate(subscription.getEndDate())
                .amount(subscription.getAmount())
                .currency(subscription.getCurrency())
                .autoRenew(subscription.getAutoRenew())
                .isActive(subscription.isActive())
                .build())
            .nextSteps("Vérifiez votre email pour activer votre compte. Vous pouvez maintenant accéder à votre tableau de bord.")
            .build();
    }

    /**
     * Mappe une session vers une réponse
     */
    private OnboardingResponse mapToResponse(OnboardingSession session) {
        return OnboardingResponse.builder()
            .sessionToken(session.getSessionToken())
            .currentStep(session.getCurrentStep())
            .maxStep(session.getMaxStep())
            .isCompleted(session.getIsCompleted())
            .expiresAt(session.getExpiresAt())
            .hasOwnerInfo(session.getOwnerInfo() != null)
            .hasOrganizationInfo(session.getOrganizationInfo() != null)
            .hasSubscriptionInfo(session.getSubscriptionInfo() != null)
            .createdAt(session.getCreatedAt())
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\OrganizationReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.Organization;
import inc.yowyob.rental_api_reactive.persistence.repository.OrganizationReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.AgencyReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.mapper.OrganizationMapper;
import inc.yowyob.rental_api_reactive.application.dto.OrganizationType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Service réactif pour la gestion des organisations
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class OrganizationReactiveService {

    private final OrganizationReactiveRepository organizationRepository;
    private final AgencyReactiveRepository agencyRepository;
    private final OrganizationMapper organizationMapper;
    private final MultiTenantReactiveService multiTenantService;
    private final SubscriptionValidationReactiveService subscriptionValidationService;

    /**
     * Crée une nouvelle organisation
     */
    public Mono<OrganizationResponse> createOrganization(CreateOrganizationRequest createRequest, UUID createdBy) {
        log.info("Creating organization: {} for owner: {}", createRequest.getName(), createRequest.getOwnerId());

        return validateOrganizationCreation(createRequest)
            .then(createOrganizationFromRequest(createRequest, createdBy))
            .flatMap(organizationRepository::save)
            .map(organizationMapper::toResponse)
            .doOnSuccess(response -> log.info("Organization created successfully: {}", response.getId()))
            .doOnError(error -> log.error("Error creating organization: {}", error.getMessage()));
    }

    /**
     * Met à jour une organisation
     */
    public Mono<OrganizationResponse> updateOrganization(UUID organizationId, UpdateOrganizationRequest updateRequest, UUID updatedBy) {
        log.info("Updating organization: {}", organizationId);

        return multiTenantService.validateOrganizationAccess(organizationId, updatedBy)
            .then(organizationRepository.findById(organizationId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                updateOrganizationFromRequest(organization, updateRequest, updatedBy);
                return organizationRepository.save(organization);
            })
            .map(organizationMapper::toResponse)
            .doOnSuccess(response -> log.info("Organization updated successfully: {}", response.getId()))
            .doOnError(error -> log.error("Error updating organization {}: {}", organizationId, error.getMessage()));
    }

    /**
     * Trouve toutes les organisations (avec filtrage multi-tenant)
     */
    public Flux<OrganizationResponse> findAll(UUID requesterId) {
        log.debug("Finding all organizations for user: {}", requesterId);

        return multiTenantService.getFilterOrganizationId(requesterId)
            .flatMapMany(orgFilter -> {
                if (orgFilter == null) {
                    // Super admin voit toutes les organisations
                    return organizationRepository.findAll();
                } else {
                    // Utilisateur normal voit seulement son organisation
                    return organizationRepository.findById(orgFilter).flux();
                }
            })
            .map(organizationMapper::toResponse)
            .doOnNext(org -> log.debug("Found organization: {}", org.getName()));
    }

    /**
     * Trouve une organisation par ID
     */
    public Mono<OrganizationResponse> findById(UUID id, UUID requesterId) {
        log.debug("Finding organization by ID: {} for user: {}", id, requesterId);

        return multiTenantService.validateOrganizationAccess(id, requesterId)
            .then(organizationRepository.findById(id))
            .map(organizationMapper::toResponse)
            .doOnNext(org -> log.debug("Found organization: {}", org.getName()));
    }

    /**
     * Trouve les organisations actives
     */
    public Flux<OrganizationResponse> findAllActive(UUID requesterId) {
        log.debug("Finding active organizations for user: {}", requesterId);

        return multiTenantService.getFilterOrganizationId(requesterId)
            .flatMapMany(orgFilter -> {
                if (orgFilter == null) {
                    return organizationRepository.findAllActive();
                } else {
                    return organizationRepository.findById(orgFilter)
                        .filter(org -> org.getIsActive())
                        .flux();
                }
            })
            .map(organizationMapper::toResponse)
            .doOnNext(org -> log.debug("Found active organization: {}", org.getName()));
    }

    /**
     * Vérifie si un nom d'organisation existe
     */
    public Mono<Boolean> existsByName(String name) {
        return organizationRepository.existsByName(name);
    }

    /**
     * Supprime une organisation (soft delete)
     */
    public Mono<Void> deleteById(UUID organizationId, UUID deletedBy) {
        log.info("Deleting organization: {}", organizationId);

        return multiTenantService.validateOrganizationAccess(organizationId, deletedBy)
            .then(organizationRepository.findById(organizationId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> validateOrganizationDeletion(organizationId)
                .then(Mono.fromRunnable(() -> {
                    organization.setIsActive(false);
                }))
                .then(organizationRepository.save(organization))
                .then())
            .doOnSuccess(v -> log.info("Organization deleted successfully: {}", organizationId))
            .doOnError(error -> log.error("Error deleting organization {}: {}", organizationId, error.getMessage()));
    }

    /**
     * Active/désactive une organisation
     */
    public Mono<OrganizationResponse> toggleOrganizationStatus(UUID organizationId, boolean isActive, UUID updatedBy) {
        log.info("Toggling organization status: {} to {}", organizationId, isActive);

        return multiTenantService.validateOrganizationAccess(organizationId, updatedBy)
            .then(organizationRepository.findById(organizationId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                organization.setIsActive(isActive);
                organization.preUpdate();
                return organizationRepository.save(organization);
            })
            .map(organizationMapper::toResponse)
            .doOnSuccess(response -> log.info("Organization status toggled: {} - {}",
                response.getId(), response.getIsActive()));
    }

    /**
     * Vérifie une organisation
     */
    public Mono<OrganizationResponse> verifyOrganization(UUID organizationId, UUID verifiedBy) {
        log.info("Verifying organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                organization.verify(verifiedBy);
                return organizationRepository.save(organization);
            })
            .map(organizationMapper::toResponse)
            .doOnSuccess(response -> log.info("Organization verified: {}", response.getId()));
    }

    /**
     * Met à jour l'abonnement d'une organisation
     */
    public Mono<OrganizationResponse> updateSubscription(UUID organizationId, UpdateSubscriptionRequest request, UUID updatedBy) {
        log.info("Updating subscription for organization: {}", organizationId);

        return multiTenantService.validateOrganizationAccess(organizationId, updatedBy)
            .then(organizationRepository.findById(organizationId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                organization.updateSubscription(
                    request.getSubscriptionPlanId(),
                    request.getExpiresAt(),
                    request.getAutoRenew()
                );
                return organizationRepository.save(organization);
            })
            .map(organizationMapper::toResponse)
            .doOnSuccess(response -> log.info("Subscription updated for organization: {}", response.getId()));
    }

    /**
     * Met à jour les statistiques d'une organisation
     */
    public Mono<OrganizationResponse> updateOrganizationStatistics(UUID organizationId, OrganizationStatisticsRequest statsRequest) {
        log.debug("Updating statistics for organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                if (statsRequest.getResourceCounters() != null) {
                    organization.updateResourceCounters(
                        statsRequest.getResourceCounters().getAgencies(),
                        statsRequest.getResourceCounters().getVehicles(),
                        statsRequest.getResourceCounters().getDrivers(),
                        statsRequest.getResourceCounters().getUsers()
                    );
                }

                if (statsRequest.getFinancialStats() != null) {
                    organization.updateFinancialStats(
                        statsRequest.getFinancialStats().getMonthlyRevenue(),
                        statsRequest.getFinancialStats().getYearlyRevenue(),
                        statsRequest.getFinancialStats().getTotalRentals()
                    );
                }

                return organizationRepository.save(organization);
            })
            .map(organizationMapper::toResponse)
            .doOnSuccess(response -> log.debug("Statistics updated for organization: {}", response.getId()));
    }

    /**
     * Trouve les organisations par type
     */
    public Flux<OrganizationResponse> findByType(OrganizationType type, UUID requesterId) {
        return multiTenantService.getFilterOrganizationId(requesterId)
            .flatMapMany(orgFilter -> {
                if (orgFilter == null) {
                    return organizationRepository.findByOrganizationType(type);
                } else {
                    return organizationRepository.findById(orgFilter)
                        .filter(org -> org.getOrganizationType() == type)
                        .flux();
                }
            })
            .map(organizationMapper::toResponse);
    }

    /**
     * Trouve les organisations par ville et pays
     */
    public Flux<OrganizationResponse> findByCityAndCountry(String city, String country, UUID requesterId) {
        return multiTenantService.getFilterOrganizationId(requesterId)
            .flatMapMany(orgFilter -> {
                if (orgFilter == null) {
                    return organizationRepository.findByCityAndCountry(city, country);
                } else {
                    return organizationRepository.findById(orgFilter)
                        .filter(org -> city.equals(org.getCity()) && country.equals(org.getCountry()))
                        .flux();
                }
            })
            .map(organizationMapper::toResponse);
    }

    /**
     * Obtient les statistiques complètes d'une organisation
     */
    public Mono<OrganizationStatisticsResponse> getOrganizationStatistics(UUID organizationId, UUID requesterId) {
        return multiTenantService.validateOrganizationAccess(organizationId, requesterId)
            .then(organizationRepository.findById(organizationId))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(this::buildOrganizationStatistics);
    }

    /**
     * Trouve les organisations nécessitant une attention
     */
    public Flux<OrganizationResponse> findOrganizationsNeedingAttention(UUID requesterId) {
        return multiTenantService.getFilterOrganizationId(requesterId)
            .flatMapMany(orgFilter -> {
                if (orgFilter == null) {
                    return organizationRepository.findOrganizationsNeedingAttention();
                } else {
                    return organizationRepository.findById(orgFilter)
                        .filter(org -> !org.getIsVerified() || org.isSubscriptionExpiringSoon())
                        .flux();
                }
            })
            .map(organizationMapper::toResponse);
    }

    // === MÉTHODES PRIVÉES ===

    /**
     * Valide la création d'une organisation
     */
    private Mono<Void> validateOrganizationCreation(CreateOrganizationRequest request) {
        return organizationRepository.existsByName(request.getName())
            .flatMap(exists -> {
                if (exists) {
                    return Mono.error(new IllegalArgumentException("Une organisation avec ce nom existe déjà"));
                }
                return Mono.empty();
            })
            .then(validateRegistrationNumber(request.getRegistrationNumber()))
            .then(validateTaxNumber(request.getTaxNumber()));
    }

    /**
     * Valide le numéro d'enregistrement
     */
    private Mono<Void> validateRegistrationNumber(String registrationNumber) {
        if (registrationNumber == null) return Mono.empty();

        return organizationRepository.existsByRegistrationNumber(registrationNumber)
            .flatMap(exists -> {
                if (exists) {
                    return Mono.error(new IllegalArgumentException("Ce numéro d'enregistrement existe déjà"));
                }
                return Mono.empty();
            });
    }

    /**
     * Valide le numéro fiscal
     */
    private Mono<Void> validateTaxNumber(String taxNumber) {
        if (taxNumber == null) return Mono.empty();

        return organizationRepository.existsByTaxNumber(taxNumber)
            .flatMap(exists -> {
                if (exists) {
                    return Mono.error(new IllegalArgumentException("Ce numéro fiscal existe déjà"));
                }
                return Mono.empty();
            });
    }

    /**
     * Crée une organisation à partir de la requête
     */
    private Mono<Organization> createOrganizationFromRequest(CreateOrganizationRequest request, UUID createdBy) {
        Organization organization = new Organization(
            request.getName(),
            request.getOrganizationType(),
            request.getOwnerId()
        );

        // Informations de base
        organization.setDescription(request.getDescription());

        // Informations légales
        organization.setRegistrationNumber(request.getRegistrationNumber());
        organization.setTaxNumber(request.getTaxNumber());
        organization.setBusinessLicense(request.getBusinessLicense());

        // Adresse
        organization.setAddress(request.getAddress());
        organization.setCity(request.getCity());
        organization.setCountry(request.getCountry() != null ? request.getCountry() : "CM");
        organization.setPostalCode(request.getPostalCode());
        organization.setRegion(request.getRegion());

        // Contact
        organization.setPhone(request.getPhone());
        organization.setEmail(request.getEmail());
        organization.setWebsite(request.getWebsite());

        // Configuration
        organization.setCurrency(request.getCurrency() != null ? request.getCurrency() : "XAF");
        organization.setTimezone(request.getTimezone() != null ? request.getTimezone() : "Africa/Douala");
        organization.setLanguage(request.getLanguage() != null ? request.getLanguage() : "fr");

        // Limites selon le type d'organisation
        OrganizationType.OrganizationLimits limits = request.getOrganizationType().getDefaultLimits();
        organization.setMaxAgencies(limits.getMaxAgencies());
        organization.setMaxVehicles(limits.getMaxVehicles());
        organization.setMaxDrivers(limits.getMaxDrivers());
        organization.setMaxUsers(limits.getMaxUsers());

        // Branding
        organization.setPrimaryColor(request.getPrimaryColor());
        organization.setSecondaryColor(request.getSecondaryColor());

        // Politiques et paramètres (à stocker en JSON)
        if (request.getPolicies() != null) {
            organization.setPolicies(convertToJson(request.getPolicies()));
        }
        if (request.getSettings() != null) {
            organization.setSettings(convertToJson(request.getSettings()));
        }

        return Mono.just(organization);
    }

    /**
     * Met à jour une organisation à partir de la requête
     */
    private void updateOrganizationFromRequest(Organization organization, UpdateOrganizationRequest request, UUID updatedBy) {
        if (request.getName() != null) organization.setName(request.getName());
        if (request.getDescription() != null) organization.setDescription(request.getDescription());
        if (request.getOrganizationType() != null) organization.setOrganizationType(request.getOrganizationType());

        // Informations légales
        if (request.getRegistrationNumber() != null) organization.setRegistrationNumber(request.getRegistrationNumber());
        if (request.getTaxNumber() != null) organization.setTaxNumber(request.getTaxNumber());
        if (request.getBusinessLicense() != null) organization.setBusinessLicense(request.getBusinessLicense());

        // Adresse
        if (request.getAddress() != null) organization.setAddress(request.getAddress());
        if (request.getCity() != null) organization.setCity(request.getCity());
        if (request.getCountry() != null) organization.setCountry(request.getCountry());
        if (request.getPostalCode() != null) organization.setPostalCode(request.getPostalCode());
        if (request.getRegion() != null) organization.setRegion(request.getRegion());

        // Contact
        if (request.getPhone() != null) organization.setPhone(request.getPhone());
        if (request.getEmail() != null) organization.setEmail(request.getEmail());
        if (request.getWebsite() != null) organization.setWebsite(request.getWebsite());

        // Configuration
        if (request.getCurrency() != null) organization.setCurrency(request.getCurrency());
        if (request.getTimezone() != null) organization.setTimezone(request.getTimezone());
        if (request.getLanguage() != null) organization.setLanguage(request.getLanguage());

        // Branding
        if (request.getPrimaryColor() != null) organization.setPrimaryColor(request.getPrimaryColor());
        if (request.getSecondaryColor() != null) organization.setSecondaryColor(request.getSecondaryColor());

        // Politiques et paramètres
        if (request.getPolicies() != null) {
            organization.setPolicies(convertToJson(request.getPolicies()));
        }
        if (request.getSettings() != null) {
            organization.setSettings(convertToJson(request.getSettings()));
        }

        organization.preUpdate();
    }

    /**
     * Valide la suppression d'une organisation
     */
    private Mono<Void> validateOrganizationDeletion(UUID organizationId) {
        return agencyRepository.countActiveByOrganizationId(organizationId)
            .flatMap(activeAgencies -> {
                if (activeAgencies > 0) {
                    return Mono.error(new IllegalArgumentException(
                        "Impossible de supprimer une organisation avec des agences actives"));
                }
                return Mono.empty();
            });
    }

    /**
     * Construit les statistiques complètes d'une organisation
     */
    private Mono<OrganizationStatisticsResponse> buildOrganizationStatistics(Organization organization) {
        return agencyRepository.countByOrganizationId(organization.getId())
            .zipWith(agencyRepository.countActiveByOrganizationId(organization.getId()))
            .map(tuple -> OrganizationStatisticsResponse.builder()
                .organizationId(organization.getId())
                .totalAgencies(tuple.getT1().intValue())
                .activeAgencies(tuple.getT2().intValue())
                .maxAgencies(organization.getMaxAgencies())
                .totalVehicles(organization.getCurrentVehicles())
                .maxVehicles(organization.getMaxVehicles())
                .totalDrivers(organization.getCurrentDrivers())
                .maxDrivers(organization.getMaxDrivers())
                .totalUsers(organization.getCurrentUsers())
                .maxUsers(organization.getMaxUsers())
                .monthlyRevenue(organization.getMonthlyRevenue())
                .yearlyRevenue(organization.getYearlyRevenue())
                .totalRentals(organization.getTotalRentals())
                .agencyUsagePercentage(organization.getAgencyUsagePercentage())
                .vehicleUsagePercentage(organization.getVehicleUsagePercentage())
                .driverUsagePercentage(organization.getDriverUsagePercentage())
                .userUsagePercentage(organization.getUserUsagePercentage())
                .isSubscriptionActive(organization.isSubscriptionActive())
                .subscriptionExpiresAt(organization.getSubscriptionExpiresAt())
                .lastActivityAt(organization.getLastActivityAt())
                .build());
    }

    /**
     * Convertit un objet en JSON
     */
    private String convertToJson(Object object) {
        // TODO: Implémenter la conversion JSON avec ObjectMapper
        return "{}"; // Placeholder
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\PasswordReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.config.AppProperties;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.security.SecureRandom;
import java.util.regex.Pattern;

/**
 * Service réactif pour la gestion des mots de passe
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class PasswordReactiveService {

    private final PasswordEncoder passwordEncoder;
    private final AppProperties appProperties;
    private final SecureRandom secureRandom = new SecureRandom();

    // Pattern pour validation du mot de passe
    private static final Pattern PASSWORD_PATTERN = Pattern.compile(
        "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$"
    );

    /**
     * Valide un mot de passe selon les critères de sécurité
     */
    public Mono<Boolean> validatePassword(String password) {
        return Mono.fromCallable(() -> {
                if (password == null || password.length() < appProperties.getSecurity().getPasswordMinLength()) {
                    return false;
                }

                // Vérification des critères de complexité
                return PASSWORD_PATTERN.matcher(password).matches();
            })
            .doOnNext(isValid -> {
                if (!isValid) {
                    log.debug("Password validation failed");
                }
            });
    }

    /**
     * Encode un mot de passe
     */
    public Mono<String> encodePassword(String rawPassword) {
        return validatePassword(rawPassword)
            .flatMap(isValid -> {
                if (!isValid) {
                    return Mono.error(new IllegalArgumentException(
                        "Password must be at least " + appProperties.getSecurity().getPasswordMinLength() +
                            " characters long and contain at least one uppercase letter, one lowercase letter, " +
                            "one digit, and one special character"));
                }

                return Mono.fromCallable(() -> passwordEncoder.encode(rawPassword));
            });
    }

    /**
     * Vérifie si un mot de passe correspond au hash
     */
    public Mono<Boolean> matches(String rawPassword, String encodedPassword) {
        return Mono.fromCallable(() -> passwordEncoder.matches(rawPassword, encodedPassword));
    }

    /**
     * Génère un mot de passe temporaire sécurisé
     */
    public Mono<String> generateTemporaryPassword() {
        return Mono.fromCallable(() -> {
            String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@$!%*?&";
            StringBuilder password = new StringBuilder();

            // S'assurer qu'on a au moins un caractère de chaque type requis
            password.append(getRandomChar("ABCDEFGHIJKLMNOPQRSTUVWXYZ")); // Majuscule
            password.append(getRandomChar("abcdefghijklmnopqrstuvwxyz")); // Minuscule
            password.append(getRandomChar("0123456789")); // Chiffre
            password.append(getRandomChar("@$!%*?&")); // Caractère spécial

            // Compléter avec des caractères aléatoires
            for (int i = 4; i < 12; i++) {
                password.append(chars.charAt(secureRandom.nextInt(chars.length())));
            }

            // Mélanger les caractères
            return shuffleString(password.toString());
        });
    }

    /**
     * Génère un token de réinitialisation
     */
    public Mono<String> generateResetToken() {
        return Mono.fromCallable(() -> {
            byte[] token = new byte[32];
            secureRandom.nextBytes(token);
            return bytesToHex(token);
        });
    }

    /**
     * Vérifie la force d'un mot de passe
     */
    public Mono<PasswordStrength> checkPasswordStrength(String password) {
        return Mono.fromCallable(() -> {
            if (password == null || password.isEmpty()) {
                return PasswordStrength.VERY_WEAK;
            }

            int score = 0;

            // Longueur
            if (password.length() >= 8) score++;
            if (password.length() >= 12) score++;

            // Complexité
            if (password.matches(".*[a-z].*")) score++;
            if (password.matches(".*[A-Z].*")) score++;
            if (password.matches(".*\\d.*")) score++;
            if (password.matches(".*[@$!%*?&].*")) score++;

            // Pas de répétitions
            if (!password.matches(".*(.)\\1{2,}.*")) score++;

            return switch (score) {
                case 0, 1, 2 -> PasswordStrength.VERY_WEAK;
                case 3, 4 -> PasswordStrength.WEAK;
                case 5 -> PasswordStrength.MEDIUM;
                case 6 -> PasswordStrength.STRONG;
                default -> PasswordStrength.VERY_STRONG;
            };
        });
    }

    private char getRandomChar(String chars) {
        return chars.charAt(secureRandom.nextInt(chars.length()));
    }

    private String shuffleString(String input) {
        char[] chars = input.toCharArray();
        for (int i = chars.length - 1; i > 0; i--) {
            int j = secureRandom.nextInt(i + 1);
            char temp = chars[i];
            chars[i] = chars[j];
            chars[j] = temp;
        }
        return new String(chars);
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }

    public enum PasswordStrength {
        VERY_WEAK,
        WEAK,
        MEDIUM,
        STRONG,
        VERY_STRONG
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\PermissionCacheReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.UserPermissionsResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.time.LocalDateTime;
import java.time.Duration;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionCacheReactiveService {

    private final PermissionReactiveService permissionService;
    private final ConcurrentMap<UUID, CacheEntry> permissionCache = new ConcurrentHashMap<>();
    private static final Duration CACHE_DURATION = Duration.ofMinutes(15);

    /**
     * Récupère les permissions d'un utilisateur avec cache
     */
    public Mono<UserPermissionsResponse> getUserPermissions(UUID userId) {
        log.debug("Getting cached permissions for user: {}", userId);

        CacheEntry entry = permissionCache.get(userId);

        if (entry != null && !entry.isExpired()) {
            log.debug("Returning cached permissions for user: {}", userId);
            return Mono.just(entry.getPermissions());
        }

        return permissionService.getUserPermissions(userId)
            .doOnNext(permissions -> {
                CacheEntry newEntry = new CacheEntry(permissions, LocalDateTime.now().plus(CACHE_DURATION));
                permissionCache.put(userId, newEntry);
                log.debug("Cached permissions for user: {}", userId);
            });
    }

    /**
     * Invalide le cache des permissions d'un utilisateur
     */
    public void evictUserPermissions(UUID userId) {
        log.debug("Evicting permissions cache for user: {}", userId);
        permissionCache.remove(userId);
    }

    /**
     * Invalide tout le cache des permissions
     */
    public void evictAllPermissions() {
        log.debug("Evicting all permissions cache");
        permissionCache.clear();
    }

    /**
     * Vérifie si un utilisateur a une permission avec cache
     */
    public Mono<Boolean> hasPermission(UUID userId, String permissionCode) {
        return getUserPermissions(userId)
            .map(permissions -> permissions.getPermissions().contains(permissionCode));
    }

    /**
     * Nettoyage automatique des entrées expirées
     */
    public void cleanupExpiredEntries() {
        log.debug("Cleaning up expired permission cache entries");
        permissionCache.entrySet().removeIf(entry -> entry.getValue().isExpired());
    }

    private static class CacheEntry {
        private final UserPermissionsResponse permissions;
        private final LocalDateTime expiresAt;

        public CacheEntry(UserPermissionsResponse permissions, LocalDateTime expiresAt) {
            this.permissions = permissions;
            this.expiresAt = expiresAt;
        }

        public UserPermissionsResponse getPermissions() {
            return permissions;
        }

        public boolean isExpired() {
            return LocalDateTime.now().isAfter(expiresAt);
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\PermissionReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.dto.Permission;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.repository.UserRoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.*;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class PermissionReactiveService {

    private final UserRoleReactiveRepository userRoleRepository;
    private final RoleReactiveRepository roleRepository;

    /**
     * Récupère toutes les permissions disponibles
     */
    public Flux<PermissionResponse> getAllPermissions() {
        log.debug("Getting all permissions");

        return Flux.fromArray(Permission.values())
            .map(this::mapPermissionToResponse);
    }

    /**
     * Récupère les permissions par ressource
     */
    public Mono<ResourcePermissionsResponse> getPermissionsByResource(String resource) {
        log.debug("Getting permissions for resource: {}", resource);

        Set<PermissionResponse> permissions = Arrays.stream(Permission.values())
            .filter(permission -> permission.getResource().equalsIgnoreCase(resource))
            .map(this::mapPermissionToResponse)
            .collect(Collectors.toSet());

        return Mono.just(ResourcePermissionsResponse.builder()
            .resource(resource)
            .permissions(permissions)
            .totalCount(permissions.size())
            .build());
    }

    /**
     * Récupère toutes les ressources disponibles
     */
    public Flux<String> getAllResources() {
        log.debug("Getting all resources");

        return Flux.fromArray(Permission.values())
            .map(Permission::getResource)
            .distinct();
    }

    /**
     * Récupère les permissions effectives d'un utilisateur
     */
    public Mono<UserPermissionsResponse> getUserPermissions(UUID userId) {
        log.debug("Getting permissions for user: {}", userId);

        return userRoleRepository.findActiveByUserId(userId)
            .flatMap(userRole -> roleRepository.findById(userRole.getRoleId()))
            .filter(Objects::nonNull)
            .map(role -> role.getPermissions())
            .filter(Objects::nonNull)
            .collectList()
            .map(permissionsList -> {
                Set<String> effectivePermissions = permissionsList.stream()
                    .flatMap(Set::stream)
                    .collect(Collectors.toSet());

                return UserPermissionsResponse.builder()
                    .userId(userId)
                    .permissions(effectivePermissions)
                    .permissionDetails(mapPermissionsToDetails(effectivePermissions))
                    .totalCount(effectivePermissions.size())
                    .build();
            });
    }

    /**
     * Vérifie si un utilisateur a une permission spécifique
     */
    public Mono<Boolean> hasPermission(UUID userId, String permissionCode) {
        log.debug("Checking permission '{}' for user: {}", permissionCode, userId);

        return getUserPermissions(userId)
            .map(userPermissions -> userPermissions.getPermissions().contains(permissionCode))
            .defaultIfEmpty(false);
    }

    /**
     * Vérifie si un utilisateur a toutes les permissions spécifiées
     */
    public Mono<Boolean> hasAllPermissions(UUID userId, Set<String> permissionCodes) {
        log.debug("Checking permissions {} for user: {}", permissionCodes, userId);

        if (permissionCodes == null || permissionCodes.isEmpty()) {
            return Mono.just(true);
        }

        return getUserPermissions(userId)
            .map(userPermissions -> userPermissions.getPermissions().containsAll(permissionCodes))
            .defaultIfEmpty(false);
    }

    /**
     * Vérifie si un utilisateur a au moins une des permissions spécifiées
     */
    public Mono<Boolean> hasAnyPermission(UUID userId, Set<String> permissionCodes) {
        log.debug("Checking any permission {} for user: {}", permissionCodes, userId);

        if (permissionCodes == null || permissionCodes.isEmpty()) {
            return Mono.just(false);
        }

        return getUserPermissions(userId)
            .map(userPermissions -> {
                Set<String> userPerms = userPermissions.getPermissions();
                return permissionCodes.stream().anyMatch(userPerms::contains);
            })
            .defaultIfEmpty(false);
    }

    /**
     * Récupère les permissions d'un rôle
     */
    public Mono<RolePermissionsResponse> getRolePermissions(UUID roleId) {
        log.debug("Getting permissions for role: {}", roleId);

        return roleRepository.findById(roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Role not found")))
            .map(role -> RolePermissionsResponse.builder()
                .roleId(roleId)
                .roleName(role.getName())
                .permissions(role.getPermissions())
                .permissionDetails(mapPermissionsToDetails(role.getPermissions()))
                .totalCount(role.getPermissions().size())
                .build());
    }

    /**
     * Compare les permissions entre deux utilisateurs
     */
    public Mono<PermissionComparisonResponse> compareUserPermissions(UUID userId1, UUID userId2) {
        log.debug("Comparing permissions between users: {} and {}", userId1, userId2);

        return Mono.zip(
            getUserPermissions(userId1),
            getUserPermissions(userId2)
        ).map(tuple -> {
            Set<String> user1Perms = tuple.getT1().getPermissions();
            Set<String> user2Perms = tuple.getT2().getPermissions();

            Set<String> commonPermissions = new HashSet<>(user1Perms);
            commonPermissions.retainAll(user2Perms);

            Set<String> user1OnlyPermissions = new HashSet<>(user1Perms);
            user1OnlyPermissions.removeAll(user2Perms);

            Set<String> user2OnlyPermissions = new HashSet<>(user2Perms);
            user2OnlyPermissions.removeAll(user1Perms);

            return PermissionComparisonResponse.builder()
                .userId1(userId1)
                .userId2(userId2)
                .commonPermissions(commonPermissions)
                .user1OnlyPermissions(user1OnlyPermissions)
                .user2OnlyPermissions(user2OnlyPermissions)
                .commonCount(commonPermissions.size())
                .user1OnlyCount(user1OnlyPermissions.size())
                .user2OnlyCount(user2OnlyPermissions.size())
                .build();
        });
    }

    private PermissionResponse mapPermissionToResponse(Permission permission) {
        return PermissionResponse.builder()
            .code(permission.getCode())
            .description(permission.getDescription())
            .resource(permission.getResource())
            .build();
    }

    private Set<PermissionResponse> mapPermissionsToDetails(Set<String> permissionCodes) {
        if (permissionCodes == null) {
            return new HashSet<>();
        }

        return permissionCodes.stream()
            .map(code -> {
                for (Permission permission : Permission.values()) {
                    if (permission.getCode().equals(code)) {
                        return mapPermissionToResponse(permission);
                    }
                }
                return PermissionResponse.builder()
                    .code(code)
                    .description("Unknown permission")
                    .resource("UNKNOWN")
                    .build();
            })
            .collect(Collectors.toSet());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\PersonnelReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

/**
 * Service réactif pour la gestion du personnel
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class PersonnelReactiveService {

    private final UserReactiveRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    // Types d'utilisateurs considérés comme personnel
    private static final List<UserType> PERSONNEL_TYPES = Arrays.asList(
        UserType.AGENCY_MANAGER,
        UserType.RENTAL_AGENT
    );

    /**
     * Crée un nouveau membre du personnel
     */
    public Mono<PersonnelResponse> createPersonnel(CreatePersonnelRequest createRequest, UUID createdBy) {
        log.info("Creating personnel: {} for organization: {}",
            createRequest.getEmail(), createRequest.getOrganizationId());

        // Vérifier que le type d'utilisateur est valide pour le personnel
        if (!PERSONNEL_TYPES.contains(createRequest.getUserType())) {
            return Mono.error(new IllegalArgumentException(
                "Type d'utilisateur invalide pour le personnel. Types autorisés: " + PERSONNEL_TYPES));
        }

        return userRepository.countByEmail(createRequest.getEmail())
            .flatMap(count -> {
                if (count > 0) {
                    return Mono.error(new IllegalArgumentException("Email déjà utilisé"));
                }

                // Créer le nouvel utilisateur personnel
                User personnel = new User();
                personnel.setId(UUID.randomUUID());
                personnel.setEmail(createRequest.getEmail());
                personnel.setPassword(passwordEncoder.encode(createRequest.getTemporaryPassword()));
                personnel.setFirstName(createRequest.getFirstName());
                personnel.setLastName(createRequest.getLastName());
                personnel.setPhone(createRequest.getPhone());
                personnel.setUserType(createRequest.getUserType());
                personnel.setOrganizationId(createRequest.getOrganizationId());
                personnel.setAgencyId(createRequest.getAgencyId());
                personnel.setIsActive(true);
                personnel.setIsEmailVerified(false);
                personnel.setIsPhoneVerified(false);

                // Informations employé spécifiques
                personnel.setEmployeeId(createRequest.getEmployeeId());
                personnel.setDepartment(createRequest.getDepartment());
                personnel.setPosition(createRequest.getPosition());
                personnel.setSupervisorId(createRequest.getSupervisorId());
                personnel.setHiredAt(LocalDateTime.now());

                // Forcer le changement de mot de passe à la première connexion
                personnel.setMustChangePassword(true);

                personnel.setCreatedAt(LocalDateTime.now());
                personnel.setUpdatedAt(LocalDateTime.now());
                personnel.setCreatedBy(createdBy);

                return userRepository.save(personnel)
                    .map(this::mapToPersonnelResponse)
                    .doOnSuccess(response -> log.info("Personnel created successfully: {}", createRequest.getEmail()));
            });
    }

    /**
     * Récupère le personnel selon les filtres
     */
    public Flux<PersonnelResponse> getPersonnelByFilters(UUID organizationId, UUID agencyId,
                                                         UserType userType, Boolean isActive) {
        log.debug("Fetching personnel for organization: {}, agency: {}, type: {}, active: {}",
            organizationId, agencyId, userType, isActive);

        return userRepository.findByOrganizationId(organizationId)
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .filter(user -> agencyId == null || agencyId.equals(user.getAgencyId()))
            .filter(user -> userType == null || userType.equals(user.getUserType()))
            .filter(user -> isActive == null || isActive.equals(user.getIsActive()))
            .map(this::mapToPersonnelResponse);
    }

    /**
     * Récupère un personnel par ID
     */
    public Mono<PersonnelResponse> getPersonnelById(UUID personnelId) {
        log.debug("Fetching personnel by ID: {}", personnelId);

        return userRepository.findById(personnelId)
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .map(this::mapToPersonnelResponse);
    }

    /**
     * Met à jour un membre du personnel
     */
    public Mono<PersonnelResponse> updatePersonnel(UUID personnelId, UpdatePersonnelRequest updateRequest, UUID updatedBy) {
        log.info("Updating personnel: {}", personnelId);

        return userRepository.findById(personnelId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Personnel non trouvé")))
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("L'utilisateur n'est pas un membre du personnel")))
            .flatMap(personnel -> {
                // Mettre à jour les champs modifiables
                if (updateRequest.getFirstName() != null) {
                    personnel.setFirstName(updateRequest.getFirstName());
                }
                if (updateRequest.getLastName() != null) {
                    personnel.setLastName(updateRequest.getLastName());
                }
                if (updateRequest.getPhone() != null) {
                    personnel.setPhone(updateRequest.getPhone());
                }
                if (updateRequest.getEmployeeId() != null) {
                    personnel.setEmployeeId(updateRequest.getEmployeeId());
                }
                if (updateRequest.getDepartment() != null) {
                    personnel.setDepartment(updateRequest.getDepartment());
                }
                if (updateRequest.getPosition() != null) {
                    personnel.setPosition(updateRequest.getPosition());
                }
                if (updateRequest.getSupervisorId() != null) {
                    personnel.setSupervisorId(updateRequest.getSupervisorId());
                }

                personnel.setUpdatedAt(LocalDateTime.now());
                personnel.setUpdatedBy(updatedBy);

                return userRepository.save(personnel);
            })
            .map(this::mapToPersonnelResponse);
    }

    /**
     * Assigne un personnel à une agence
     */
    public Mono<PersonnelResponse> assignToAgency(UUID personnelId, UUID agencyId, UUID assignedBy) {
        log.info("Assigning personnel {} to agency: {}", personnelId, agencyId);

        return userRepository.findById(personnelId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Personnel non trouvé")))
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("L'utilisateur n'est pas un membre du personnel")))
            .flatMap(personnel -> {
                personnel.setAgencyId(agencyId);
                personnel.setUpdatedAt(LocalDateTime.now());
                personnel.setUpdatedBy(assignedBy);

                return userRepository.save(personnel);
            })
            .map(this::mapToPersonnelResponse);
    }

    /**
     * Met à jour le statut d'un personnel
     */
    public Mono<PersonnelResponse> updateStatus(UUID personnelId, Boolean isActive, UUID updatedBy) {
        log.info("Updating personnel {} status to: {}", personnelId, isActive);

        return userRepository.findById(personnelId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Personnel non trouvé")))
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("L'utilisateur n'est pas un membre du personnel")))
            .flatMap(personnel -> {
                personnel.setIsActive(isActive);
                personnel.setUpdatedAt(LocalDateTime.now());
                personnel.setUpdatedBy(updatedBy);

                return userRepository.save(personnel);
            })
            .map(this::mapToPersonnelResponse);
    }

    /**
     * Supprime un personnel
     */
    public Mono<Void> deletePersonnel(UUID personnelId, UUID deletedBy) {
        log.info("Deleting personnel: {}", personnelId);

        return userRepository.findById(personnelId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Personnel non trouvé")))
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("L'utilisateur n'est pas un membre du personnel")))
            .flatMap(personnel -> userRepository.deleteById(personnelId));
    }

    /**
     * Récupère le personnel d'une agence
     */
    public Flux<PersonnelResponse> getPersonnelByAgency(UUID agencyId, UserType userType) {
        log.debug("Fetching personnel for agency: {}, type: {}", agencyId, userType);

        return userRepository.findAll()
            .filter(user -> agencyId.equals(user.getAgencyId()))
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .filter(user -> userType == null || userType.equals(user.getUserType()))
            .map(this::mapToPersonnelResponse);
    }

    /**
     * Vérifie si un utilisateur est du personnel
     */
    public Mono<Boolean> isPersonnel(UUID userId) {
        return userRepository.findById(userId)
            .map(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .defaultIfEmpty(false);
    }

    /**
     * Récupère les informations d'agence pour un personnel (pour la redirection après login)
     */
    public Mono<AgencyRedirectInfo> getPersonnelAgencyInfo(UUID personnelId) {
        log.debug("Getting agency info for personnel: {}", personnelId);

        return userRepository.findById(personnelId)
            .filter(user -> PERSONNEL_TYPES.contains(user.getUserType()))
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Utilisateur n'est pas du personnel")))
            .map(personnel -> {
                AgencyRedirectInfo redirectInfo = new AgencyRedirectInfo();
                redirectInfo.setPersonnelId(personnel.getId());
                redirectInfo.setOrganizationId(personnel.getOrganizationId());
                redirectInfo.setAgencyId(personnel.getAgencyId());
                redirectInfo.setUserType(personnel.getUserType());
                redirectInfo.setEmployeeId(personnel.getEmployeeId());
                redirectInfo.setDepartment(personnel.getDepartment());
                redirectInfo.setPosition(personnel.getPosition());
                redirectInfo.setRequiresPasswordChange(personnel.getMustChangePassword());
                return redirectInfo;
            });
    }

    /**
     * Mappe une entité User vers PersonnelResponse
     */
    private PersonnelResponse mapToPersonnelResponse(User user) {
        PersonnelResponse response = new PersonnelResponse();
        response.setId(user.getId());
        response.setEmail(user.getEmail());
        response.setFirstName(user.getFirstName());
        response.setLastName(user.getLastName());
        response.setFullName(user.getFullName());
        response.setPhone(user.getPhone());
        response.setUserType(user.getUserType());
        response.setOrganizationId(user.getOrganizationId());
        response.setAgencyId(user.getAgencyId());
        response.setEmployeeId(user.getEmployeeId());
        response.setDepartment(user.getDepartment());
        response.setPosition(user.getPosition());
        response.setSupervisorId(user.getSupervisorId());
        response.setHiredAt(user.getHiredAt());
        response.setIsActive(user.getIsActive());
        response.setIsEmailVerified(user.getIsEmailVerified());
        response.setIsPhoneVerified(user.getIsPhoneVerified());
        response.setMustChangePassword(user.getMustChangePassword());
        response.setLastLoginAt(user.getLastLoginAt());
        response.setCreatedAt(user.getCreatedAt());
        response.setProfilePicture(user.getProfilePicture());
        return response;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\RoleReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.dto.Permission;
import inc.yowyob.rental_api_reactive.application.dto.RoleType;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.Role;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.UserRoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.mapper.RoleMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class RoleReactiveService {

    private final RoleReactiveRepository roleRepository;
    private final UserRoleReactiveRepository userRoleRepository;
    private final RoleMapper roleMapper;

    /**
     * Crée un nouveau rôle
     */
    public Mono<RoleResponse> createRole(CreateRoleRequest request, UUID createdBy) {
        log.info("Creating role: {} for organization: {}", request.getName(), request.getOrganizationId());

        return roleRepository.countByOrganizationIdAndName(request.getOrganizationId(), request.getName())
            .flatMap(count -> {
                if (count > 0) {
                    return Mono.error(new IllegalArgumentException("Role name already exists in organization"));
                }
                return createNewRole(request, createdBy);
            });
    }

    private Mono<RoleResponse> createNewRole(CreateRoleRequest request, UUID createdBy) {
        return validatePermissions(request.getPermissions())
            .then(Mono.fromCallable(() -> {
                Role role = new Role(
                    request.getName(),
                    request.getDescription(),
                    request.getOrganizationId()
                );

                role.setRoleType(request.getRoleType() != null ? request.getRoleType() : RoleType.CUSTOM);
                role.setPriority(request.getPriority() != null ? request.getPriority() : 0);
                role.setPermissions(request.getPermissions());
                role.setColor(request.getColor());
                role.setIcon(request.getIcon());
                role.setCreatedBy(createdBy);
                role.setUpdatedBy(createdBy);

                return role;
            }))
            .flatMap(roleRepository::save)
            .map(roleMapper::toResponse)
            .doOnSuccess(role -> log.info("Role created: {}", role.getId()))
            .doOnError(error -> log.error("Failed to create role: {}", request.getName(), error));
    }

    /**
     * Récupère les permissions d'un rôle
     */
    public Mono<RolePermissionsResponse> getRolePermissions(UUID roleId) {
        log.debug("Getting permissions for role: {}", roleId);

        return roleRepository.findById(roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Role not found")))
            .map(role -> {
                Set<PermissionResponse> permissionDetails = role.getPermissions().stream()
                    .map(permCode -> {
                        for (Permission permission : Permission.values()) {
                            if (permission.getCode().equals(permCode)) {
                                return PermissionResponse.builder()
                                    .code(permission.getCode())
                                    .description(permission.getDescription())
                                    .resource(permission.getResource())
                                    .build();
                            }
                        }
                        return PermissionResponse.builder()
                            .code(permCode)
                            .description("Unknown permission")
                            .resource("UNKNOWN")
                            .build();
                    })
                    .collect(Collectors.toSet());

                return RolePermissionsResponse.builder()
                    .roleId(roleId)
                    .roleName(role.getName())
                    .permissions(role.getPermissions())
                    .permissionDetails(permissionDetails)
                    .totalCount(role.getPermissions().size())
                    .build();
            });
    }

    /**
     * Met à jour un rôle existant
     */
    public Mono<RoleResponse> updateRole(UUID roleId, UpdateRoleRequest request, UUID updatedBy) {
        log.info("Updating role: {}", roleId);

        return roleRepository.findById(roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Role not found")))
            .flatMap(role -> {
                if (Boolean.TRUE.equals(role.getIsSystemRole())) {
                    return Mono.error(new IllegalArgumentException("Cannot modify system role"));
                }
                return updateRoleEntity(role, request, updatedBy);
            });
    }

    private Mono<RoleResponse> updateRoleEntity(Role role, UpdateRoleRequest request, UUID updatedBy) {
        return validatePermissions(request.getPermissions())
            .then(Mono.fromCallable(() -> {
                if (request.getName() != null) role.setName(request.getName());
                if (request.getDescription() != null) role.setDescription(request.getDescription());
                if (request.getPermissions() != null) role.setPermissions(request.getPermissions());
                if (request.getPriority() != null) role.setPriority(request.getPriority());
                if (request.getColor() != null) role.setColor(request.getColor());
                if (request.getIcon() != null) role.setIcon(request.getIcon());

                role.setUpdatedBy(updatedBy);
                role.preUpdate();

                return role;
            }))
            .flatMap(roleRepository::save)
            .map(roleMapper::toResponse);
    }

    /**
     * Supprime un rôle
     */
    public Mono<Void> deleteRole(UUID roleId) {
        log.info("Deleting role: {}", roleId);

        return roleRepository.findById(roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Role not found")))
            .flatMap(role -> {
                if (Boolean.TRUE.equals(role.getIsSystemRole())) {
                    return Mono.error(new IllegalArgumentException("Cannot delete system role"));
                }
                if (Boolean.TRUE.equals(role.getIsDefaultRole())) {
                    return Mono.error(new IllegalArgumentException("Cannot delete default role"));
                }

                // Vérifier qu'aucun utilisateur n'a ce rôle
                return userRoleRepository.countByRoleId(roleId)
                    .flatMap(count -> {
                        if (count > 0) {
                            return Mono.error(new IllegalArgumentException("Cannot delete role assigned to users"));
                        }
                        return roleRepository.deleteById(roleId);
                    });
            });
    }

    /**
     * Récupère tous les rôles d'une organisation
     */
    public Flux<RoleResponse> getRolesByOrganization(UUID organizationId) {
        log.debug("Getting roles for organization: {}", organizationId);

        return roleRepository.findByOrganizationId(organizationId)
            .map(roleMapper::toResponse);
    }

    /**
     * Récupère un rôle par son ID
     */
    public Mono<RoleResponse> getRoleById(UUID roleId) {
        log.debug("Getting role: {}", roleId);

        return roleRepository.findById(roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Role not found")))
            .map(roleMapper::toResponse);
    }

    /**
     * Récupère les rôles par défaut d'une organisation
     */
    public Flux<RoleResponse> getDefaultRoles(UUID organizationId) {
        log.debug("Getting default roles for organization: {}", organizationId);

        return roleRepository.findDefaultRolesByOrganizationId(organizationId)
            .map(roleMapper::toResponse);
    }

    /**
     * Récupère les rôles système
     */
    public Flux<RoleResponse> getSystemRoles() {
        log.debug("Getting system roles");

        return roleRepository.findSystemRoles()
            .map(roleMapper::toResponse);
    }

    /**
     * Valide les permissions
     */
    private Mono<Void> validatePermissions(Set<String> permissions) {
        if (permissions == null || permissions.isEmpty()) {
            return Mono.empty();
        }

        Set<String> validPermissions = Arrays.stream(Permission.values())
            .map(Permission::getCode)
            .collect(Collectors.toSet());

        for (String permission : permissions) {
            if (!validPermissions.contains(permission)) {
                return Mono.error(new IllegalArgumentException("Invalid permission: " + permission));
            }
        }

        return Mono.empty();
    }

    /**
     * Clone un rôle avec un nouveau nom
     */
    public Mono<RoleResponse> cloneRole(UUID roleId, String newName, UUID createdBy) {
        log.info("Cloning role: {} with new name: {}", roleId, newName);

        return roleRepository.findById(roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Role not found")))
            .flatMap(originalRole -> {
                // Vérifier que le nouveau nom n'existe pas
                return roleRepository.countByOrganizationIdAndName(originalRole.getOrganizationId(), newName)
                    .flatMap(count -> {
                        if (count > 0) {
                            return Mono.error(new IllegalArgumentException("Role name already exists"));
                        }

                        Role clonedRole = new Role(
                            newName,
                            "Clone of " + originalRole.getName(),
                            originalRole.getOrganizationId()
                        );

                        clonedRole.setRoleType(RoleType.CUSTOM);
                        clonedRole.setPermissions(originalRole.getPermissions());
                        clonedRole.setPriority(originalRole.getPriority());
                        clonedRole.setColor(originalRole.getColor());
                        clonedRole.setIcon(originalRole.getIcon());
                        clonedRole.setCreatedBy(createdBy);
                        clonedRole.setUpdatedBy(createdBy);

                        return roleRepository.save(clonedRole);
                    });
            })
            .map(roleMapper::toResponse);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\SubscriptionPlanReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import inc.yowyob.rental_api_reactive.persistence.repository.SubscriptionPlanReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.math.BigDecimal;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class SubscriptionPlanReactiveService {

    private final SubscriptionPlanReactiveRepository subscriptionPlanRepository;

    /**
     * Récupère tous les plans d'abonnement actifs
     */
    public Flux<SubscriptionPlan> getAllActivePlans() {
        log.debug("Fetching all active subscription plans");
        return subscriptionPlanRepository.findAllActive()
            .doOnNext(plan -> log.debug("Found active plan: {}", plan.getName()))
            .doOnComplete(() -> log.info("Successfully fetched all active plans"));
    }

    /**
     * Récupère un plan d'abonnement par ID
     */
    public Mono<SubscriptionPlan> getPlanById(UUID planId) {
        log.debug("Fetching subscription plan with ID: {}", planId);
        return subscriptionPlanRepository.findById(planId)
            .doOnNext(plan -> log.debug("Found plan: {}", plan.getName()))
            .doOnSuccess(plan -> {
                if (plan != null) {
                    log.info("Successfully fetched plan: {}", planId);
                } else {
                    log.warn("Plan not found: {}", planId);
                }
            });
    }

    /**
     * Récupère les plans populaires
     */
    public Flux<SubscriptionPlan> getPopularPlans() {
        log.debug("Fetching popular subscription plans");
        return subscriptionPlanRepository.findPopularPlans()
            .doOnNext(plan -> log.debug("Found popular plan: {}", plan.getName()))
            .doOnComplete(() -> log.info("Successfully fetched popular plans"));
    }

    /**
     * Récupère les plans standards (non personnalisés)
     */
    public Flux<SubscriptionPlan> getStandardPlans() {
        log.debug("Fetching standard subscription plans");
        return subscriptionPlanRepository.findStandardPlans()
            .doOnNext(plan -> log.debug("Found standard plan: {}", plan.getName()))
            .doOnComplete(() -> log.info("Successfully fetched standard plans"));
    }

    /**
     * Sauvegarde un plan d'abonnement
     */
    public Mono<SubscriptionPlan> savePlan(SubscriptionPlan plan) {
        log.info("Saving subscription plan: {}", plan.getName());
        return subscriptionPlanRepository.save(plan)
            .doOnSuccess(savedPlan -> log.info("Successfully saved plan: {}", savedPlan.getId()));
    }

    /**
     * Vérifie si un plan existe par nom
     */
    public Mono<Boolean> existsByName(String name) {
        log.debug("Checking if plan exists with name: {}", name);
        return subscriptionPlanRepository.findAllActive()
            .filter(plan -> name.equals(plan.getName()))
            .hasElements()
            .doOnNext(exists -> log.debug("Plan exists with name {}: {}", name, exists));
    }

    /**
     * Supprime un plan d'abonnement (soft delete)
     */
    public Mono<SubscriptionPlan> deactivatePlan(UUID planId) {
        log.info("Deactivating subscription plan: {}", planId);
        return subscriptionPlanRepository.findById(planId)
            .switchIfEmpty(Mono.error(new RuntimeException("Plan not found: " + planId)))
            .map(plan -> {
                plan.setIsActive(false);
                return plan;
            })
            .flatMap(subscriptionPlanRepository::save)
            .doOnSuccess(plan -> log.info("Successfully deactivated plan: {}", planId));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\SubscriptionValidationReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.ResourceLimitInfo;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.SubscriptionChangeValidation;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.SubscriptionLimitsResponse;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.SubscriptionValidationResult;
import inc.yowyob.rental_api_reactive.persistence.entity.Organization;
import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import inc.yowyob.rental_api_reactive.persistence.repository.OrganizationReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.SubscriptionPlanReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.AgencyReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Service de validation des limites d'abonnement
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class SubscriptionValidationReactiveService {

    private final OrganizationReactiveRepository organizationRepository;
    private final SubscriptionPlanReactiveRepository subscriptionPlanRepository;
    private final AgencyReactiveRepository agencyRepository;

    /**
     * Valide si une organisation peut créer une nouvelle agence
     */
    public Mono<Boolean> validateAgencyCreationLimit(UUID organizationId) {
        log.debug("Validating agency creation limit for organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                // Vérifier que l'abonnement est actif
                if (!organization.isSubscriptionActive()) {
                    log.warn("Organization {} has expired subscription", organizationId);
                    return Mono.just(false);
                }

                // Compter les agences actuelles
                return agencyRepository.countActiveByOrganizationId(organizationId)
                    .map(currentAgencies -> {
                        boolean canCreate = currentAgencies < organization.getMaxAgencies();

                        if (!canCreate) {
                            log.warn("Organization {} has reached agency limit: {}/{}",
                                organizationId, currentAgencies, organization.getMaxAgencies());
                        }

                        return canCreate;
                    });
            })
            .doOnNext(canCreate -> log.debug("Agency creation validation result for organization {}: {}",
                organizationId, canCreate));
    }

    /**
     * Valide si une organisation peut ajouter un véhicule
     */
    public Mono<Boolean> validateVehicleCreationLimit(UUID organizationId) {
        log.debug("Validating vehicle creation limit for organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .map(organization -> {
                if (!organization.isSubscriptionActive()) {
                    log.warn("Organization {} has expired subscription", organizationId);
                    return false;
                }

                boolean canCreate = organization.canAddVehicle();

                if (!canCreate) {
                    log.warn("Organization {} has reached vehicle limit: {}/{}",
                        organizationId, organization.getCurrentVehicles(), organization.getMaxVehicles());
                }

                return canCreate;
            });
    }

    /**
     * Valide si une organisation peut ajouter un chauffeur
     */
    public Mono<Boolean> validateDriverCreationLimit(UUID organizationId) {
        log.debug("Validating driver creation limit for organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .map(organization -> {
                if (!organization.isSubscriptionActive()) {
                    log.warn("Organization {} has expired subscription", organizationId);
                    return false;
                }

                boolean canCreate = organization.canAddDriver();

                if (!canCreate) {
                    log.warn("Organization {} has reached driver limit: {}/{}",
                        organizationId, organization.getCurrentDrivers(), organization.getMaxDrivers());
                }

                return canCreate;
            });
    }

    /**
     * Valide si une organisation peut ajouter un utilisateur
     */
    public Mono<Boolean> validateUserCreationLimit(UUID organizationId) {
        log.debug("Validating user creation limit for organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .map(organization -> {
                if (!organization.isSubscriptionActive()) {
                    log.warn("Organization {} has expired subscription", organizationId);
                    return false;
                }

                boolean canCreate = organization.canAddUser();

                if (!canCreate) {
                    log.warn("Organization {} has reached user limit: {}/{}",
                        organizationId, organization.getCurrentUsers(), organization.getMaxUsers());
                }

                return canCreate;
            });
    }

    /**
     * Obtient les limites actuelles d'une organisation
     */
    public Mono<SubscriptionLimitsResponse> getOrganizationLimits(UUID organizationId) {
        log.debug("Getting subscription limits for organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                return agencyRepository.countActiveByOrganizationId(organizationId)
                    .map(activeAgencies -> buildLimitsResponse(organization, activeAgencies.intValue()));
            });
    }

    /**
     * Vérifie si une fonctionnalité est disponible selon le plan d'abonnement
     */
    public Mono<Boolean> isFeatureAvailable(UUID organizationId, String featureName) {
        log.debug("Checking feature availability: {} for organization: {}", featureName, organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                if (!organization.isSubscriptionActive()) {
                    return Mono.just(false);
                }

                if (organization.getSubscriptionPlanId() == null) {
                    return Mono.just(false);
                }

                return subscriptionPlanRepository.findById(organization.getSubscriptionPlanId())
                    .map(plan -> isFeatureEnabledInPlan(plan, featureName))
                    .defaultIfEmpty(false);
            });
    }

    /**
     * Valide toutes les limites pour une organisation
     */
    public Mono<SubscriptionValidationResult> validateAllLimits(UUID organizationId) {
        log.debug("Validating all limits for organization: {}", organizationId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .flatMap(organization -> {
                return agencyRepository.countActiveByOrganizationId(organizationId)
                    .map(activeAgencies -> {
                        SubscriptionValidationResult result = new SubscriptionValidationResult();
                        result.setOrganizationId(organizationId);
                        result.setSubscriptionActive(organization.isSubscriptionActive());

                        // Vérification des limites
                        result.setCanCreateAgency(activeAgencies < organization.getMaxAgencies());
                        result.setCanAddVehicle(organization.canAddVehicle());
                        result.setCanAddDriver(organization.canAddDriver());
                        result.setCanAddUser(organization.canAddUser());

                        // Calcul des pourcentages d'utilisation
                        result.setAgencyUsagePercentage(organization.getAgencyUsagePercentage());
                        result.setVehicleUsagePercentage(organization.getVehicleUsagePercentage());
                        result.setDriverUsagePercentage(organization.getDriverUsagePercentage());
                        result.setUserUsagePercentage(organization.getUserUsagePercentage());

                        // Alertes
                        result.setHasLimitWarnings(
                            result.getAgencyUsagePercentage() > 80 ||
                                result.getVehicleUsagePercentage() > 80 ||
                                result.getDriverUsagePercentage() > 80 ||
                                result.getUserUsagePercentage() > 80
                        );

                        result.setSubscriptionExpiringSoon(organization.isSubscriptionExpiringSoon());

                        return result;
                    });
            });
    }

    /**
     * Valide et applique les limites lors de l'upgrade/downgrade d'abonnement
     */
    public Mono<SubscriptionChangeValidation> validateSubscriptionChange(UUID organizationId, UUID newPlanId) {
        log.debug("Validating subscription change for organization {} to plan {}", organizationId, newPlanId);

        return organizationRepository.findById(organizationId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("Organisation non trouvée")))
            .zipWith(subscriptionPlanRepository.findById(newPlanId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Plan d'abonnement non trouvé"))))
            .flatMap(tuple -> {
                Organization organization = tuple.getT1();
                SubscriptionPlan newPlan = tuple.getT2();

                return agencyRepository.countActiveByOrganizationId(organizationId)
                    .map(activeAgencies -> {
                        SubscriptionChangeValidation validation = new SubscriptionChangeValidation();
                        validation.setOrganizationId(organizationId);
                        validation.setNewPlanId(newPlanId);
                        validation.setIsUpgrade(newPlan.getPrice().compareTo(getCurrentPlanPrice(organization)) > 0);

                        // Vérifier les contraintes du nouveau plan
                        validation.setAgencyLimitSufficient(activeAgencies <= newPlan.getMaxAgencies());
                        validation.setVehicleLimitSufficient(organization.getCurrentVehicles() <= newPlan.getMaxVehicles());
                        validation.setDriverLimitSufficient(organization.getCurrentDrivers() <= newPlan.getMaxDrivers());
                        validation.setUserLimitSufficient(organization.getCurrentUsers() <= newPlan.getMaxUsers());

                        validation.setCanChange(
                            validation.getAgencyLimitSufficient() &&
                                validation.getVehicleLimitSufficient() &&
                                validation.getDriverLimitSufficient() &&
                                validation.getUserLimitSufficient()
                        );

                        if (!validation.getCanChange()) {
                            validation.setBlockingReasons(buildBlockingReasons(validation, organization, newPlan));
                        }

                        return validation;
                    });
            });
    }

    // === MÉTHODES PRIVÉES ===

    /**
     * Construit la réponse des limites
     */
    private SubscriptionLimitsResponse buildLimitsResponse(Organization organization, int activeAgencies) {
        return SubscriptionLimitsResponse.builder()
            .organizationId(organization.getId())
            .subscriptionActive(organization.isSubscriptionActive())
            .subscriptionExpiresAt(organization.getSubscriptionExpiresAt())
            .agencyLimits(ResourceLimitInfo.builder()
                .current(activeAgencies)
                .maximum(organization.getMaxAgencies())
                .available(organization.getMaxAgencies() - activeAgencies)
                .usagePercentage(organization.getAgencyUsagePercentage())
                .build())
            .vehicleLimits(ResourceLimitInfo.builder()
                .current(organization.getCurrentVehicles())
                .maximum(organization.getMaxVehicles())
                .available(organization.getMaxVehicles() - organization.getCurrentVehicles())
                .usagePercentage(organization.getVehicleUsagePercentage())
                .build())
            .driverLimits(ResourceLimitInfo.builder()
                .current(organization.getCurrentDrivers())
                .maximum(organization.getMaxDrivers())
                .available(organization.getMaxDrivers() - organization.getCurrentDrivers())
                .usagePercentage(organization.getDriverUsagePercentage())
                .build())
            .userLimits(ResourceLimitInfo.builder()
                .current(organization.getCurrentUsers())
                .maximum(organization.getMaxUsers())
                .available(organization.getMaxUsers() - organization.getCurrentUsers())
                .usagePercentage(organization.getUserUsagePercentage())
                .build())
            .build();
    }

    /**
     * Vérifie si une fonctionnalité est activée dans un plan
     */
    private boolean isFeatureEnabledInPlan(SubscriptionPlan plan, String featureName) {
        // TODO: Implémenter selon les fonctionnalités du plan
        switch (featureName.toLowerCase()) {
            case "geofencing":
                return plan.getHasGeofencing();
            case "chat":
                return plan.getHasChat();
            case "analytics":
                return plan.getHasAnalytics();
            case "api_access":
            default:
                return false;
        }
    }

    /**
     * Obtient le prix du plan actuel
     */
    private java.math.BigDecimal getCurrentPlanPrice(Organization organization) {
        // TODO: Récupérer le prix du plan actuel
        return java.math.BigDecimal.ZERO;
    }

    /**
     * Construit les raisons bloquantes pour un changement d'abonnement
     */
    private java.util.List<String> buildBlockingReasons(SubscriptionChangeValidation validation, Organization organization, SubscriptionPlan newPlan) {
        java.util.List<String> reasons = new java.util.ArrayList<>();

        if (!validation.getAgencyLimitSufficient()) {
            reasons.add(String.format("Trop d'agences actives (%d) pour le nouveau plan (limite: %d)",
                organization.getCurrentAgencies(), newPlan.getMaxAgencies()));
        }

        if (!validation.getVehicleLimitSufficient()) {
            reasons.add(String.format("Trop de véhicules (%d) pour le nouveau plan (limite: %d)",
                organization.getCurrentVehicles(), newPlan.getMaxVehicles()));
        }

        if (!validation.getDriverLimitSufficient()) {
            reasons.add(String.format("Trop de chauffeurs (%d) pour le nouveau plan (limite: %d)",
                organization.getCurrentDrivers(), newPlan.getMaxDrivers()));
        }

        if (!validation.getUserLimitSufficient()) {
            reasons.add(String.format("Trop d'utilisateurs (%d) pour le nouveau plan (limite: %d)",
                organization.getCurrentUsers(), newPlan.getMaxUsers()));
        }

        return reasons;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\UserDetailsReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.Collections;

/**
 * Service réactif pour le chargement des détails utilisateur
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class UserDetailsReactiveService implements ReactiveUserDetailsService {

    private final UserReactiveRepository userRepository;

    @Override
    public Mono<UserDetails> findByUsername(String email) {
        log.debug("Loading user by email: {}", email);

        return userRepository.findByEmail(email)
            .switchIfEmpty(Mono.error(new UsernameNotFoundException("User not found with email: " + email)))
            .map(this::createUserDetails)
            .doOnNext(userDetails -> log.debug("User loaded successfully: {}", email))
            .doOnError(error -> log.error("Failed to load user: {}", email, error));
    }

    /**
     * Crée un objet UserDetails à partir d'un utilisateur
     */
    private UserDetails createUserDetails(User user) {
        return org.springframework.security.core.userdetails.User.builder()
            .username(user.getEmail())
            .password(user.getPassword())
            .disabled(!user.getIsActive())
            .accountExpired(false)
            .accountLocked(user.getLockedUntil() != null && user.getLockedUntil().isAfter(java.time.LocalDateTime.now()))
            .credentialsExpired(false)
            .authorities(Collections.emptyList()) // À implémenter selon les rôles
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\UserReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Service réactif pour la gestion des utilisateurs (Mis à jour)
 * Route: src/main/java/inc/yowyob/rental_api_reactive/application/service/UserReactiveService.java
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class UserReactiveService {

    private final UserReactiveRepository userRepository;

    /**
     * Trouve tous les utilisateurs
     */
    public Flux<UserResponse> findAll() {
        log.debug("Finding all users");
        return userRepository.findNonDeletedUsers()
            .map(this::mapToUserResponse)
            .doOnNext(user -> log.debug("Found user: {}", user.getEmail()));
    }

    /**
     * Trouve un utilisateur par ID
     */
    public Mono<UserResponse> findById(UUID id) {
        log.debug("Finding user by ID: {}", id);
        return userRepository.findById(id)
            .filter(user -> !user.getIsDeleted())
            .map(this::mapToUserResponse)
            .doOnNext(user -> log.debug("Found user: {}", user.getEmail()));
    }

    /**
     * Trouve un utilisateur par email
     */
    public Mono<UserResponse> findByEmail(String email) {
        log.debug("Finding user by email: {}", email);
        return userRepository.findByEmail(email)
            .filter(user -> !user.getIsDeleted())
            .map(this::mapToUserResponse)
            .doOnNext(user -> log.debug("Found user: {}", user.getEmail()));
    }

    /**
     * Trouve les utilisateurs par organisation
     */
    public Flux<UserResponse> findByOrganizationId(UUID organizationId) {
        log.debug("Finding users by organization ID: {}", organizationId);
        return userRepository.findByOrganizationId(organizationId)
            .filter(user -> !user.getIsDeleted())
            .map(this::mapToUserResponse)
            .doOnNext(user -> log.debug("Found user in organization: {}", user.getEmail()));
    }

    /**
     * Vérifie si un email existe
     */
    public Mono<Boolean> existsByEmail(String email) {
        log.debug("Checking if email exists: {}", email);
        return userRepository.countByEmail(email)
            .map(count -> count > 0)
            .doOnNext(exists -> log.debug("Email {} exists: {}", email, exists));
    }

    /**
     * Sauvegarde un utilisateur
     */
    public Mono<UserResponse> save(User user) {
        log.debug("Saving user: {}", user.getEmail());
        user.prePersist();
        return userRepository.save(user)
            .map(this::mapToUserResponse)
            .doOnNext(saved -> log.info("User saved successfully: {}", saved.getEmail()));
    }

    /**
     * Met à jour le profil utilisateur
     */
    public Mono<UserResponse> updateProfile(UUID userId, UpdateProfileRequest updateRequest) {
        log.info("Updating user profile: {}", userId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .filter(user -> !user.getIsDeleted())
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User has been deleted")))
            .flatMap(user -> {
                // Mettre à jour les champs modifiables
                if (updateRequest.getFirstName() != null) {
                    user.setFirstName(updateRequest.getFirstName());
                }
                if (updateRequest.getLastName() != null) {
                    user.setLastName(updateRequest.getLastName());
                }
                if (updateRequest.getPhone() != null) {
                    user.setPhone(updateRequest.getPhone());
                }
                if (updateRequest.getAddress() != null) {
                    user.setAddress(updateRequest.getAddress());
                }
                if (updateRequest.getCity() != null) {
                    user.setCity(updateRequest.getCity());
                }
                if (updateRequest.getCountry() != null) {
                    user.setCountry(updateRequest.getCountry());
                }
                if (updateRequest.getProfilePicture() != null) {
                    user.setProfilePicture(updateRequest.getProfilePicture());
                }

                user.preUpdate();
                return userRepository.save(user);
            })
            .map(this::mapToUserResponse)
            .doOnSuccess(response -> log.info("User profile updated successfully: {}", userId));
    }

    /**
     * Met à jour la photo de profil
     */
    public Mono<String> updateAvatar(UUID userId, String avatarUrl) {
        log.info("Updating avatar for user: {}", userId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .filter(user -> !user.getIsDeleted())
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User has been deleted")))
            .flatMap(user -> {
                user.setProfilePicture(avatarUrl);
                user.preUpdate();
                return userRepository.save(user);
            })
            .map(User::getProfilePicture)
            .doOnSuccess(url -> log.info("Avatar updated successfully for user: {}", userId));
    }

    /**
     * Supprime la photo de profil
     */
    public Mono<Void> deleteAvatar(UUID userId) {
        log.info("Deleting avatar for user: {}", userId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .filter(user -> !user.getIsDeleted())
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User has been deleted")))
            .flatMap(user -> {
                user.setProfilePicture(null);
                user.preUpdate();
                return userRepository.save(user);
            })
            .then()
            .doOnSuccess(v -> log.info("Avatar deleted successfully for user: {}", userId));
    }

    /**
     * Met à jour les préférences utilisateur
     */
    public Mono<UserResponse> updatePreferences(UUID userId, UserPreferencesRequest preferencesRequest) {
        log.info("Updating preferences for user: {}", userId);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .filter(user -> !user.getIsDeleted())
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User has been deleted")))
            .flatMap(user -> {
                // Mettre à jour les préférences
                if (preferencesRequest.getPreferredLanguage() != null) {
                    user.setPreferredLanguage(preferencesRequest.getPreferredLanguage());
                }
                if (preferencesRequest.getTimezone() != null) {
                    user.setTimezone(preferencesRequest.getTimezone());
                }
                if (preferencesRequest.getEmailNotifications() != null) {
                    user.setEmailNotifications(preferencesRequest.getEmailNotifications());
                }
                if (preferencesRequest.getSmsNotifications() != null) {
                    user.setSmsNotifications(preferencesRequest.getSmsNotifications());
                }
                if (preferencesRequest.getCurrency() != null) {
                    user.setCurrency(preferencesRequest.getCurrency());
                }
                if (preferencesRequest.getDateFormat() != null) {
                    user.setDateFormat(preferencesRequest.getDateFormat());
                }

                user.preUpdate();
                return userRepository.save(user);
            })
            .map(this::mapToUserResponse)
            .doOnSuccess(response -> log.info("Preferences updated successfully for user: {}", userId));
    }

    /**
     * Désactive un compte utilisateur (soft delete)
     */
    public Mono<Void> deactivateAccount(UUID userId, String reason) {
        log.info("Deactivating account for user: {} with reason: {}", userId, reason);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .flatMap(user -> {
                user.markAsDeleted(userId); // Self-deactivation
                // Note: En production, enregistrer la raison dans une table d'audit
                return userRepository.save(user);
            })
            .then()
            .doOnSuccess(v -> log.info("Account deactivated successfully for user: {}", userId));
    }

    /**
     * Active/Désactive un utilisateur
     */
    public Mono<UserResponse> updateUserStatus(UUID userId, Boolean isActive, UUID updatedBy) {
        log.info("Updating user status: {} to {}", userId, isActive);

        return userRepository.findById(userId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .flatMap(user -> {
                user.setIsActive(isActive);
                user.setUpdatedBy(updatedBy);
                user.preUpdate();
                return userRepository.save(user);
            })
            .map(this::mapToUserResponse)
            .doOnSuccess(response -> log.info("User status updated successfully: {}", userId));
    }

    /**
     * Supprime un utilisateur par ID
     */
    public Mono<Void> deleteById(UUID id) {
        log.debug("Deleting user by ID: {}", id);
        return userRepository.deleteById(id)
            .doOnSuccess(v -> log.info("User deleted successfully: {}", id));
    }

    /**
     * Trouve les utilisateurs par type
     */
    public Flux<UserResponse> findByUserType(inc.yowyob.rental_api_reactive.application.dto.UserType userType) {
        log.debug("Finding users by type: {}", userType);
        return userRepository.findByUserType(userType)
            .filter(user -> !user.getIsDeleted())
            .map(this::mapToUserResponse);
    }

    /**
     * Trouve le personnel par organisation
     */
    public Flux<UserResponse> findPersonnelByOrganization(UUID organizationId) {
        log.debug("Finding personnel by organization: {}", organizationId);
        return userRepository.findPersonnelByOrganizationId(organizationId)
            .filter(user -> !user.getIsDeleted())
            .map(this::mapToUserResponse);
    }

    /**
     * Trouve le personnel par agence
     */
    public Flux<UserResponse> findPersonnelByAgency(UUID agencyId) {
        log.debug("Finding personnel by agency: {}", agencyId);
        return userRepository.findPersonnelByAgencyId(agencyId)
            .filter(user -> !user.getIsDeleted())
            .map(this::mapToUserResponse);
    }

    /**
     * Statistiques des utilisateurs par organisation
     */
    public Mono<UserStatsResponse> getUserStats(UUID organizationId) {
        log.debug("Getting user stats for organization: {}", organizationId);

        return Mono.zip(
            userRepository.countByOrganizationId(organizationId),
            userRepository.countActiveByOrganizationId(organizationId),
            userRepository.countPersonnelByOrganizationId(organizationId)
        ).map(tuple -> {
            UserStatsResponse stats = new UserStatsResponse();
            stats.setTotalUsers(tuple.getT1());
            stats.setActiveUsers(tuple.getT2());
            stats.setPersonnelCount(tuple.getT3());
            stats.setClientCount(tuple.getT1() - tuple.getT3()); // Approximation
            return stats;
        });
    }

    /**
     * Mappe une entité User vers UserResponse
     */
    private UserResponse mapToUserResponse(User user) {
        UserResponse response = new UserResponse();
        response.setId(user.getId());
        response.setEmail(user.getEmail());
        response.setFirstName(user.getFirstName());
        response.setLastName(user.getLastName());
        response.setFullName(user.getFullName());
        response.setPhone(user.getPhone());
        response.setUserType(user.getUserType());
        response.setOrganizationId(user.getOrganizationId());
        response.setAgencyId(user.getAgencyId());
        response.setProfilePicture(user.getProfilePicture());
        response.setAddress(user.getAddress());
        response.setCity(user.getCity());
        response.setCountry(user.getCountry());
        response.setIsEmailVerified(user.getIsEmailVerified());
        response.setIsPhoneVerified(user.getIsPhoneVerified());
        response.setPreferredLanguage(user.getPreferredLanguage());
        response.setTimezone(user.getTimezone());
        response.setCurrency(user.getCurrency());
        response.setDateFormat(user.getDateFormat());
        response.setEmailNotifications(user.getEmailNotifications());
        response.setSmsNotifications(user.getSmsNotifications());
        response.setPushNotifications(user.getPushNotifications());
        response.setLastLoginAt(user.getLastLoginAt());
        response.setCreatedAt(user.getCreatedAt());
        response.setIsActive(user.getIsActive());

        // Informations employé (si applicable)
        if (user.isPersonnel()) {
            response.setEmployeeId(user.getEmployeeId());
            response.setDepartment(user.getDepartment());
            response.setPosition(user.getPosition());
            response.setSupervisorId(user.getSupervisorId());
            response.setHiredAt(user.getHiredAt());
            response.setMustChangePassword(user.getMustChangePassword());
        }

        return response;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\application\service\UserRoleReactiveService.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.UserRole;
import inc.yowyob.rental_api_reactive.persistence.repository.UserRoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.mapper.UserRoleMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserRoleReactiveService {

    private final UserRoleReactiveRepository userRoleRepository;
    private final RoleReactiveRepository roleRepository;
    private final UserReactiveRepository userRepository;
    private final UserRoleMapper userRoleMapper;

    /**
     * Assigne un rôle à un utilisateur
     */
    public Mono<UserRoleResponse> assignRole(AssignRoleRequest request, UUID assignedBy) {
        log.info("Assigning role {} to user {} in organization {}",
            request.getRoleId(), request.getUserId(), request.getOrganizationId());

        return validateAssignmentRequest(request)
            .then(checkExistingAssignment(request))
            .then(createUserRole(request, assignedBy))
            .map(userRoleMapper::toResponse)
            .doOnSuccess(userRole -> log.info("Role assigned successfully: {}", userRole.getId()))
            .doOnError(error -> log.error("Failed to assign role", error));
    }

    private Mono<Void> validateAssignmentRequest(AssignRoleRequest request) {
        return userRepository.findById(request.getUserId())
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User not found")))
            .then(roleRepository.findById(request.getRoleId())
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Role not found"))))
            .then();
    }

    private Mono<Void> checkExistingAssignment(AssignRoleRequest request) {
        return userRoleRepository.findByUserIdAndRoleId(request.getUserId(), request.getRoleId())
            .filter(userRole -> userRole.getIsActive())
            .flatMap(existingRole -> Mono.error(new IllegalArgumentException("User already has this role")))
            .then();
    }

    private Mono<UserRole> createUserRole(AssignRoleRequest request, UUID assignedBy) {
        return Mono.fromCallable(() -> {
            UserRole userRole = new UserRole(
                request.getUserId(),
                request.getRoleId(),
                request.getOrganizationId(),
                request.getAgencyId()
            );

            userRole.setAssignedBy(assignedBy);
            if (request.getExpiresAt() != null) {
                userRole.setExpiresAt(request.getExpiresAt());
            }

            return userRole;
        }).flatMap(userRoleRepository::save);
    }

    /**
     * Révoque un rôle d'un utilisateur
     */
    public Mono<Void> revokeRole(UUID userId, UUID roleId, UUID revokedBy) {
        log.info("Revoking role {} from user {}", roleId, userId);

        return userRoleRepository.findByUserIdAndRoleId(userId, roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User role assignment not found")))
            .flatMap(userRole -> {
                userRole.revoke(revokedBy);
                return userRoleRepository.save(userRole);
            })
            .then()
            .doOnSuccess(v -> log.info("Role revoked successfully"))
            .doOnError(error -> log.error("Failed to revoke role", error));
    }

    /**
     * Récupère tous les rôles d'un utilisateur
     */
    public Flux<UserRoleResponse> getUserRoles(UUID userId) {
        log.debug("Getting roles for user: {}", userId);

        return userRoleRepository.findActiveByUserId(userId)
            .map(userRoleMapper::toResponse);
    }

    /**
     * Récupère tous les utilisateurs ayant un rôle spécifique
     */
    public Flux<UserRoleResponse> getUsersByRole(UUID roleId) {
        log.debug("Getting users with role: {}", roleId);

        return userRoleRepository.findByRoleId(roleId)
            .filter(userRole -> userRole.getIsActive())
            .map(userRoleMapper::toResponse);
    }

    /**
     * Supprime tous les rôles d'un utilisateur
     */
    public Mono<Void> revokeAllUserRoles(UUID userId, UUID revokedBy) {
        log.info("Revoking all roles from user: {}", userId);

        return userRoleRepository.findActiveByUserId(userId)
            .flatMap(userRole -> {
                userRole.revoke(revokedBy);
                return userRoleRepository.save(userRole);
            })
            .then()
            .doOnSuccess(v -> log.info("All roles revoked for user: {}", userId));
    }

    /**
     * Active un rôle temporairement désactivé
     */
    public Mono<UserRoleResponse> activateRole(UUID userId, UUID roleId) {
        log.info("Activating role {} for user {}", roleId, userId);

        return userRoleRepository.findByUserIdAndRoleId(userId, roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User role assignment not found")))
            .flatMap(userRole -> {
                userRole.activate();
                return userRoleRepository.save(userRole);
            })
            .map(userRoleMapper::toResponse);
    }

    /**
     * Étend l'expiration d'un rôle
     */
    public Mono<UserRoleResponse> extendRoleExpiration(UUID userId, UUID roleId, LocalDateTime newExpirationDate) {
        log.info("Extending role {} expiration for user {} to {}", roleId, userId, newExpirationDate);

        return userRoleRepository.findByUserIdAndRoleId(userId, roleId)
            .switchIfEmpty(Mono.error(new IllegalArgumentException("User role assignment not found")))
            .flatMap(userRole -> {
                userRole.setExpiration(newExpirationDate);
                return userRoleRepository.save(userRole);
            })
            .map(userRoleMapper::toResponse);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\config\AppProperties.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

/**
 * Configuration des propriétés de l'application
 * Route: src/main/java/inc/yowyob/rental_api_reactive/infrastructure/config/AppProperties.java
 */
@Data
@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    @JsonProperty("jwt")
    private Jwt jwt = new Jwt();

    @JsonProperty("cors")
    private Cors cors = new Cors();

    @JsonProperty("security")
    private Security security = new Security();

    @Data
    public static class Jwt {
        @JsonProperty("secret")
        private String secret = "mySecretKey123456789012345678901234567890";

        @JsonProperty("expiration")
        private long expiration = 86400000; // 24 heures en millisecondes

        @JsonProperty("refreshExpiration")
        private long refreshExpiration = 2592000000L; // 30 jours en millisecondes
    }

    @Data
    public static class Cors {
        @JsonProperty("allowedOrigins")
        private String[] allowedOrigins = {
            "http://localhost:3000",
            "http://localhost:8080",
            "http://localhost:4200",
            "https://*.rental-api.com"
        };

        @JsonProperty("allowedMethods")
        private String[] allowedMethods = {
            "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"
        };

        @JsonProperty("allowedHeaders")
        private String[] allowedHeaders = {
            "Authorization",
            "Content-Type",
            "X-Requested-With",
            "Accept",
            "Origin",
            "X-User-Id"
        };

        @JsonProperty("allowCredentials")
        private boolean allowCredentials = true;

        @JsonProperty("maxAge")
        private long maxAge = 3600;
    }

    @Data
    public static class Security {
        @JsonProperty("maxFailedAttempts")
        private int maxFailedAttempts = 5;

        @JsonProperty("lockDurationHours")
        private int lockDurationHours = 1;

        @JsonProperty("passwordMinLength")
        private int passwordMinLength = 8;

        @JsonProperty("emailVerificationExpiryHours")
        private int emailVerificationExpiryHours = 24;

        @JsonProperty("passwordResetExpiryHours")
        private int passwordResetExpiryHours = 1;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\config\DefaultRoleConfiguration.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import inc.yowyob.rental_api_reactive.application.dto.Permission;
import inc.yowyob.rental_api_reactive.application.dto.RoleType;
import inc.yowyob.rental_api_reactive.persistence.entity.Role;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.Arrays;
import java.util.Set;
import java.util.stream.Collectors;

@Component
@Order(3)
@RequiredArgsConstructor
@Slf4j
public class DefaultRoleConfiguration implements CommandLineRunner {

    private final RoleReactiveRepository roleRepository;

    @Override
    public void run(String... args) throws Exception {
        log.info("Initializing default system roles...");

        createSystemRoles()
            .doOnSuccess(v -> log.info("System roles initialization completed"))
            .doOnError(error -> log.error("Failed to initialize system roles", error))
            .subscribe();
    }

    private Mono<Void> createSystemRoles() {
        return createSuperAdminRole()
            .then(createClientRole())
            .then();
    }

    private Mono<Void> createSuperAdminRole() {
        return roleRepository.findSystemRoles()
            .any(role -> RoleType.SUPER_ADMIN.equals(role.getRoleType()))
            .flatMap(exists -> {
                if (exists) {
                    log.info("Super Admin role already exists");
                    return Mono.empty();
                }

                Set<String> allPermissions = Arrays.stream(Permission.values())
                    .map(Permission::getCode)
                    .collect(Collectors.toSet());

                Role superAdminRole = new Role(
                    "Super Administrateur",
                    "Administrateur système avec tous les privilèges",
                    null // Pas d'organisation pour les rôles système
                );

                superAdminRole.setRoleType(RoleType.SUPER_ADMIN);
                superAdminRole.setIsSystemRole(true);
                superAdminRole.setPriority(100);
                superAdminRole.setPermissions(allPermissions);
                superAdminRole.setColor("#dc2626");
                superAdminRole.setIcon("crown");

                return roleRepository.save(superAdminRole);
            })
            .then();
    }

    private Mono<Void> createClientRole() {
        return roleRepository.findSystemRoles()
            .any(role -> RoleType.CLIENT.equals(role.getRoleType()))
            .flatMap(exists -> {
                if (exists) {
                    log.info("Client role already exists");
                    return Mono.empty();
                }

                Set<String> clientPermissions = Set.of(
                    Permission.VEHICLE_READ.getCode(),
                    Permission.RENTAL_READ.getCode(),
                    Permission.RENTAL_WRITE.getCode(),
                    Permission.USER_READ.getCode(),
                    Permission.USER_UPDATE.getCode()
                );

                Role clientRole = new Role(
                    "Client",
                    "Utilisateur client avec accès aux fonctionnalités de location",
                    null // Pas d'organisation pour les rôles système
                );

                clientRole.setRoleType(RoleType.CLIENT);
                clientRole.setIsSystemRole(true);
                clientRole.setIsDefaultRole(true);
                clientRole.setPriority(10);
                clientRole.setPermissions(clientPermissions);
                clientRole.setColor("#059669");
                clientRole.setIcon("user");

                return roleRepository.save(clientRole);
            })
            .then();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\config\OpenApiConfig.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("Rental API Reactive")
                .version("2.0.0")
                .description("""
                    API réactive pour la gestion de location de véhicules multi-agent
                    """)
                .contact(new Contact()
                    .name("Yowyob Inc")
                    .email("contact@yowyob.inc")
                    .url("https://yowyob.inc"))
                .license(new License()
                    .name("MIT License")
                    .url("https://opensource.org/licenses/MIT")))
            .servers(List.of(
                new Server()
                    .url("http://localhost:8080")
                    .description("Serveur de développement"),
                new Server()
                    .url("https://api.rental.yowyob.inc")
                    .description("Serveur de production")
            ));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\config\ReactiveConfiguration.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.config.EnableWebFlux;

/**
 * Configuration pour les composants reactifs
 */
@Configuration
@EnableWebFlux
public class ReactiveConfiguration {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        return mapper;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\config\ReactiveSecurityConfig.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import inc.yowyob.rental_api_reactive.infrastructure.security.config.CustomAuthenticationManager;
import inc.yowyob.rental_api_reactive.infrastructure.security.config.ReactiveSecurityContextRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

/**
 * Configuration de sécurité réactive pour WebFlux
 */
@Configuration
@EnableWebFluxSecurity
@RequiredArgsConstructor
public class ReactiveSecurityConfig {

    private final CustomAuthenticationManager customAuthenticationManager;
    private final ReactiveSecurityContextRepository securityContextRepository;
    private final AppProperties appProperties;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            // Configuration CORS
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))

            // Désactiver CSRF pour API REST
            .csrf(ServerHttpSecurity.CsrfSpec::disable)

            // Désactiver l'authentification HTTP Basic
            .httpBasic(ServerHttpSecurity.HttpBasicSpec::disable)

            // Désactiver les formulaires de login
            .formLogin(ServerHttpSecurity.FormLoginSpec::disable)

            // Configuration des autorisations
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers("/v3/api-docs/**").permitAll()
                .pathMatchers("/swagger-ui/**").permitAll()
                .pathMatchers("/swagger-ui.html").permitAll()
                .pathMatchers("/swagger-resources/**").permitAll()
                .pathMatchers("/webjars/**").permitAll()

                // Health checks et actuator
                .pathMatchers("/actuator/**").permitAll()
                .pathMatchers("/health").permitAll()

                // Routes publiques - Authentification
                .pathMatchers("/api/v1/auth/register").permitAll()
                .pathMatchers("/api/v1/auth/login").permitAll()
                .pathMatchers("/api/v1/auth/refresh").permitAll()
                .pathMatchers("/api/v1/auth/forgot-password").permitAll()
                .pathMatchers("/api/v1/auth/reset-password").permitAll()
                .pathMatchers("/api/v1/auth/verify-email").permitAll()

                // Routes publiques - Onboarding
                .pathMatchers("/api/v1/onboarding/**").permitAll()

                // Routes publiques - Forfaits (consultation uniquement)
                .pathMatchers("/api/v1/subscription/plans/**").permitAll()

                // Routes sécurisées - Authentification
                .pathMatchers("/api/v1/auth/me").authenticated()
                .pathMatchers("/api/v1/auth/change-password").authenticated()
                .pathMatchers("/api/v1/auth/logout").authenticated()

                // Routes sécurisées - Profil utilisateur
                .pathMatchers("/api/v1/profile/**").authenticated()

                // Gestion du personnel (Propriétaires d'organisation uniquement)
                .pathMatchers("/api/v1/personnel/**").authenticated()

                // À sécuriser dans les phases suivantes
                .pathMatchers("/api/v1/users/**").permitAll()
                .pathMatchers("/api/v1/organizations/**").permitAll()
                .pathMatchers("/api/v1/permissions").permitAll()
                .pathMatchers("/api/v1/roles").permitAll()
                .pathMatchers("/api/v1/user-roles").permitAll()

                // Toutes les autres routes nécessitent une authentification
                .anyExchange().authenticated()
            )

            // Configuration du gestionnaire d'authentification
            .authenticationManager(customAuthenticationManager)

            // Configuration du repository de contexte de sécurité
            .securityContextRepository(securityContextRepository)

            .build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        // Origines autorisées depuis les propriétés
        configuration.setAllowedOriginPatterns(Arrays.asList(appProperties.getCors().getAllowedOrigins()));

        // Méthodes autorisées
        configuration.setAllowedMethods(Arrays.asList(appProperties.getCors().getAllowedMethods()));

        // Headers autorisés
        configuration.setAllowedHeaders(Arrays.asList(appProperties.getCors().getAllowedHeaders()));

        // Headers exposés
        configuration.setExposedHeaders(List.of(
            "Access-Control-Allow-Origin",
            "Access-Control-Allow-Credentials",
            "Authorization"
        ));

        // Permettre les credentials
        configuration.setAllowCredentials(appProperties.getCors().isAllowCredentials());

        // Durée de cache pour les preflight requests
        configuration.setMaxAge(appProperties.getCors().getMaxAge());

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\config\SubscriptionPlanDataInitializer.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import inc.yowyob.rental_api_reactive.persistence.repository.SubscriptionPlanReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.math.BigDecimal;
import java.util.Map;
import java.util.UUID;

/**
 * Initialise les données de base pour les forfaits d'abonnement (Version Reactive)
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class SubscriptionPlanDataInitializer implements CommandLineRunner {

    private final SubscriptionPlanReactiveRepository subscriptionPlanRepository;

    @Override
    public void run(String... args) throws Exception {
        log.info("Initializing subscription plans data (reactive)...");

        try {
            subscriptionPlanRepository.findAllActive()
                .hasElements()
                .flatMap(hasPlans -> {
                    if (hasPlans) {
                        log.info("Subscription plans already exist. Skipping initialization.");
                        return Mono.empty();
                    } else {
                        return createSubscriptionPlans()
                            .then(); // Convertit le Flux en Mono<Void>
                    }
                })
                .doOnSuccess(unused -> log.info("Subscription plans initialization completed successfully."))
                .doOnError(error -> log.error("Error during subscription plans initialization: {}", error.getMessage(), error))
                .subscribe();

        } catch (Exception e) {
            log.error("Error during subscription plans initialization: {}", e.getMessage(), e);
        }
    }

    private Flux<SubscriptionPlan> createSubscriptionPlans() {
        log.info("Creating default subscription plans...");

        return Flux.just(
                createTrialPlan(),
                createBasicPlan(),
                createPremiumPlan(),
                createEnterprisePlan()
            )
            .flatMap(subscriptionPlanRepository::save)
            .doOnNext(plan -> log.info("Created subscription plan: {} - {}", plan.getName(), plan.getId()));
    }

    private SubscriptionPlan createTrialPlan() {
        SubscriptionPlan plan = new SubscriptionPlan();
        plan.setId(UUID.randomUUID());
        plan.setName("GRATUIT");
        plan.setDescription("Forfait d'essai gratuit de 30 jours pour découvrir notre plateforme");
        plan.setPrice(BigDecimal.ZERO);
        plan.setCurrency("XAF");
        plan.setDurationDays(30);
        plan.setMaxAgencies(1);
        plan.setMaxVehicles(5);
        plan.setMaxDrivers(2);
        plan.setMaxUsers(3);
        plan.setIsPopular(false);
        plan.setIsCustom(false);
        plan.setSortOrder(1);
        plan.setFeatures(Map.of(
            "geofencing", false,
            "chat", false,
            "advanced_reports", false,
            "api_access", false,
            "priority_support", false,
            "custom_branding", false,
            "multi_language", true,
            "basic_analytics", true
        ));
        return plan;
    }

    private SubscriptionPlan createBasicPlan() {
        SubscriptionPlan plan = new SubscriptionPlan();
        plan.setId(UUID.randomUUID());
        plan.setName("BASIC");
        plan.setDescription("Forfait de base idéal pour les petites entreprises de location");
        plan.setPrice(new BigDecimal("29.99"));
        plan.setCurrency("XAF");
        plan.setDurationDays(30);
        plan.setMaxAgencies(3);
        plan.setMaxVehicles(20);
        plan.setMaxDrivers(10);
        plan.setMaxUsers(8);
        plan.setIsPopular(true);
        plan.setIsCustom(false);
        plan.setSortOrder(2);
        plan.setFeatures(Map.of(
            "geofencing", false,
            "chat", true,
            "advanced_reports", false,
            "api_access", false,
            "priority_support", false,
            "custom_branding", false,
            "multi_language", true,
            "basic_analytics", true,
            "email_notifications", true
        ));
        return plan;
    }

    private SubscriptionPlan createPremiumPlan() {
        SubscriptionPlan plan = new SubscriptionPlan();
        plan.setId(UUID.randomUUID());
        plan.setName("PREMIUM");
        plan.setDescription("Forfait premium avec fonctionnalités avancées pour les entreprises en croissance");
        plan.setPrice(new BigDecimal("79.99"));
        plan.setCurrency("XAF");
        plan.setDurationDays(30);
        plan.setMaxAgencies(10);
        plan.setMaxVehicles(100);
        plan.setMaxDrivers(50);
        plan.setMaxUsers(25);
        plan.setIsPopular(true);
        plan.setIsCustom(false);
        plan.setSortOrder(3);
        plan.setFeatures(Map.ofEntries(
            Map.entry("geofencing", true),
            Map.entry("chat", true),
            Map.entry("advanced_reports", true),
            Map.entry("api_access", true),
            Map.entry("priority_support", false),
            Map.entry("custom_branding", true),
            Map.entry("multi_language", true),
            Map.entry("basic_analytics", true),
            Map.entry("advanced_analytics", true),
            Map.entry("email_notifications", true),
            Map.entry("sms_notifications", true),
            Map.entry("integrations", true)
        ));
        return plan;
    }

    private SubscriptionPlan createEnterprisePlan() {
        SubscriptionPlan plan = new SubscriptionPlan();
        plan.setId(UUID.randomUUID());
        plan.setName("ENTERPRISE");
        plan.setDescription("Solution complète pour les grandes entreprises avec support dédié");
        plan.setPrice(new BigDecimal("199.99"));
        plan.setCurrency("XAF");
        plan.setDurationDays(30);
        plan.setMaxAgencies(Integer.MAX_VALUE);
        plan.setMaxVehicles(Integer.MAX_VALUE);
        plan.setMaxDrivers(Integer.MAX_VALUE);
        plan.setMaxUsers(Integer.MAX_VALUE);
        plan.setIsPopular(false);
        plan.setIsCustom(false);
        plan.setSortOrder(4);
        plan.setFeatures(Map.ofEntries(
            Map.entry("geofencing", true),
            Map.entry("chat", true),
            Map.entry("advanced_reports", true),
            Map.entry("api_access", true),
            Map.entry("priority_support", true),
            Map.entry("custom_branding", true),
            Map.entry("multi_language", true),
            Map.entry("basic_analytics", true),
            Map.entry("advanced_analytics", true),
            Map.entry("email_notifications", true),
            Map.entry("sms_notifications", true),
            Map.entry("integrations", true),
            Map.entry("white_labeling", true),
            Map.entry("dedicated_support", true),
            Map.entry("custom_features", true)
        ));
        return plan;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\config\WebConfig.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

import java.util.Arrays;
import java.util.List;

@Configuration
public class WebConfig {

    @Value("${app.cors.allowed-origins}")
    private String[] allowedOrigins;

    @Value("${app.cors.allowed-methods}")
    private String allowedMethods;

    @Value("${app.cors.allowed-headers}")
    private String allowedHeaders;

    @Value("${app.cors.allow-credentials}")
    private boolean allowCredentials;

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration configuration = new CorsConfiguration();

        // Origines autorisées
        configuration.setAllowedOriginPatterns(Arrays.asList(allowedOrigins));

        // Méthodes autorisées
        configuration.setAllowedMethods(Arrays.asList(allowedMethods.split(",")));

        // Headers autorisés - Important pour Swagger
        if ("*".equals(allowedHeaders)) {
            configuration.addAllowedHeader("*");
        } else {
            configuration.setAllowedHeaders(Arrays.asList(allowedHeaders.split(",")));
        }

        // Headers exposés pour les réponses
        configuration.setExposedHeaders(List.of(
            "Access-Control-Allow-Origin",
            "Access-Control-Allow-Credentials",
            "Content-Type",
            "Authorization"
        ));

        // Permettre les credentials
        configuration.setAllowCredentials(allowCredentials);

        // Durée de cache pour les preflight requests
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration); // Appliquer à tous les chemins

        return new CorsWebFilter(source);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\CustomPermissionEvaluator.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security;

import inc.yowyob.rental_api_reactive.application.service.AuthorizationReactiveService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.access.PermissionEvaluator;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
public class CustomPermissionEvaluator implements PermissionEvaluator {

    private final AuthorizationReactiveService authorizationService;

    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        if (authentication == null || permission == null) {
            return false;
        }

        UUID userId = getUserId(authentication);
        if (userId == null) {
            return false;
        }

        String permissionStr = permission.toString();
        String[] parts = permissionStr.split("_");

        if (parts.length >= 2) {
            String resource = parts[0];
            String action = parts[1];

            return authorizationService.hasPermission(userId, resource, action).block();
        }

        return false;
    }

    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
        return hasPermission(authentication, null, permission);
    }

    private UUID getUserId(Authentication authentication) {
        try {
            Object principal = authentication.getPrincipal();
            if (principal instanceof UserPrincipal) {
                return ((UserPrincipal) principal).getId();
            }
            return UUID.fromString(principal.toString());
        } catch (Exception e) {
            log.warn("Could not extract user ID from authentication", e);
            return null;
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\UserPrincipal.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.Set;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserPrincipal implements UserDetails {

    @JsonProperty("id")
    private UUID id;

    @JsonProperty("email")
    private String email;

    @JsonProperty("password")
    private String password;

    @JsonProperty("first_name")
    private String firstName;

    @JsonProperty("last_name")
    private String lastName;

    @JsonProperty("user_type")
    private UserType userType;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("agency_id")
    private UUID agencyId;

    @JsonProperty("is_active")
    private Boolean isActive;

    @JsonProperty("authorities")
    private Set<String> authorities;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        if (authorities == null) {
            return Collections.emptyList();
        }
        return authorities.stream()
            .map(authority -> (GrantedAuthority) () -> authority)
            .toList();
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return Boolean.TRUE.equals(isActive);
    }

    @JsonProperty("full_name")
    public String getFullName() {
        if (firstName != null && lastName != null) {
            return firstName + " " + lastName;
        }
        return email;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\config\CustomAuthenticationManager.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.config;

import org.springframework.security.authentication.ReactiveAuthenticationManager;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

/**
 * Gestionnaire d'authentification réactif personnalisé
 */
@Component
public class CustomAuthenticationManager implements ReactiveAuthenticationManager {

    @Override
    public Mono<Authentication> authenticate(Authentication authentication) {
        return Mono.just(authentication);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\config\MethodSecurityConfig.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.config;

import inc.yowyob.rental_api_reactive.infrastructure.security.CustomPermissionEvaluator;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler;
import org.springframework.security.access.expression.method.MethodSecurityExpressionHandler;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

@Configuration
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class MethodSecurityConfig {

    private final CustomPermissionEvaluator permissionEvaluator;

    @Bean
    public MethodSecurityExpressionHandler methodSecurityExpressionHandler() {
        DefaultMethodSecurityExpressionHandler expressionHandler = new DefaultMethodSecurityExpressionHandler();
        expressionHandler.setPermissionEvaluator(permissionEvaluator);
        return expressionHandler;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\config\ReactiveSecurityContextRepository.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.config;

import inc.yowyob.rental_api_reactive.infrastructure.security.jwt.JwtReactiveTokenProvider;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextImpl;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.server.context.ServerSecurityContextRepository;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.util.Collections;

/**
 * Repository réactif pour la gestion du contexte de sécurité
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class ReactiveSecurityContextRepository implements ServerSecurityContextRepository {

    private final JwtReactiveTokenProvider jwtTokenProvider;
    private final UserReactiveRepository userRepository;

    @Override
    public Mono<Void> save(ServerWebExchange exchange, SecurityContext context) {
        return Mono.empty();
    }

    @Override
    public Mono<SecurityContext> load(ServerWebExchange exchange) {
        return extractTokenFromRequest(exchange)
            .flatMap(token -> jwtTokenProvider.validateToken(token)
                .flatMap(isValid -> {
                    if (!isValid) {
                        return Mono.empty();
                    }

                    return jwtTokenProvider.getEmailFromToken(token)
                        .flatMap(userRepository::findByEmail)
                        .map(user -> {
                            UserDetails userDetails = new org.springframework.security.core.userdetails.User(
                                user.getEmail(),
                                "",
                                user.getIsActive(),
                                true,
                                true,
                                true,
                                Collections.emptyList()
                            );

                            Authentication authentication = new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());

                            // CORRECTION: Cast explicite vers SecurityContext
                            SecurityContext securityContext = new SecurityContextImpl(authentication);
                            return securityContext;
                        });
                }))
            .onErrorResume(ex -> {
                log.debug("Error loading security context: {}", ex.getMessage());
                return Mono.empty();
            });
    }

    private Mono<String> extractTokenFromRequest(ServerWebExchange exchange) {
        return Mono.fromCallable(() -> {
            String bearerToken = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
            if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
                return bearerToken.substring(7);
            }
            return null;
        });
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\filter\MultiTenantSecurityFilter.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.filter;

import inc.yowyob.rental_api_reactive.application.service.AuthorizationReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.security.UserPrincipal;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Component
@RequiredArgsConstructor
@Slf4j
public class MultiTenantSecurityFilter implements WebFilter {

    private final AuthorizationReactiveService authorizationService;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return ReactiveSecurityContextHolder.getContext()
            .cast(org.springframework.security.core.context.SecurityContext.class)
            .map(org.springframework.security.core.context.SecurityContext::getAuthentication)
            .cast(Authentication.class)
            .flatMap(authentication -> {
                if (authentication == null || !authentication.isAuthenticated()) {
                    return chain.filter(exchange);
                }

                return validateTenantAccess(exchange, authentication)
                    .flatMap(isValid -> {
                        if (isValid) {
                            return chain.filter(exchange);
                        } else {
                            exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
                            return exchange.getResponse().setComplete();
                        }
                    });
            })
            .switchIfEmpty(chain.filter(exchange));
    }

    private Mono<Boolean> validateTenantAccess(ServerWebExchange exchange, Authentication authentication) {
        String organizationIdHeader = exchange.getRequest().getHeaders().getFirst("X-Organization-Id");
        String agencyIdHeader = exchange.getRequest().getHeaders().getFirst("X-Agency-Id");

        if (organizationIdHeader == null && agencyIdHeader == null) {
            return Mono.just(true); // Pas de contrainte multi-tenant
        }

        Object principal = authentication.getPrincipal();
        if (!(principal instanceof UserPrincipal userPrincipal)) {
            return Mono.just(false);
        }

        UUID userId = userPrincipal.getId();

        // Validation de l'accès organisation
        if (organizationIdHeader != null) {
            try {
                UUID organizationId = UUID.fromString(organizationIdHeader);
                return authorizationService.canAccessOrganization(userId, organizationId);
            } catch (IllegalArgumentException e) {
                log.warn("Invalid organization ID in header: {}", organizationIdHeader);
                return Mono.just(false);
            }
        }

        // Validation de l'accès agence
        if (agencyIdHeader != null) {
            try {
                UUID agencyId = UUID.fromString(agencyIdHeader);
                return authorizationService.canAccessAgency(userId, agencyId);
            } catch (IllegalArgumentException e) {
                log.warn("Invalid agency ID in header: {}", agencyIdHeader);
                return Mono.just(false);
            }
        }

        return Mono.just(true);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\jwt\JwtAuthenticationWebFilter.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.jwt;

import inc.yowyob.rental_api_reactive.infrastructure.security.jwt.JwtReactiveTokenProvider;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;
import reactor.core.publisher.Mono;

import java.util.Collections;

/**
 * Filtre Web réactif pour l'authentification JWT
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationWebFilter implements WebFilter {

    private final JwtReactiveTokenProvider jwtTokenProvider;
    private final UserReactiveRepository userRepository;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getPath().value();

        // Ignorer les routes publiques
        if (isPublicPath(path)) {
            return chain.filter(exchange);
        }

        return extractToken(exchange)
            .flatMap(token -> jwtTokenProvider.validateToken(token)
                .flatMap(isValid -> {
                    if (!isValid) {
                        return chain.filter(exchange);
                    }

                    return jwtTokenProvider.getEmailFromToken(token)
                        .flatMap(userRepository::findByEmail)
                        .flatMap(user -> {
                            UserDetails userDetails = new org.springframework.security.core.userdetails.User(
                                user.getEmail(),
                                "",
                                user.getIsActive(),
                                true,
                                true,
                                true,
                                Collections.emptyList()
                            );

                            UsernamePasswordAuthenticationToken authentication =
                                new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());

                            return chain.filter(exchange)
                                .contextWrite(ReactiveSecurityContextHolder.withAuthentication(authentication));
                        })
                        .switchIfEmpty(chain.filter(exchange));
                }))
            .switchIfEmpty(chain.filter(exchange))
            .onErrorResume(ex -> {
                log.debug("JWT authentication failed: {}", ex.getMessage());
                return chain.filter(exchange);
            });
    }

    private Mono<String> extractToken(ServerWebExchange exchange) {
        return Mono.fromCallable(() -> {
            String bearerToken = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
            if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
                return bearerToken.substring(7);
            }
            return null;
        });
    }

    private boolean isPublicPath(String path) {
        return path.startsWith("/api/v1/auth/") ||
            path.startsWith("/api/v1/onboarding/") ||
            path.startsWith("/api/v1/subscription/plans") ||
            path.startsWith("/v3/api-docs") ||
            path.startsWith("/swagger-ui") ||
            path.startsWith("/actuator/health");
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\jwt\JwtReactiveTokenProvider.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.jwt;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.infrastructure.config.AppProperties;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Service réactif pour la gestion des tokens JWT
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtReactiveTokenProvider {

    private final AppProperties appProperties;

    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(appProperties.getJwt().getSecret().getBytes());
    }

    /**
     * Génère un token JWT pour un utilisateur
     */
    public Mono<String> generateToken(User user) {
        return Mono.fromCallable(() -> {
            Map<String, Object> claims = new HashMap<>();
            claims.put("userId", user.getId().toString());
            claims.put("email", user.getEmail());
            claims.put("userType", user.getUserType().name());
            claims.put("isActive", user.getIsActive());

            // Informations organisation
            if (user.getOrganizationId() != null) {
                claims.put("organizationId", user.getOrganizationId().toString());
            }

            // Informations agence pour le personnel
            if (user.getAgencyId() != null) {
                claims.put("agencyId", user.getAgencyId().toString());
                claims.put("isAgencyBound", true);
            } else {
                claims.put("isAgencyBound", false);
            }

            return createToken(claims, user.getEmail(), appProperties.getJwt().getExpiration());
        });
    }

    /**
     * Génère un refresh token
     */
    public Mono<String> generateRefreshToken(User user) {
        return Mono.fromCallable(() -> {
            Map<String, Object> claims = new HashMap<>();
            claims.put("userId", user.getId().toString());
            claims.put("type", "refresh");

            return createToken(claims, user.getEmail(), appProperties.getJwt().getRefreshExpiration());
        });
    }

    /**
     * Crée un token JWT avec les claims spécifiés
     */
    private String createToken(Map<String, Object> claims, String subject, long expiration) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration);

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(getSigningKey(), SignatureAlgorithm.HS256)
            .compact();
    }

    /**
     * Extrait le token du header Authorization
     */
    public Mono<String> extractTokenFromHeader(String bearerToken) {
        return Mono.fromCallable(() -> {
            if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
                return bearerToken.substring(7);
            }
            return null;
        });
    }

    /**
     * Valide un token JWT
     */
    public Mono<Boolean> validateToken(String token) {
        return Mono.fromCallable(() -> {
            try {
                Jwts.parser()
                    .setSigningKey(getSigningKey())
                    .build()
                    .parseClaimsJws(token);
                return true;
            } catch (JwtException | IllegalArgumentException e) {
                log.debug("Invalid JWT token: {}", e.getMessage());
                return false;
            }
        });
    }

    /**
     * Extrait l'email du token
     */
    public Mono<String> getEmailFromToken(String token) {
        return Mono.fromCallable(() -> {
            Claims claims = getClaims(token);
            return claims.getSubject();
        });
    }

    /**
     * Extrait l'ID utilisateur du token
     */
    public Mono<UUID> getUserIdFromToken(String token) {
        return Mono.fromCallable(() -> {
            Claims claims = getClaims(token);
            return UUID.fromString(claims.get("userId", String.class));
        });
    }

    /**
     * Extrait les claims du token
     */
    private Claims getClaims(String token) {
        return Jwts.parser()
            .setSigningKey(getSigningKey())
            .build()
            .parseClaimsJws(token)
            .getBody();
    }

    /**
     * Vérifie si le token est expiré
     */
    public Mono<Boolean> isTokenExpired(String token) {
        return Mono.fromCallable(() -> {
            try {
                Claims claims = getClaims(token);
                return claims.getExpiration().before(new Date());
            } catch (JwtException e) {
                return true;
            }
        });
    }

    /**
     * Extrait le contexte utilisateur du token
     */
    public Mono<TokenContext> extractTokenContext(String token) {
        return Mono.fromCallable(() -> {
            Claims claims = getClaims(token);

            TokenContext context = new TokenContext();
            context.setUserId(UUID.fromString(claims.get("userId", String.class)));
            context.setEmail(claims.getSubject());
            context.setUserType(claims.get("userType", String.class));
            context.setIsActive(claims.get("isActive", Boolean.class));

            String orgId = claims.get("organizationId", String.class);
            if (orgId != null) {
                context.setOrganizationId(UUID.fromString(orgId));
            }

            String agencyId = claims.get("agencyId", String.class);
            if (agencyId != null) {
                context.setAgencyId(UUID.fromString(agencyId));
            }

            context.setIsAgencyBound(claims.get("isAgencyBound", Boolean.class));

            return context;
        });
    }

    /**
     * Contexte utilisateur extrait du token JWT
     */
    public static class TokenContext {
        @JsonProperty("userId")
        private UUID userId;

        @JsonProperty("email")
        private String email;

        @JsonProperty("userType")
        private String userType;

        @JsonProperty("organizationId")
        private UUID organizationId;

        @JsonProperty("agencyId")
        private UUID agencyId;

        @JsonProperty("isAgencyBound")
        private Boolean isAgencyBound;

        @JsonProperty("isActive")
        private Boolean isActive;

        // Constructeurs
        public TokenContext() {}

        // Getters et Setters
        public UUID getUserId() { return userId; }
        public void setUserId(UUID userId) { this.userId = userId; }

        public String getEmail() { return email; }
        public void setEmail(String email) { this.email = email; }

        public String getUserType() { return userType; }
        public void setUserType(String userType) { this.userType = userType; }

        public UUID getOrganizationId() { return organizationId; }
        public void setOrganizationId(UUID organizationId) { this.organizationId = organizationId; }

        public UUID getAgencyId() { return agencyId; }
        public void setAgencyId(UUID agencyId) { this.agencyId = agencyId; }

        public Boolean getIsAgencyBound() { return isAgencyBound; }
        public void setIsAgencyBound(Boolean isAgencyBound) { this.isAgencyBound = isAgencyBound; }

        public Boolean getIsActive() { return isActive; }
        public void setIsActive(Boolean isActive) { this.isActive = isActive; }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\model\TokenContext.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.util.UUID;

@Data
public class TokenContext {
    @JsonProperty("userId")
    private UUID userId;

    @JsonProperty("email")
    private String email;

    @JsonProperty("userType")
    private String userType;

    @JsonProperty("organizationId")
    private UUID organizationId;

    @JsonProperty("agencyId")
    private UUID agencyId;

    @JsonProperty("isAgencyBound")
    private Boolean isAgencyBound;

    @JsonProperty("isActive")
    private Boolean isActive;

    @JsonProperty("permissions")
    private java.util.List<String> permissions;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\security\model\UserPrincipal.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.security.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.Collection;
import java.util.Collections;
import java.util.UUID;

@Data
@AllArgsConstructor
public class UserPrincipal implements UserDetails {
    @JsonProperty("id")
    private UUID id;

    @JsonProperty("email")
    private String email;

    @JsonProperty("password")
    private String password;

    @JsonProperty("firstName")
    private String firstName;

    @JsonProperty("lastName")
    private String lastName;

    @JsonProperty("userType")
    private String userType;

    @JsonProperty("organizationId")
    private UUID organizationId;

    @JsonProperty("agencyId")
    private UUID agencyId;

    @JsonProperty("isActive")
    private Boolean isActive;

    @JsonProperty("isEmailVerified")
    private Boolean isEmailVerified;

    public static UserPrincipal create(User user) {
        return new UserPrincipal(
            user.getId(),
            user.getEmail(),
            user.getPassword(),
            user.getFirstName(),
            user.getLastName(),
            user.getUserType().name(),
            user.getOrganizationId(),
            user.getAgencyId(),
            user.getIsActive(),
            user.getIsEmailVerified()
        );
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        // À implémenter selon les rôles et permissions
        return Collections.emptyList();
    }

    @Override
    public String getUsername() {
        return email;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return isActive && isEmailVerified;
    }

    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\AgencyReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.AgencyReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.security.UserPrincipal;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

/**
 * Contrôleur réactif pour la gestion des agences
 */
@RestController
@RequestMapping("/api/v1/agencies")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Agencies", description = "API réactive de gestion des agences")
public class AgencyReactiveController {

    private final AgencyReactiveService agencyService;

    @Operation(
        summary = "Créer une nouvelle agence",
        description = "Crée une nouvelle agence dans une organisation"
    )
    @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyResponse>> createAgency(
        @Valid @RequestBody CreateAgencyRequest createRequest,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("POST /api/v1/agencies - Creating agency: {} for organization: {}",
            createRequest.getName(), createRequest.getOrganizationId());

        return agencyService.createAgency(createRequest, userPrincipal.getId())
            .map(agency -> ApiResponse.<AgencyResponse>builder()
                .success(true)
                .message("Agence créée avec succès")
                .data(agency)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<AgencyResponse>builder()
                .success(false)
                .message("Erreur lors de la création de l'agence")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir une agence par ID",
        description = "Récupère les détails d'une agence spécifique"
    )
    @GetMapping(value = "/{agencyId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyResponse>> getAgencyById(
        @Parameter(description = "ID de l'agence") @PathVariable UUID agencyId,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/agencies/{} - Getting agency details", agencyId);

        return agencyService.findById(agencyId)
            .map(agency -> ApiResponse.<AgencyResponse>builder()
                .success(true)
                .message("Agence trouvée")
                .data(agency)
                .build())
            .switchIfEmpty(Mono.just(ApiResponse.<AgencyResponse>builder()
                .success(false)
                .message("Agence non trouvée")
                .data(null)
                .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message("Accès refusé à cette agence")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<AgencyResponse>builder()
                .success(false)
                .message("Erreur lors de la récupération de l'agence")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Mettre à jour une agence",
        description = "Met à jour les informations d'une agence"
    )
    @PutMapping(value = "/{agencyId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyResponse>> updateAgency(
        @Parameter(description = "ID de l'agence") @PathVariable UUID agencyId,
        @Valid @RequestBody UpdateAgencyRequest updateRequest,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PUT /api/v1/agencies/{} - Updating agency", agencyId);

        return agencyService.updateAgency(agencyId, updateRequest, userPrincipal.getId())
            .map(agency -> ApiResponse.<AgencyResponse>builder()
                .success(true)
                .message("Agence mise à jour avec succès")
                .data(agency)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<AgencyResponse>builder()
                .success(false)
                .message("Erreur lors de la mise à jour de l'agence")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Supprimer une agence",
        description = "Supprime une agence (soft delete)"
    )
    @DeleteMapping(value = "/{agencyId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Void>> deleteAgency(
        @Parameter(description = "ID de l'agence") @PathVariable UUID agencyId,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("DELETE /api/v1/agencies/{} - Deleting agency", agencyId);

        return agencyService.deleteAgency(agencyId, userPrincipal.getId())
            .then(Mono.just(ApiResponse.<Void>builder()
                .success(true)
                .message("Agence supprimée avec succès")
                .data(null)
                .build()))
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<Void>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<Void>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<Void>builder()
                .success(false)
                .message("Erreur lors de la suppression de l'agence")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les agences d'une organisation",
        description = "Récupère toutes les agences d'une organisation"
    )
    @GetMapping(value = "/organization/{organizationId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<AgencyResponse>>> getAgenciesByOrganization(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID organizationId,
        @RequestParam(defaultValue = "false") boolean activeOnly,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/agencies/organization/{} - Getting agencies, activeOnly: {}",
            organizationId, activeOnly);

        Flux<AgencyResponse> agencies = activeOnly
            ? agencyService.findActiveByOrganizationId(organizationId)
            : agencyService.findByOrganizationId(organizationId);

        return Mono.fromCallable(() -> ApiResponse.<Flux<AgencyResponse>>builder()
                .success(true)
                .message("Agences récupérées avec succès")
                .data(agencies)
                .build())
            .onErrorReturn(ApiResponse.<Flux<AgencyResponse>>builder()
                .success(false)
                .message("Erreur lors de la récupération des agences")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les agences d'un gestionnaire",
        description = "Récupère toutes les agences gérées par un utilisateur"
    )
    @GetMapping(value = "/manager/{managerId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<AgencyResponse>>> getAgenciesByManager(
        @Parameter(description = "ID du gestionnaire") @PathVariable UUID managerId,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/agencies/manager/{} - Getting managed agencies", managerId);

        Flux<AgencyResponse> agencies = agencyService.findByManagerId(managerId);

        return Mono.fromCallable(() -> ApiResponse.<Flux<AgencyResponse>>builder()
                .success(true)
                .message("Agences du gestionnaire récupérées")
                .data(agencies)
                .build())
            .onErrorReturn(ApiResponse.<Flux<AgencyResponse>>builder()
                .success(false)
                .message("Erreur lors de la récupération des agences")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les agences par localisation",
        description = "Récupère les agences par ville et pays"
    )
    @GetMapping(value = "/location", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<AgencyResponse>>> getAgenciesByLocation(
        @RequestParam String city,
        @RequestParam String country,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/agencies/location - Getting agencies in {} - {}", city, country);

        Flux<AgencyResponse> agencies = agencyService.findByCityAndCountry(city, country);

        return Mono.fromCallable(() -> ApiResponse.<Flux<AgencyResponse>>builder()
                .success(true)
                .message("Agences trouvées pour la localisation")
                .data(agencies)
                .build())
            .onErrorReturn(ApiResponse.<Flux<AgencyResponse>>builder()
                .success(false)
                .message("Erreur lors de la recherche par localisation")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Activer/désactiver une agence",
        description = "Change le statut actif d'une agence"
    )
    @PatchMapping(value = "/{agencyId}/status", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyResponse>> toggleAgencyStatus(
        @Parameter(description = "ID de l'agence") @PathVariable UUID agencyId,
        @RequestParam boolean isActive,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PATCH /api/v1/agencies/{}/status - Toggling status to {}", agencyId, isActive);

        return agencyService.toggleAgencyStatus(agencyId, isActive, userPrincipal.getId())
            .map(agency -> ApiResponse.<AgencyResponse>builder()
                .success(true)
                .message("Statut de l'agence modifié avec succès")
                .data(agency)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<AgencyResponse>builder()
                .success(false)
                .message("Erreur lors du changement de statut")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Assigner un gestionnaire à une agence",
        description = "Assigne ou change le gestionnaire d'une agence"
    )
    @PatchMapping(value = "/{agencyId}/manager", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyResponse>> assignManager(
        @Parameter(description = "ID de l'agence") @PathVariable UUID agencyId,
        @RequestParam UUID managerId,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PATCH /api/v1/agencies/{}/manager - Assigning manager {}", agencyId, managerId);

        return agencyService.assignManager(agencyId, managerId, userPrincipal.getId())
            .map(agency -> ApiResponse.<AgencyResponse>builder()
                .success(true)
                .message("Gestionnaire assigné avec succès")
                .data(agency)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<AgencyResponse>builder()
                .success(false)
                .message("Erreur lors de l'assignation du gestionnaire")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les statistiques d'une agence",
        description = "Récupère les statistiques détaillées d'une agence"
    )
    @GetMapping(value = "/{agencyId}/statistics", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyStatisticsResponse>> getAgencyStatistics(
        @Parameter(description = "ID de l'agence") @PathVariable UUID agencyId,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/agencies/{}/statistics - Getting agency statistics", agencyId);

        return agencyService.getAgencyStatistics(agencyId)
            .map(stats -> ApiResponse.<AgencyStatisticsResponse>builder()
                .success(true)
                .message("Statistiques de l'agence récupérées")
                .data(stats)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<AgencyStatisticsResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<AgencyStatisticsResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<AgencyStatisticsResponse>builder()
                .success(false)
                .message("Erreur lors de la récupération des statistiques")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Mettre à jour les statistiques d'une agence",
        description = "Met à jour les statistiques d'une agence (usage interne)"
    )
    @PutMapping(value = "/{agencyId}/statistics", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyResponse>> updateAgencyStatistics(
        @Parameter(description = "ID de l'agence") @PathVariable UUID agencyId,
        @Valid @RequestBody AgencyStatisticsRequest statsRequest,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PUT /api/v1/agencies/{}/statistics - Updating agency statistics", agencyId);

        return agencyService.updateAgencyStatistics(agencyId, statsRequest)
            .map(agency -> ApiResponse.<AgencyResponse>builder()
                .success(true)
                .message("Statistiques mises à jour avec succès")
                .data(agency)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<AgencyResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<AgencyResponse>builder()
                .success(false)
                .message("Erreur lors de la mise à jour des statistiques")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les agences avec réservation en ligne",
        description = "Récupère les agences qui acceptent les réservations en ligne"
    )
    @GetMapping(value = "/online-booking", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<AgencyResponse>>> getAgenciesWithOnlineBooking() {
        log.info("GET /api/v1/agencies/online-booking - Getting agencies with online booking");

        Flux<AgencyResponse> agencies = agencyService.findAgenciesWithOnlineBooking();

        return Mono.fromCallable(() -> ApiResponse.<Flux<AgencyResponse>>builder()
                .success(true)
                .message("Agences avec réservation en ligne trouvées")
                .data(agencies)
                .build())
            .onErrorReturn(ApiResponse.<Flux<AgencyResponse>>builder()
                .success(false)
                .message("Erreur lors de la recherche")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Rechercher des agences dans une zone géographique",
        description = "Recherche les agences dans une zone géographique définie"
    )
    @GetMapping(value = "/search/bounds", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<AgencyResponse>>> searchAgenciesInBounds(
        @RequestParam double minLat,
        @RequestParam double maxLat,
        @RequestParam double minLng,
        @RequestParam double maxLng) {

        log.info("GET /api/v1/agencies/search/bounds - Searching agencies in bounds: {},{} to {},{}",
            minLat, minLng, maxLat, maxLng);

        Flux<AgencyResponse> agencies = agencyService.findAgenciesInBounds(minLat, maxLat, minLng, maxLng);

        return Mono.fromCallable(() -> ApiResponse.<Flux<AgencyResponse>>builder()
                .success(true)
                .message("Agences trouvées dans la zone")
                .data(agencies)
                .build())
            .onErrorReturn(ApiResponse.<Flux<AgencyResponse>>builder()
                .success(false)
                .message("Erreur lors de la recherche géographique")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Vérifier si une organisation peut créer une agence",
        description = "Vérifie les limites d'abonnement pour la création d'agence"
    )
    @GetMapping(value = "/can-create/{organizationId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Boolean>> canCreateAgency(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID organizationId,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/agencies/can-create/{} - Checking agency creation limit", organizationId);

        return agencyService.canCreateAgency(organizationId)
            .map(canCreate -> ApiResponse.<Boolean>builder()
                .success(true)
                .message(canCreate ? "Création d'agence autorisée" : "Limite d'agences atteinte")
                .data(canCreate)
                .build())
            .onErrorReturn(ApiResponse.<Boolean>builder()
                .success(false)
                .message("Erreur lors de la vérification")
                .data(false)
                .build());
    }

    @Operation(
        summary = "Compter les agences d'une organisation",
        description = "Retourne le nombre d'agences (total et actives) d'une organisation"
    )
    @GetMapping(value = "/count/{organizationId}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<AgencyCountResponse>> countAgenciesByOrganization(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID organizationId,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/agencies/count/{} - Counting agencies", organizationId);

        return agencyService.countByOrganizationId(organizationId)
            .zipWith(agencyService.countActiveByOrganizationId(organizationId))
            .map(tuple -> {
                AgencyCountResponse count = AgencyCountResponse.builder()
                    .organizationId(organizationId)
                    .totalAgencies(tuple.getT1().intValue())
                    .activeAgencies(tuple.getT2().intValue())
                    .inactiveAgencies(tuple.getT1().intValue() - tuple.getT2().intValue())
                    .build();

                return ApiResponse.<AgencyCountResponse>builder()
                    .success(true)
                    .message("Comptage des agences effectué")
                    .data(count)
                    .build();
            })
            .onErrorReturn(ApiResponse.<AgencyCountResponse>builder()
                .success(false)
                .message("Erreur lors du comptage")
                .data(null)
                .build());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\AuthReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.AuthReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import java.util.UUID;

/**
 * Contrôleur réactif d'authentification
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
@Tag(name = "Authentication", description = "APIs réactives d'authentification et de gestion des utilisateurs")
public class AuthReactiveController {

    private final AuthReactiveService authService;

    @Operation(
        summary = "Inscription d'un nouvel utilisateur",
        description = "Crée un nouveau compte utilisateur avec validation email"
    )
    @PostMapping("/register")
    public Mono<AuthResponse> register(@Valid @RequestBody RegisterRequest registerRequest) {
        log.info("POST /auth/register - Registering user: {}", registerRequest.getEmail());

        return authService.register(registerRequest)
            .doOnSuccess(response -> log.info("User registered successfully: {}", registerRequest.getEmail()))
            .doOnError(error -> log.error("Registration failed for: {}", registerRequest.getEmail(), error));
    }

    @Operation(
        summary = "Connexion utilisateur",
        description = "Authentifie un utilisateur et retourne les tokens JWT"
    )
    @PostMapping("/login")
    public Mono<AuthResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        log.info("POST /auth/login - Login attempt: {}", loginRequest.getEmail());

        return authService.login(loginRequest)
            .doOnSuccess(response -> log.info("User logged in successfully: {}", loginRequest.getEmail()))
            .doOnError(error -> log.error("Login failed for: {}", loginRequest.getEmail(), error));
    }

    @Operation(
        summary = "Renouvellement du token d'accès",
        description = "Génère un nouveau token d'accès à partir du refresh token"
    )
    @PostMapping("/refresh")
    public Mono<AuthResponse> refreshToken(@Valid @RequestBody RefreshTokenRequest refreshRequest) {
        log.info("POST /auth/refresh - Refreshing token");

        return authService.refreshToken(refreshRequest)
            .doOnSuccess(response -> log.info("Token refreshed successfully"))
            .doOnError(error -> log.error("Token refresh failed", error));
    }

    @Operation(
        summary = "Déconnexion",
        description = "Déconnecte l'utilisateur (côté client principalement)"
    )
    @PostMapping("/logout")
    public Mono<ApiResponse<String>> logout() {
        log.info("POST /auth/logout - User logout");

        // Dans un système JWT stateless, la déconnexion se fait côté client
        // En supprimant les tokens du stockage local
        return Mono.just(ApiResponse.<String>builder()
            .success(true)
            .message("Logged out successfully")
            .data("Please remove tokens from client storage")
            .build());
    }

    @Operation(
        summary = "Changement de mot de passe",
        description = "Change le mot de passe de l'utilisateur connecté"
    )
    @PostMapping("/change-password")
    public Mono<ApiResponse<String>> changePassword(
        @Valid @RequestBody ChangePasswordRequest changeRequest,
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId) {

        log.info("POST /auth/change-password - Changing password for user: {}", userId);

        return authService.changePassword(changeRequest, userId)
            .doOnSuccess(response -> log.info("Password changed successfully for user: {}", userId))
            .doOnError(error -> log.error("Password change failed for user: {}", userId, error));
    }

    @Operation(
        summary = "Demande de réinitialisation de mot de passe",
        description = "Envoie un email avec les instructions de réinitialisation"
    )
    @PostMapping("/forgot-password")
    public Mono<ApiResponse<String>> forgotPassword(@Valid @RequestBody ForgotPasswordRequest forgotRequest) {
        log.info("POST /auth/forgot-password - Password reset requested for: {}", forgotRequest.getEmail());

        return authService.forgotPassword(forgotRequest)
            .doOnSuccess(response -> log.info("Password reset instructions sent for: {}", forgotRequest.getEmail()))
            .doOnError(error -> log.error("Forgot password failed for: {}", forgotRequest.getEmail(), error));
    }

    @Operation(
        summary = "Réinitialisation du mot de passe",
        description = "Réinitialise le mot de passe avec le token reçu par email"
    )
    @PostMapping("/reset-password")
    public Mono<ApiResponse<String>> resetPassword(@Valid @RequestBody ResetPasswordRequest resetRequest) {
        log.info("POST /auth/reset-password - Resetting password with token");

        return authService.resetPassword(resetRequest)
            .doOnSuccess(response -> log.info("Password reset successfully"))
            .doOnError(error -> log.error("Password reset failed", error));
    }

    @Operation(
        summary = "Vérification d'email",
        description = "Vérifie l'adresse email avec le token reçu"
    )
    @PostMapping("/verify-email")
    public Mono<ApiResponse<String>> verifyEmail(
        @Parameter(description = "Token de vérification email")
        @RequestParam String token) {

        log.info("POST /auth/verify-email - Verifying email with token");

        return authService.verifyEmail(token)
            .doOnSuccess(response -> log.info("Email verified successfully"))
            .doOnError(error -> log.error("Email verification failed", error));
    }

    @Operation(
        summary = "Profil utilisateur connecté",
        description = "Récupère les informations de l'utilisateur connecté"
    )
    @GetMapping("/me")
    public Mono<ApiResponse<UserResponse>> getCurrentUser(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId) {

        log.info("GET /auth/me - Getting current user profile: {}", userId);

        return authService.getCurrentUser(userId)
            .doOnSuccess(response -> log.info("User profile retrieved for: {}", userId))
            .doOnError(error -> log.error("Failed to get user profile for: {}", userId, error));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\DriverReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

public class DriverReactiveController {
    
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\HealthReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/health")
@Slf4j
@Tag(name = "Health", description = "API de santé de l'application")
public class HealthReactiveController {

    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Vérifier la santé de l'application", description = "Retourne le statut de santé de l'application")
    public Mono<ApiResponse<Map<String, Object>>> health() {
        log.debug("Health check requested");

        Map<String, Object> healthData = Map.of(
            "status", "UP",
            "timestamp", LocalDateTime.now(),
            "service", "Rental API Reactive",
            "version", "1.0.0",
            "environment", "development"
        );

        return Mono.just(ApiResponse.success(healthData, "Application is healthy"));
    }

    @GetMapping(value = "/readiness", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Vérifier la disponibilité", description = "Vérifie si l'application est prête à recevoir du trafic")
    public Mono<ApiResponse<Map<String, Object>>> readiness() {
        log.debug("Readiness check requested");

        Map<String, Object> readinessData = Map.of(
            "status", "READY",
            "timestamp", LocalDateTime.now(),
            "checks", Map.of(
                "database", "UP",
                "memory", "OK",
                "disk", "OK"
            )
        );

        return Mono.just(ApiResponse.success(readinessData, "Application is ready"));
    }

    @GetMapping(value = "/liveness", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Vérifier la vivacité", description = "Vérifie si l'application est vivante")
    public Mono<ApiResponse<Map<String, Object>>> liveness() {
        log.debug("Liveness check requested");

        Map<String, Object> livenessData = Map.of(
            "status", "ALIVE",
            "timestamp", LocalDateTime.now(),
            "uptime", "running"
        );

        return Mono.just(ApiResponse.success(livenessData, "Application is alive"));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\OnboardingReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.OnboardingReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@Slf4j
@RestController
@RequestMapping("/api/v1/onboarding")
@RequiredArgsConstructor
@Tag(name = "Onboarding", description = "APIs réactives pour le processus d'inscription et de création d'organisation")
public class OnboardingReactiveController {

    private final OnboardingReactiveService onboardingService;

    @Operation(
        summary = "Démarrer une nouvelle session d'onboarding",
        description = "Crée une nouvelle session et retourne un token de session pour les étapes suivantes."
    )
    @PostMapping("/start")
    public Mono<ApiResponse<OnboardingResponse>> startOnboarding() {
        log.info("POST /onboarding/start - Starting new onboarding session");
        return onboardingService.startOnboarding()
            .map(response -> ApiResponse.<OnboardingResponse>builder()
                .success(true)
                .message("Session d'onboarding démarrée avec succès.")
                .data(response)
                .build())
            .doOnError(error -> log.error("Failed to start onboarding session", error));
    }

    @Operation(
        summary = "Récupérer le statut d'une session d'onboarding",
        description = "Retourne l'état actuel d'une session d'onboarding, y compris l'étape en cours."
    )
    @GetMapping("/{sessionToken}/status")
    public Mono<ApiResponse<OnboardingResponse>> getOnboardingStatus(
        @Parameter(description = "Token de la session d'onboarding") @PathVariable String sessionToken) {

        log.info("GET /onboarding/{}/status - Fetching onboarding status", sessionToken);
        return onboardingService.getOnboardingStatus(sessionToken)
            .map(response -> ApiResponse.<OnboardingResponse>builder()
                .success(true)
                .message("Statut de la session récupéré avec succès.")
                .data(response)
                .build())
            .doOnError(error -> log.error("Failed to get onboarding status for session {}", sessionToken, error));
    }

    @Operation(
        summary = "Étape 1: Sauvegarder les informations du propriétaire",
        description = "Sauvegarde les informations sur le propriétaire du compte (email, mot de passe, etc.)."
    )
    @PutMapping("/{sessionToken}/owner")
    public Mono<ApiResponse<OnboardingResponse>> saveOwnerInfo(
        @Parameter(description = "Token de la session d'onboarding") @PathVariable String sessionToken,
        @Valid @RequestBody OnboardingOwnerRequest ownerRequest) {

        log.info("PUT /onboarding/{}/owner - Saving owner info", sessionToken);
        return onboardingService.saveOwnerInfo(sessionToken, ownerRequest)
            .map(response -> ApiResponse.<OnboardingResponse>builder()
                .success(true)
                .message("Étape 1: Informations du propriétaire sauvegardées.")
                .data(response)
                .build())
            .doOnError(error -> log.error("Error saving owner info for session {}", sessionToken, error));
    }

    @Operation(
        summary = "Étape 2: Sauvegarder les informations de l'organisation",
        description = "Sauvegarde les informations sur l'organisation (nom, type, adresse, etc.)."
    )
    @PutMapping("/{sessionToken}/organization")
    public Mono<ApiResponse<OnboardingResponse>> saveOrganizationInfo(
        @Parameter(description = "Token de la session d'onboarding") @PathVariable String sessionToken,
        @Valid @RequestBody OnboardingOrganizationRequest orgRequest) {

        log.info("PUT /onboarding/{}/organization - Saving organization info", sessionToken);
        return onboardingService.saveOrganizationInfo(sessionToken, orgRequest)
            .map(response -> ApiResponse.<OnboardingResponse>builder()
                .success(true)
                .message("Étape 2: Informations de l'organisation sauvegardées.")
                .data(response)
                .build())
            .doOnError(error -> log.error("Error saving organization info for session {}", sessionToken, error));
    }

    @Operation(
        summary = "Étape 3: Sauvegarder les informations de l'abonnement",
        description = "Sauvegarde le choix du plan d'abonnement et les informations de paiement."
    )
    @PutMapping("/{sessionToken}/subscription")
    public Mono<ApiResponse<OnboardingResponse>> saveSubscriptionInfo(
        @Parameter(description = "Token de la session d'onboarding") @PathVariable String sessionToken,
        @Valid @RequestBody OnboardingSubscriptionRequest subscriptionRequest) {

        log.info("PUT /onboarding/{}/subscription - Saving subscription info", sessionToken);
        return onboardingService.saveSubscriptionInfo(sessionToken, subscriptionRequest)
            .map(response -> ApiResponse.<OnboardingResponse>builder()
                .success(true)
                .message("Étape 3: Informations de l'abonnement sauvegardées.")
                .data(response)
                .build())
            .doOnError(error -> log.error("Error saving subscription info for session {}", sessionToken, error));
    }

    @Operation(
        summary = "Finaliser l'onboarding",
        description = "Valide toutes les informations collectées, crée l'utilisateur, l'organisation, l'abonnement, et clôture la session."
    )
    @PostMapping("/{sessionToken}/complete")
    public Mono<ApiResponse<OnboardingCompletionResponse>> completeOnboarding(
        @Parameter(description = "Token de la session d'onboarding") @PathVariable String sessionToken) {

        log.info("POST /onboarding/{}/complete - Completing onboarding process", sessionToken);
        return onboardingService.completeOnboarding(sessionToken)
            .map(response -> ApiResponse.<OnboardingCompletionResponse>builder()
                .success(true)
                .message(response.getMessage())
                .data(response)
                .build())
            .doOnError(error -> log.error("Failed to complete onboarding for session {}", sessionToken, error));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\OrganizationReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.OrganizationReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.security.UserPrincipal;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.application.dto.OrganizationType;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

/**
 * Contrôleur réactif pour la gestion des organisations
 */
@RestController
@RequestMapping("/api/v1/organizations")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Organizations", description = "API réactive de gestion des organisations")
public class OrganizationReactiveController {

    private final OrganizationReactiveService organizationService;

    @Operation(
        summary = "Créer une nouvelle organisation",
        description = "Crée une nouvelle organisation dans le système"
    )
    @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationResponse>> createOrganization(
        @Valid @RequestBody CreateOrganizationRequest createRequest,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("POST /api/v1/organizations - Creating organization: {}", createRequest.getName());

        return organizationService.createOrganization(createRequest, userPrincipal.getId())
            .map(organization -> ApiResponse.<OrganizationResponse>builder()
                .success(true)
                .message("Organisation créée avec succès")
                .data(organization)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Erreur lors de la création de l'organisation")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir toutes les organisations",
        description = "Récupère la liste des organisations selon les permissions de l'utilisateur"
    )
    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<OrganizationResponse>>> getAllOrganizations(
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations - Getting organizations for user: {}", userPrincipal.getId());

        Flux<OrganizationResponse> organizations = organizationService.findAll(userPrincipal.getId());

        return Mono.fromCallable(() -> ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(true)
                .message("Organisations récupérées avec succès")
                .data(organizations)
                .build())
            .onErrorReturn(ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(false)
                .message("Erreur lors de la récupération des organisations")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir une organisation par ID",
        description = "Récupère une organisation spécifique par son ID"
    )
    @GetMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationResponse>> getOrganizationById(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/{} - Getting organization by ID", id);

        return organizationService.findById(id, userPrincipal.getId())
            .map(org -> ApiResponse.<OrganizationResponse>builder()
                .success(true)
                .message("Organisation trouvée")
                .data(org)
                .build())
            .switchIfEmpty(Mono.just(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Organisation non trouvée")
                .data(null)
                .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message("Accès refusé à cette organisation")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Erreur lors de la récupération de l'organisation")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Mettre à jour une organisation",
        description = "Met à jour les informations d'une organisation"
    )
    @PutMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationResponse>> updateOrganization(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @Valid @RequestBody UpdateOrganizationRequest updateRequest,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PUT /api/v1/organizations/{} - Updating organization", id);

        return organizationService.updateOrganization(id, updateRequest, userPrincipal.getId())
            .map(organization -> ApiResponse.<OrganizationResponse>builder()
                .success(true)
                .message("Organisation mise à jour avec succès")
                .data(organization)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Erreur lors de la mise à jour de l'organisation")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Supprimer une organisation",
        description = "Supprime une organisation (soft delete)"
    )
    @DeleteMapping(value = "/{id}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Void>> deleteOrganization(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("DELETE /api/v1/organizations/{} - Deleting organization", id);

        return organizationService.deleteById(id, userPrincipal.getId())
            .then(Mono.just(ApiResponse.<Void>builder()
                .success(true)
                .message("Organisation supprimée avec succès")
                .data(null)
                .build()))
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<Void>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<Void>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<Void>builder()
                .success(false)
                .message("Erreur lors de la suppression de l'organisation")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les organisations actives",
        description = "Récupère toutes les organisations actives"
    )
    @GetMapping(value = "/active", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<OrganizationResponse>>> getActiveOrganizations(
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/active - Getting active organizations");

        Flux<OrganizationResponse> organizations = organizationService.findAllActive(userPrincipal.getId());

        return Mono.fromCallable(() -> ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(true)
                .message("Organisations actives récupérées")
                .data(organizations)
                .build())
            .onErrorReturn(ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(false)
                .message("Erreur lors de la récupération des organisations actives")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Vérifier l'existence d'un nom d'organisation",
        description = "Vérifie si un nom d'organisation est déjà utilisé"
    )
    @GetMapping(value = "/exists/{name}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Boolean>> checkOrganizationNameExists(
        @Parameter(description = "Nom à vérifier") @PathVariable String name) {

        log.info("GET /api/v1/organizations/exists/{} - Checking if organization name exists", name);

        return organizationService.existsByName(name)
            .map(exists -> ApiResponse.<Boolean>builder()
                .success(true)
                .message(exists ? "Nom existe" : "Nom disponible")
                .data(exists)
                .build())
            .onErrorReturn(ApiResponse.<Boolean>builder()
                .success(false)
                .message("Erreur lors de la vérification du nom d'organisation")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Activer/désactiver une organisation",
        description = "Change le statut actif d'une organisation"
    )
    @PatchMapping(value = "/{id}/status", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationResponse>> toggleOrganizationStatus(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @RequestParam boolean isActive,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PATCH /api/v1/organizations/{}/status - Toggling status to {}", id, isActive);

        return organizationService.toggleOrganizationStatus(id, isActive, userPrincipal.getId())
            .map(organization -> ApiResponse.<OrganizationResponse>builder()
                .success(true)
                .message("Statut de l'organisation modifié avec succès")
                .data(organization)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Erreur lors du changement de statut")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Vérifier une organisation",
        description = "Marque une organisation comme vérifiée (Super Admin uniquement)"
    )
    @PatchMapping(value = "/{id}/verify", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationResponse>> verifyOrganization(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PATCH /api/v1/organizations/{}/verify - Verifying organization", id);

        return organizationService.verifyOrganization(id, userPrincipal.getId())
            .map(organization -> ApiResponse.<OrganizationResponse>builder()
                .success(true)
                .message("Organisation vérifiée avec succès")
                .data(organization)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Erreur lors de la vérification")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les organisations par type",
        description = "Récupère les organisations d'un type spécifique"
    )
    @GetMapping(value = "/type/{type}", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<OrganizationResponse>>> getOrganizationsByType(
        @Parameter(description = "Type d'organisation") @PathVariable OrganizationType type,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/type/{} - Getting organizations by type", type);

        Flux<OrganizationResponse> organizations = organizationService.findByType(type, userPrincipal.getId());

        return Mono.fromCallable(() -> ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(true)
                .message("Organisations trouvées pour le type " + type.getDisplayName())
                .data(organizations)
                .build())
            .onErrorReturn(ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(false)
                .message("Erreur lors de la recherche par type")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les organisations par localisation",
        description = "Récupère les organisations par ville et pays"
    )
    @GetMapping(value = "/location", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<OrganizationResponse>>> getOrganizationsByLocation(
        @RequestParam String city,
        @RequestParam String country,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/location - Getting organizations in {} - {}", city, country);

        Flux<OrganizationResponse> organizations = organizationService.findByCityAndCountry(city, country, userPrincipal.getId());

        return Mono.fromCallable(() -> ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(true)
                .message("Organisations trouvées pour la localisation")
                .data(organizations)
                .build())
            .onErrorReturn(ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(false)
                .message("Erreur lors de la recherche par localisation")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les statistiques d'une organisation",
        description = "Récupère les statistiques détaillées d'une organisation"
    )
    @GetMapping(value = "/{id}/statistics", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationStatisticsResponse>> getOrganizationStatistics(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/{}/statistics - Getting organization statistics", id);

        return organizationService.getOrganizationStatistics(id, userPrincipal.getId())
            .map(stats -> ApiResponse.<OrganizationStatisticsResponse>builder()
                .success(true)
                .message("Statistiques de l'organisation récupérées")
                .data(stats)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<OrganizationStatisticsResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<OrganizationStatisticsResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationStatisticsResponse>builder()
                .success(false)
                .message("Erreur lors de la récupération des statistiques")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Mettre à jour les statistiques d'une organisation",
        description = "Met à jour les statistiques d'une organisation (usage interne)"
    )
    @PutMapping(value = "/{id}/statistics", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationResponse>> updateOrganizationStatistics(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @Valid @RequestBody OrganizationStatisticsRequest statsRequest,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PUT /api/v1/organizations/{}/statistics - Updating organization statistics", id);

        return organizationService.updateOrganizationStatistics(id, statsRequest)
            .map(organization -> ApiResponse.<OrganizationResponse>builder()
                .success(true)
                .message("Statistiques mises à jour avec succès")
                .data(organization)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Erreur lors de la mise à jour des statistiques")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Mettre à jour l'abonnement d'une organisation",
        description = "Met à jour le plan d'abonnement d'une organisation"
    )
    @PutMapping(value = "/{id}/subscription", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationResponse>> updateSubscription(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @Valid @RequestBody UpdateSubscriptionRequest subscriptionRequest,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("PUT /api/v1/organizations/{}/subscription - Updating subscription", id);

        return organizationService.updateSubscription(id, subscriptionRequest, userPrincipal.getId())
            .map(organization -> ApiResponse.<OrganizationResponse>builder()
                .success(true)
                .message("Abonnement mis à jour avec succès")
                .data(organization)
                .build())
            .onErrorResume(IllegalArgumentException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message(error.getMessage())
                    .data(null)
                    .build()))
            .onErrorResume(SecurityException.class, error ->
                Mono.just(ApiResponse.<OrganizationResponse>builder()
                    .success(false)
                    .message("Accès refusé")
                    .data(null)
                    .build()))
            .onErrorReturn(ApiResponse.<OrganizationResponse>builder()
                .success(false)
                .message("Erreur lors de la mise à jour de l'abonnement")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les organisations nécessitant une attention",
        description = "Récupère les organisations avec des alertes (abonnement expirant, non vérifiées, etc.)"
    )
    @GetMapping(value = "/alerts", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<OrganizationResponse>>> getOrganizationsNeedingAttention(
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/alerts - Getting organizations needing attention");

        Flux<OrganizationResponse> organizations = organizationService.findOrganizationsNeedingAttention(userPrincipal.getId());

        return Mono.fromCallable(() -> ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(true)
                .message("Organisations nécessitant une attention trouvées")
                .data(organizations)
                .build())
            .onErrorReturn(ApiResponse.<Flux<OrganizationResponse>>builder()
                .success(false)
                .message("Erreur lors de la recherche d'alertes")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Obtenir les agences d'une organisation",
        description = "Récupère toutes les agences d'une organisation"
    )
    @GetMapping(value = "/{id}/agencies", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<Flux<AgencyResponse>>> getOrganizationAgencies(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @RequestParam(defaultValue = "false") boolean activeOnly,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/{}/agencies - Getting organization agencies, activeOnly: {}", id, activeOnly);

        // Cette méthode sera déléguée au service des agences
        // Pour l'instant, nous retournons une réponse placeholder
        return Mono.fromCallable(() -> ApiResponse.<Flux<AgencyResponse>>builder()
            .success(true)
            .message("Redirection vers /api/v1/agencies/organization/" + id)
            .data(null)
            .build());
    }

    @Operation(
        summary = "Obtenir les statistiques générales",
        description = "Récupère les statistiques générales d'une organisation (tableau de bord)"
    )
    @GetMapping(value = "/{id}/stats", produces = MediaType.APPLICATION_JSON_VALUE)
    public Mono<ApiResponse<OrganizationDashboardResponse>> getOrganizationDashboard(
        @Parameter(description = "ID de l'organisation") @PathVariable UUID id,
        @AuthenticationPrincipal UserPrincipal userPrincipal) {

        log.info("GET /api/v1/organizations/{}/stats - Getting organization dashboard", id);

        return organizationService.getOrganizationStatistics(id, userPrincipal.getId())
            .map(stats -> {
                // Convertir les statistiques en format dashboard
                OrganizationDashboardResponse dashboard = OrganizationDashboardResponse.builder()
                    .organizationId(stats.getOrganizationId())
                    .totalAgencies(stats.getTotalAgencies())
                    .activeAgencies(stats.getActiveAgencies())
                    .totalVehicles(stats.getTotalVehicles())
                    .totalDrivers(stats.getTotalDrivers())
                    .totalUsers(stats.getTotalUsers())
                    .monthlyRevenue(stats.getMonthlyRevenue())
                    .totalRentals(stats.getTotalRentals())
                    .agencyUtilization(stats.getAgencyUsagePercentage())
                    .vehicleUtilization(stats.getVehicleUsagePercentage())
                    .subscriptionStatus(stats.getIsSubscriptionActive() ? "ACTIVE" : "EXPIRED")
                    .alertsCount(calculateAlertsCount(stats))
                    .build();

                return ApiResponse.<OrganizationDashboardResponse>builder()
                    .success(true)
                    .message("Tableau de bord récupéré")
                    .data(dashboard)
                    .build();
            })
            .onErrorReturn(ApiResponse.<OrganizationDashboardResponse>builder()
                .success(false)
                .message("Erreur lors de la récupération du tableau de bord")
                .data(null)
                .build());
    }

    // === MÉTHODES PRIVÉES ===

    /**
     * Calcule le nombre d'alertes pour une organisation
     */
    private int calculateAlertsCount(OrganizationStatisticsResponse stats) {
        int alerts = 0;

        // Abonnement expirant ou expiré
        if (!stats.getIsSubscriptionActive()) {
            alerts++;
        }

        // Utilisation proche de la limite (> 80%)
        if (stats.getAgencyUsagePercentage() > 80 ||
            stats.getVehicleUsagePercentage() > 80) {
            alerts++;
        }

        // Pas d'activité récente (plus de 30 jours)
        if (stats.getLastActivityAt() != null &&
            stats.getLastActivityAt().isBefore(java.time.LocalDateTime.now().minusDays(30))) {
            alerts++;
        }

        return alerts;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\PermissionReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.PermissionReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Set;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/permissions")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Permission Management", description = "APIs de gestion des permissions")
public class PermissionReactiveController {

    private final PermissionReactiveService permissionService;

    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Lister toutes les permissions", description = "Récupère toutes les permissions disponibles dans le système")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<Flux<PermissionResponse>>> getAllPermissions() {
        log.info("GET /api/v1/permissions - Getting all permissions");

        Flux<PermissionResponse> permissions = permissionService.getAllPermissions();

        return Mono.just(ApiResponse.<Flux<PermissionResponse>>builder()
            .success(true)
            .message("Permissions récupérées avec succès")
            .data(permissions)
            .build());
    }

    @GetMapping(value = "/resources", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Lister les ressources", description = "Récupère toutes les ressources disponibles")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<Flux<String>>> getAllResources() {
        log.info("GET /api/v1/permissions/resources - Getting all resources");

        Flux<String> resources = permissionService.getAllResources();

        return Mono.just(ApiResponse.<Flux<String>>builder()
            .success(true)
            .message("Ressources récupérées avec succès")
            .data(resources)
            .build());
    }

    @GetMapping(value = "/resources/{resource}", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir les permissions par ressource", description = "Récupère toutes les permissions pour une ressource spécifique")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<ResourcePermissionsResponse>> getPermissionsByResource(
        @Parameter(description = "Nom de la ressource")
        @PathVariable String resource) {

        log.info("GET /api/v1/permissions/resources/{} - Getting permissions for resource", resource);

        return permissionService.getPermissionsByResource(resource)
            .map(resourcePermissions -> ApiResponse.<ResourcePermissionsResponse>builder()
                .success(true)
                .message("Permissions de la ressource récupérées avec succès")
                .data(resourcePermissions)
                .build());
    }

    @GetMapping(value = "/users/{userId}", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir les permissions d'un utilisateur", description = "Récupère toutes les permissions effectives d'un utilisateur")
    @PreAuthorize("hasPermission('USER', 'READ')")
    public Mono<ApiResponse<UserPermissionsResponse>> getUserPermissions(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId) {

        log.info("GET /api/v1/permissions/users/{} - Getting user permissions", userId);

        return permissionService.getUserPermissions(userId)
            .map(userPermissions -> ApiResponse.<UserPermissionsResponse>builder()
                .success(true)
                .message("Permissions utilisateur récupérées avec succès")
                .data(userPermissions)
                .build());
    }

    @GetMapping(value = "/users/{userId}/check", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Vérifier une permission", description = "Vérifie si un utilisateur possède une permission spécifique")
    @PreAuthorize("hasPermission('USER', 'READ')")
    public Mono<ApiResponse<PermissionCheckResponse>> checkPermission(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "Code de la permission à vérifier")
        @RequestParam String permission) {

        log.info("GET /api/v1/permissions/users/{}/check - Checking permission: {}", userId, permission);

        return permissionService.hasPermission(userId, permission)
            .map(hasPermission -> {
                PermissionCheckResponse response = PermissionCheckResponse.builder()
                    .userId(userId)
                    .permission(permission)
                    .hasPermission(hasPermission)
                    .build();

                return ApiResponse.<PermissionCheckResponse>builder()
                    .success(true)
                    .message("Vérification de permission effectuée")
                    .data(response)
                    .build();
            });
    }

    @PostMapping(value = "/users/{userId}/check-multiple", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Vérifier plusieurs permissions", description = "Vérifie si un utilisateur possède plusieurs permissions")
    @PreAuthorize("hasPermission('USER', 'READ')")
    public Mono<ApiResponse<MultiplePermissionCheckResponse>> checkMultiplePermissions(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @RequestBody CheckMultiplePermissionsRequest request) {

        log.info("POST /api/v1/permissions/users/{}/check-multiple - Checking {} permissions",
            userId, request.getPermissions().size());

        return Mono.zip(
            permissionService.hasAllPermissions(userId, request.getPermissions()),
            permissionService.hasAnyPermission(userId, request.getPermissions())
        ).map(tuple -> {
            MultiplePermissionCheckResponse response = MultiplePermissionCheckResponse.builder()
                .userId(userId)
                .permissions(request.getPermissions())
                .hasAllPermissions(tuple.getT1())
                .hasAnyPermissions(tuple.getT2())
                .build();

            return ApiResponse.<MultiplePermissionCheckResponse>builder()
                .success(true)
                .message("Vérification multiple effectuée")
                .data(response)
                .build();
        });
    }

    @GetMapping(value = "/compare/{userId1}/{userId2}", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Comparer les permissions", description = "Compare les permissions entre deux utilisateurs")
    @PreAuthorize("hasPermission('USER', 'READ')")
    public Mono<ApiResponse<PermissionComparisonResponse>> comparePermissions(
        @Parameter(description = "ID du premier utilisateur")
        @PathVariable UUID userId1,
        @Parameter(description = "ID du deuxième utilisateur")
        @PathVariable UUID userId2) {

        log.info("GET /api/v1/permissions/compare/{}/{} - Comparing permissions", userId1, userId2);

        return permissionService.compareUserPermissions(userId1, userId2)
            .map(comparison -> ApiResponse.<PermissionComparisonResponse>builder()
                .success(true)
                .message("Comparaison des permissions effectuée")
                .data(comparison)
                .build());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\PersonnelReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.PersonnelReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import java.util.UUID;

/**
 * Contrôleur réactif pour la gestion du personnel
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/personnel")
@RequiredArgsConstructor
@Tag(name = "Personnel Management", description = "APIs réactives de gestion du personnel d'organisation")
public class PersonnelReactiveController {

    private final PersonnelReactiveService personnelService;

    @Operation(
        summary = "Créer un nouveau membre du personnel",
        description = "Crée un nouveau utilisateur de type personnel (AGENCY_MANAGER, RENTAL_AGENT, DRIVER) et l'affecte à une agence"
    )
    @PostMapping
    public Mono<ApiResponse<PersonnelResponse>> createPersonnel(
        @Valid @RequestBody CreatePersonnelRequest createRequest,
        @Parameter(description = "ID de l'utilisateur connecté (ORGANIZATION_OWNER)")
        @RequestHeader("X-User-Id") UUID createdBy) {

        log.info("POST /personnel - Creating personnel: {} for organization: {}",
            createRequest.getEmail(), createRequest.getOrganizationId());

        return personnelService.createPersonnel(createRequest, createdBy)
            .map(personnel -> ApiResponse.<PersonnelResponse>builder()
                .success(true)
                .message("Personnel créé avec succès")
                .data(personnel)
                .build())
            .doOnSuccess(response -> log.info("Personnel created successfully: {}", createRequest.getEmail()))
            .doOnError(error -> log.error("Failed to create personnel: {}", createRequest.getEmail(), error));
    }

    @Operation(
        summary = "Récupérer tous les membres du personnel",
        description = "Retourne la liste du personnel d'une organisation avec filtres optionnels"
    )
    @GetMapping
    public Mono<ApiResponse<java.util.List<PersonnelResponse>>> getAllPersonnel(
        @Parameter(description = "ID de l'organisation")
        @RequestParam UUID organizationId,
        @Parameter(description = "ID de l'agence (optionnel)")
        @RequestParam(required = false) UUID agencyId,
        @Parameter(description = "Type d'utilisateur (optionnel)")
        @RequestParam(required = false) UserType userType,
        @Parameter(description = "Statut actif (optionnel)")
        @RequestParam(required = false) Boolean isActive) {

        log.info("GET /personnel - Fetching personnel for organization: {}, agency: {}",
            organizationId, agencyId);

        return personnelService.getPersonnelByFilters(organizationId, agencyId, userType, isActive)
            .collectList()
            .map(personnel -> ApiResponse.<java.util.List<PersonnelResponse>>builder()
                .success(true)
                .message("Personnel récupéré avec succès")
                .data(personnel)
                .count((long) personnel.size())
                .build())
            .doOnSuccess(response -> log.info("Retrieved {} personnel members", response.getData().size()));
    }

    @Operation(
        summary = "Récupérer un membre du personnel par ID",
        description = "Retourne les détails d'un membre du personnel spécifique"
    )
    @GetMapping("/{personnelId}")
    public Mono<ApiResponse<PersonnelResponse>> getPersonnelById(
        @Parameter(description = "ID du personnel")
        @PathVariable UUID personnelId) {

        log.info("GET /personnel/{} - Fetching personnel details", personnelId);

        return personnelService.getPersonnelById(personnelId)
            .map(personnel -> ApiResponse.<PersonnelResponse>builder()
                .success(true)
                .message("Personnel trouvé avec succès")
                .data(personnel)
                .build())
            .switchIfEmpty(Mono.just(ApiResponse.<PersonnelResponse>builder()
                .success(false)
                .message("Personnel non trouvé")
                .data(null)
                .build()))
            .doOnSuccess(response -> log.info("Personnel details retrieved: {}", personnelId));
    }

    @Operation(
        summary = "Mettre à jour un membre du personnel",
        description = "Met à jour les informations d'un membre du personnel"
    )
    @PutMapping("/{personnelId}")
    public Mono<ApiResponse<PersonnelResponse>> updatePersonnel(
        @Parameter(description = "ID du personnel")
        @PathVariable UUID personnelId,
        @Valid @RequestBody UpdatePersonnelRequest updateRequest,
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID updatedBy) {

        log.info("PUT /personnel/{} - Updating personnel", personnelId);

        return personnelService.updatePersonnel(personnelId, updateRequest, updatedBy)
            .map(personnel -> ApiResponse.<PersonnelResponse>builder()
                .success(true)
                .message("Personnel mis à jour avec succès")
                .data(personnel)
                .build())
            .doOnSuccess(response -> log.info("Personnel updated successfully: {}", personnelId))
            .doOnError(error -> log.error("Failed to update personnel: {}", personnelId, error));
    }

    @Operation(
        summary = "Assigner du personnel à une agence",
        description = "Assigne ou réassigne un membre du personnel à une agence"
    )
    @PutMapping("/{personnelId}/agency")
    public Mono<ApiResponse<PersonnelResponse>> assignToAgency(
        @Parameter(description = "ID du personnel")
        @PathVariable UUID personnelId,
        @Parameter(description = "ID de la nouvelle agence")
        @RequestParam UUID agencyId,
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID assignedBy) {

        log.info("PUT /personnel/{}/agency - Assigning to agency: {}", personnelId, agencyId);

        return personnelService.assignToAgency(personnelId, agencyId, assignedBy)
            .map(personnel -> ApiResponse.<PersonnelResponse>builder()
                .success(true)
                .message("Personnel assigné à l'agence avec succès")
                .data(personnel)
                .build())
            .doOnSuccess(response -> log.info("Personnel assigned to agency successfully: {}", personnelId))
            .doOnError(error -> log.error("Failed to assign personnel to agency: {}", personnelId, error));
    }

    @Operation(
        summary = "Activer/Désactiver un membre du personnel",
        description = "Active ou désactive un compte personnel"
    )
    @PutMapping("/{personnelId}/status")
    public Mono<ApiResponse<PersonnelResponse>> updateStatus(
        @Parameter(description = "ID du personnel")
        @PathVariable UUID personnelId,
        @Parameter(description = "Nouveau statut")
        @RequestParam Boolean isActive,
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID updatedBy) {

        log.info("PUT /personnel/{}/status - Updating status to: {}", personnelId, isActive);

        return personnelService.updateStatus(personnelId, isActive, updatedBy)
            .map(personnel -> ApiResponse.<PersonnelResponse>builder()
                .success(true)
                .message(isActive ? "Personnel activé avec succès" : "Personnel désactivé avec succès")
                .data(personnel)
                .build())
            .doOnSuccess(response -> log.info("Personnel status updated successfully: {}", personnelId))
            .doOnError(error -> log.error("Failed to update personnel status: {}", personnelId, error));
    }

    @Operation(
        summary = "Supprimer un membre du personnel",
        description = "Supprime définitivement un compte personnel (action irréversible)"
    )
    @DeleteMapping("/{personnelId}")
    public Mono<ApiResponse<String>> deletePersonnel(
        @Parameter(description = "ID du personnel")
        @PathVariable UUID personnelId,
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID deletedBy) {

        log.info("DELETE /personnel/{} - Deleting personnel", personnelId);

        return personnelService.deletePersonnel(personnelId, deletedBy)
            .then(Mono.just(ApiResponse.<String>builder()
                .success(true)
                .message("Personnel supprimé avec succès")
                .data("Personnel deleted")
                .build()))
            .doOnSuccess(response -> log.info("Personnel deleted successfully: {}", personnelId))
            .doOnError(error -> log.error("Failed to delete personnel: {}", personnelId, error));
    }

    @Operation(
        summary = "Récupérer le personnel par agence",
        description = "Retourne tous les membres du personnel d'une agence spécifique"
    )
    @GetMapping("/agency/{agencyId}")
    public Mono<ApiResponse<java.util.List<PersonnelResponse>>> getPersonnelByAgency(
        @Parameter(description = "ID de l'agence")
        @PathVariable UUID agencyId,
        @Parameter(description = "Type d'utilisateur (optionnel)")
        @RequestParam(required = false) UserType userType) {

        log.info("GET /personnel/agency/{} - Fetching personnel for agency", agencyId);

        return personnelService.getPersonnelByAgency(agencyId, userType)
            .collectList()
            .map(personnel -> ApiResponse.<java.util.List<PersonnelResponse>>builder()
                .success(true)
                .message("Personnel de l'agence récupéré avec succès")
                .data(personnel)
                .count((long) personnel.size())
                .build())
            .doOnSuccess(response -> log.info("Retrieved {} personnel for agency: {}",
                response.getData().size(), agencyId));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\RoleReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.RoleReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/roles")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Role Management", description = "APIs de gestion des rôles")
public class RoleReactiveController {

    private final RoleReactiveService roleService;

    @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseStatus(HttpStatus.CREATED)
    @Operation(summary = "Créer un nouveau rôle", description = "Crée un nouveau rôle personnalisé dans une organisation")
    @PreAuthorize("hasPermission('ROLE', 'WRITE')")
    public Mono<ApiResponse<RoleResponse>> createRole(
        @Valid @RequestBody CreateRoleRequest request,
        @Parameter(description = "ID de l'utilisateur créateur")
        @RequestHeader("X-User-Id") UUID createdBy) {

        log.info("POST /api/v1/roles - Creating role: {}", request.getName());

        return roleService.createRole(request, createdBy)
            .map(role -> ApiResponse.<RoleResponse>builder()
                .success(true)
                .message("Rôle créé avec succès")
                .data(role)
                .build())
            .doOnSuccess(response -> log.info("Role created: {}", response.getData().getId()))
            .doOnError(error -> log.error("Failed to create role: {}", request.getName(), error));
    }

    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Lister les rôles", description = "Récupère tous les rôles d'une organisation")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<Flux<RoleResponse>>> getRoles(
        @Parameter(description = "ID de l'organisation")
        @RequestParam UUID organizationId) {

        log.info("GET /api/v1/roles - Getting roles for organization: {}", organizationId);

        Flux<RoleResponse> roles = roleService.getRolesByOrganization(organizationId);

        return Mono.just(ApiResponse.<Flux<RoleResponse>>builder()
            .success(true)
            .message("Rôles récupérés avec succès")
            .data(roles)
            .build());
    }

    @GetMapping(value = "/{roleId}", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir un rôle", description = "Récupère les détails d'un rôle spécifique")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<RoleResponse>> getRole(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId) {

        log.info("GET /api/v1/roles/{} - Getting role details", roleId);

        return roleService.getRoleById(roleId)
            .map(role -> ApiResponse.<RoleResponse>builder()
                .success(true)
                .message("Rôle récupéré avec succès")
                .data(role)
                .build())
            .doOnSuccess(response -> log.info("Role retrieved: {}", roleId))
            .doOnError(error -> log.error("Failed to get role: {}", roleId, error));
    }

    @PutMapping(value = "/{roleId}", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Modifier un rôle", description = "Met à jour les informations d'un rôle existant")
    @PreAuthorize("hasPermission('ROLE', 'UPDATE')")
    public Mono<ApiResponse<RoleResponse>> updateRole(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId,
        @Valid @RequestBody UpdateRoleRequest request,
        @Parameter(description = "ID de l'utilisateur modificateur")
        @RequestHeader("X-User-Id") UUID updatedBy) {

        log.info("PUT /api/v1/roles/{} - Updating role", roleId);

        return roleService.updateRole(roleId, request, updatedBy)
            .map(role -> ApiResponse.<RoleResponse>builder()
                .success(true)
                .message("Rôle modifié avec succès")
                .data(role)
                .build())
            .doOnSuccess(response -> log.info("Role updated: {}", roleId))
            .doOnError(error -> log.error("Failed to update role: {}", roleId, error));
    }

    @DeleteMapping("/{roleId}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @Operation(summary = "Supprimer un rôle", description = "Supprime un rôle personnalisé")
    @PreAuthorize("hasPermission('ROLE', 'DELETE')")
    public Mono<ApiResponse<Void>> deleteRole(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId) {

        log.info("DELETE /api/v1/roles/{} - Deleting role", roleId);

        return roleService.deleteRole(roleId)
            .then(Mono.just(ApiResponse.<Void>builder()
                .success(true)
                .message("Rôle supprimé avec succès")
                .build()))
            .doOnSuccess(response -> log.info("Role deleted: {}", roleId))
            .doOnError(error -> log.error("Failed to delete role: {}", roleId, error));
    }

    @GetMapping(value = "/{roleId}/permissions", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir les permissions d'un rôle", description = "Récupère toutes les permissions associées à un rôle")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<RolePermissionsResponse>> getRolePermissions(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId) {

        log.info("GET /api/v1/roles/{}/permissions - Getting role permissions", roleId);

        return roleService.getRolePermissions(roleId)
            .map(permissions -> ApiResponse.<RolePermissionsResponse>builder()
                .success(true)
                .message("Permissions du rôle récupérées avec succès")
                .data(permissions)
                .build());
    }

    @PostMapping(value = "/{roleId}/clone", produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseStatus(HttpStatus.CREATED)
    @Operation(summary = "Cloner un rôle", description = "Crée une copie d'un rôle existant avec un nouveau nom")
    @PreAuthorize("hasPermission('ROLE', 'WRITE')")
    public Mono<ApiResponse<RoleResponse>> cloneRole(
        @Parameter(description = "ID du rôle à cloner")
        @PathVariable UUID roleId,
        @Valid @RequestBody CloneRoleRequest request,
        @Parameter(description = "ID de l'utilisateur créateur")
        @RequestHeader("X-User-Id") UUID createdBy) {

        log.info("POST /api/v1/roles/{}/clone - Cloning role with name: {}", roleId, request.getNewName());

        return roleService.cloneRole(roleId, request.getNewName(), createdBy)
            .map(role -> ApiResponse.<RoleResponse>builder()
                .success(true)
                .message("Rôle cloné avec succès")
                .data(role)
                .build())
            .doOnSuccess(response -> log.info("Role cloned: {}", response.getData().getId()));
    }

    @GetMapping(value = "/system", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir les rôles système", description = "Récupère tous les rôles prédéfinis du système")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<Flux<RoleResponse>>> getSystemRoles() {
        log.info("GET /api/v1/roles/system - Getting system roles");

        Flux<RoleResponse> systemRoles = roleService.getSystemRoles();

        return Mono.just(ApiResponse.<Flux<RoleResponse>>builder()
            .success(true)
            .message("Rôles système récupérés avec succès")
            .data(systemRoles)
            .build());
    }

    @GetMapping(value = "/defaults", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir les rôles par défaut", description = "Récupère les rôles par défaut d'une organisation")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<Flux<RoleResponse>>> getDefaultRoles(
        @Parameter(description = "ID de l'organisation")
        @RequestParam UUID organizationId) {

        log.info("GET /api/v1/roles/defaults - Getting default roles for organization: {}", organizationId);

        Flux<RoleResponse> defaultRoles = roleService.getDefaultRoles(organizationId);

        return Mono.just(ApiResponse.<Flux<RoleResponse>>builder()
            .success(true)
            .message("Rôles par défaut récupérés avec succès")
            .data(defaultRoles)
            .build());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\SubscriptionPlanReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.SubscriptionPlanReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.ApiResponse;
import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/v1/subscription")
@RequiredArgsConstructor
@Tag(name = "Subscription Plans", description = "APIs reactives de gestion des forfaits d'abonnement")
public class SubscriptionPlanReactiveController {

    private final SubscriptionPlanReactiveService subscriptionPlanService;

    @Operation(
        summary = "Récupérer tous les forfaits disponibles",
        description = "Retourne la liste de tous les forfaits d'abonnement actifs"
    )
    @GetMapping("/plans")
    public Mono<ApiResponse<List<SubscriptionPlan>>> getAllPlans() {
        log.info("GET /subscription/plans - Fetching all subscription plans");

        return subscriptionPlanService.getAllActivePlans()
            .collectList()
            .map(plans -> ApiResponse.<List<SubscriptionPlan>>builder()
                .success(true)
                .message("Forfaits d'abonnement récupérés avec succès")
                .data(plans)
                .count((long) plans.size())
                .build())
            .doOnSuccess(response -> log.info("Successfully fetched {} subscription plans", response.getData().size()))
            .onErrorReturn(ApiResponse.<List<SubscriptionPlan>>builder()
                .success(false)
                .message("Erreur lors de la récupération des forfaits d'abonnement")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Récupérer un forfait par ID",
        description = "Retourne les détails d'un forfait d'abonnement spécifique"
    )
    @GetMapping("/plans/{planId}")
    public Mono<ApiResponse<SubscriptionPlan>> getPlanById(
        @Parameter(description = "ID du forfait d'abonnement")
        @PathVariable UUID planId
    ) {
        log.info("GET /subscription/plans/{} - Fetching subscription plan", planId);

        return subscriptionPlanService.getPlanById(planId)
            .map(plan -> ApiResponse.<SubscriptionPlan>builder()
                .success(true)
                .message("Forfait d'abonnement trouvé avec succès")
                .data(plan)
                .build())
            .switchIfEmpty(Mono.just(ApiResponse.<SubscriptionPlan>builder()
                .success(false)
                .message("Forfait d'abonnement non trouvé")
                .data(null)
                .build()))
            .onErrorReturn(ApiResponse.<SubscriptionPlan>builder()
                .success(false)
                .message("Erreur lors de la récupération du forfait d'abonnement")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Récupérer les forfaits populaires",
        description = "Retourne les forfaits marqués comme populaires"
    )
    @GetMapping("/plans/popular")
    public Mono<ApiResponse<List<SubscriptionPlan>>> getPopularPlans() {
        log.info("GET /subscription/plans/popular - Fetching popular subscription plans");

        return subscriptionPlanService.getPopularPlans()
            .collectList()
            .map(plans -> ApiResponse.<List<SubscriptionPlan>>builder()
                .success(true)
                .message("Forfaits populaires récupérés avec succès")
                .data(plans)
                .count((long) plans.size())
                .build())
            .onErrorReturn(ApiResponse.<List<SubscriptionPlan>>builder()
                .success(false)
                .message("Erreur lors de la récupération des forfaits populaires")
                .data(null)
                .build());
    }

    @Operation(
        summary = "Récupérer les forfaits standards",
        description = "Retourne les forfaits non personnalisés"
    )
    @GetMapping("/plans/standard")
    public Mono<ApiResponse<List<SubscriptionPlan>>> getStandardPlans() {
        log.info("GET /subscription/plans/standard - Fetching standard subscription plans");

        return subscriptionPlanService.getStandardPlans()
            .collectList()
            .map(plans -> ApiResponse.<List<SubscriptionPlan>>builder()
                .success(true)
                .message("Forfaits standards récupérés avec succès")
                .data(plans)
                .count((long) plans.size())
                .build())
            .onErrorReturn(ApiResponse.<List<SubscriptionPlan>>builder()
                .success(false)
                .message("Erreur lors de la récupération des forfaits standards")
                .data(null)
                .build());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\UserProfileReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.UserReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import java.util.UUID;

/**
 * Contrôleur réactif pour la gestion du profil utilisateur
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/profile")
@RequiredArgsConstructor
@Tag(name = "User Profile", description = "APIs réactives de gestion du profil utilisateur")
public class UserProfileReactiveController {

    private final UserReactiveService userService;

    @Operation(
        summary = "Récupérer le profil utilisateur",
        description = "Récupère les informations détaillées du profil de l'utilisateur connecté"
    )
    @GetMapping
    public Mono<ApiResponse<UserResponse>> getProfile(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId) {

        log.info("GET /profile - Getting user profile: {}", userId);

        return userService.findById(userId)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Profil utilisateur récupéré avec succès")
                .data(user)
                .build())
            .switchIfEmpty(Mono.just(ApiResponse.<UserResponse>builder()
                .success(false)
                .message("Utilisateur non trouvé")
                .data(null)
                .build()))
            .doOnSuccess(response -> log.info("User profile retrieved successfully: {}", userId))
            .doOnError(error -> log.error("Failed to get user profile: {}", userId, error));
    }

    @Operation(
        summary = "Mettre à jour le profil utilisateur",
        description = "Met à jour les informations du profil de l'utilisateur connecté"
    )
    @PutMapping
    public Mono<ApiResponse<UserResponse>> updateProfile(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId,
        @Valid @RequestBody UpdateProfileRequest updateRequest) {

        log.info("PUT /profile - Updating user profile: {}", userId);

        return userService.updateProfile(userId, updateRequest)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Profil mis à jour avec succès")
                .data(user)
                .build())
            .doOnSuccess(response -> log.info("User profile updated successfully: {}", userId))
            .doOnError(error -> log.error("Failed to update user profile: {}", userId, error));
    }

    @Operation(
        summary = "Uploader une photo de profil",
        description = "Met à jour la photo de profil de l'utilisateur"
    )
    @PostMapping("/avatar")
    public Mono<ApiResponse<String>> uploadAvatar(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId,
        @Parameter(description = "URL de la nouvelle photo de profil")
        @RequestParam String avatarUrl) {

        log.info("POST /profile/avatar - Uploading avatar for user: {}", userId);

        return userService.updateAvatar(userId, avatarUrl)
            .map(updatedUrl -> ApiResponse.<String>builder()
                .success(true)
                .message("Photo de profil mise à jour avec succès")
                .data(updatedUrl)
                .build())
            .doOnSuccess(response -> log.info("Avatar updated successfully for user: {}", userId))
            .doOnError(error -> log.error("Failed to update avatar for user: {}", userId, error));
    }

    @Operation(
        summary = "Supprimer la photo de profil",
        description = "Supprime la photo de profil actuelle de l'utilisateur"
    )
    @DeleteMapping("/avatar")
    public Mono<ApiResponse<String>> deleteAvatar(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId) {

        log.info("DELETE /profile/avatar - Deleting avatar for user: {}", userId);

        return userService.deleteAvatar(userId)
            .then(Mono.just(ApiResponse.<String>builder()
                .success(true)
                .message("Photo de profil supprimée avec succès")
                .data("Avatar deleted")
                .build()))
            .doOnSuccess(response -> log.info("Avatar deleted successfully for user: {}", userId))
            .doOnError(error -> log.error("Failed to delete avatar for user: {}", userId, error));
    }

    @Operation(
        summary = "Mettre à jour les préférences utilisateur",
        description = "Met à jour les préférences de l'utilisateur (langue, fuseau horaire, notifications, etc.)"
    )
    @PutMapping("/preferences")
    public Mono<ApiResponse<UserResponse>> updatePreferences(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId,
        @Valid @RequestBody UserPreferencesRequest preferencesRequest) {

        log.info("PUT /profile/preferences - Updating preferences for user: {}", userId);

        return userService.updatePreferences(userId, preferencesRequest)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Préférences mises à jour avec succès")
                .data(user)
                .build())
            .doOnSuccess(response -> log.info("Preferences updated successfully for user: {}", userId))
            .doOnError(error -> log.error("Failed to update preferences for user: {}", userId, error));
    }

    @Operation(
        summary = "Désactiver le compte utilisateur",
        description = "Désactive le compte de l'utilisateur connecté (soft delete)"
    )
    @PostMapping("/deactivate")
    public Mono<ApiResponse<String>> deactivateAccount(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId,
        @Valid @RequestBody DeactivateAccountRequest deactivateRequest) {

        log.info("POST /profile/deactivate - Deactivating account for user: {}", userId);

        return userService.deactivateAccount(userId, deactivateRequest.getReason())
            .then(Mono.just(ApiResponse.<String>builder()
                .success(true)
                .message("Compte désactivé avec succès")
                .data("Account deactivated")
                .build()))
            .doOnSuccess(response -> log.info("Account deactivated successfully for user: {}", userId))
            .doOnError(error -> log.error("Failed to deactivate account for user: {}", userId, error));
    }

    @Operation(
        summary = "Récupérer les informations employé",
        description = "Récupère les informations spécifiques à l'employé (personnel uniquement)"
    )
    @GetMapping("/employee")
    public Mono<ApiResponse<EmployeeInfoResponse>> getEmployeeInfo(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId) {

        log.info("GET /profile/employee - Getting employee info for user: {}", userId);

        return userService.findById(userId)
            .filter(user -> user.getIsPersonnel())
            .map(user -> {
                EmployeeInfoResponse employeeInfo = new EmployeeInfoResponse();
                employeeInfo.setEmployeeId(user.getEmployeeId());
                employeeInfo.setDepartment(user.getDepartment());
                employeeInfo.setPosition(user.getPosition());
                employeeInfo.setSupervisorId(user.getSupervisorId());
                employeeInfo.setHiredAt(user.getHiredAt());
                employeeInfo.setMustChangePassword(user.getMustChangePassword());
                employeeInfo.setOrganizationId(user.getOrganizationId());
                employeeInfo.setAgencyId(user.getAgencyId());

                return ApiResponse.<EmployeeInfoResponse>builder()
                    .success(true)
                    .message("Informations employé récupérées avec succès")
                    .data(employeeInfo)
                    .build();
            })
            .switchIfEmpty(Mono.just(ApiResponse.<EmployeeInfoResponse>builder()
                .success(false)
                .message("Utilisateur non trouvé ou n'est pas un employé")
                .data(null)
                .build()))
            .doOnSuccess(response -> log.info("Employee info retrieved for user: {}", userId));
    }

    @Operation(
        summary = "Mettre à jour les paramètres de notification",
        description = "Met à jour les préférences de notification de l'utilisateur"
    )
    @PutMapping("/notifications")
    public Mono<ApiResponse<UserResponse>> updateNotificationSettings(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId,
        @Valid @RequestBody NotificationSettingsRequest notificationRequest) {

        log.info("PUT /profile/notifications - Updating notification settings for user: {}", userId);

        UserPreferencesRequest preferencesRequest = new UserPreferencesRequest();
        preferencesRequest.setEmailNotifications(notificationRequest.getEmailNotifications());
        preferencesRequest.setSmsNotifications(notificationRequest.getSmsNotifications());

        return userService.updatePreferences(userId, preferencesRequest)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Paramètres de notification mis à jour avec succès")
                .data(user)
                .build())
            .doOnSuccess(response -> log.info("Notification settings updated for user: {}", userId))
            .doOnError(error -> log.error("Failed to update notification settings for user: {}", userId, error));
    }

    @Operation(
        summary = "Changer la langue de l'interface",
        description = "Change la langue préférée de l'utilisateur"
    )
    @PutMapping("/language")
    public Mono<ApiResponse<UserResponse>> changeLanguage(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId,
        @Parameter(description = "Code de langue (fr, en, es, etc.)")
        @RequestParam String language) {

        log.info("PUT /profile/language - Changing language to {} for user: {}", language, userId);

        UserPreferencesRequest preferencesRequest = new UserPreferencesRequest();
        preferencesRequest.setPreferredLanguage(language);

        return userService.updatePreferences(userId, preferencesRequest)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Langue mise à jour avec succès")
                .data(user)
                .build())
            .doOnSuccess(response -> log.info("Language changed to {} for user: {}", language, userId))
            .doOnError(error -> log.error("Failed to change language for user: {}", userId, error));
    }

    @Operation(
        summary = "Changer le fuseau horaire",
        description = "Met à jour le fuseau horaire de l'utilisateur"
    )
    @PutMapping("/timezone")
    public Mono<ApiResponse<UserResponse>> changeTimezone(
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID userId,
        @Parameter(description = "Fuseau horaire (ex: Africa/Douala)")
        @RequestParam String timezone) {

        log.info("PUT /profile/timezone - Changing timezone to {} for user: {}", timezone, userId);

        UserPreferencesRequest preferencesRequest = new UserPreferencesRequest();
        preferencesRequest.setTimezone(timezone);

        return userService.updatePreferences(userId, preferencesRequest)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Fuseau horaire mis à jour avec succès")
                .data(user)
                .build())
            .doOnSuccess(response -> log.info("Timezone changed to {} for user: {}", timezone, userId))
            .doOnError(error -> log.error("Failed to change timezone for user: {}", userId, error));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\UserReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.UserReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import java.util.UUID;

/**
 * Contrôleur réactif pour la gestion des utilisateurs
 * Route de base: /api/v1/users
 */
@Slf4j
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
@Tag(name = "User Management", description = "APIs réactives de gestion des utilisateurs")
public class UserReactiveController {

    private final UserReactiveService userService;

    @Operation(
        summary = "Récupérer tous les utilisateurs",
        description = "Retourne la liste de tous les utilisateurs non supprimés"
    )
    @GetMapping
    public Mono<ApiResponse<java.util.List<UserResponse>>> getAllUsers(
        @Parameter(description = "ID de l'organisation (optionnel)")
        @RequestParam(required = false) UUID organizationId,
        @Parameter(description = "Type d'utilisateur (optionnel)")
        @RequestParam(required = false) UserType userType,
        @Parameter(description = "Utilisateurs actifs uniquement")
        @RequestParam(defaultValue = "true") Boolean activeOnly) {

        log.info("GET /users - Fetching users for organization: {}, type: {}, activeOnly: {}",
            organizationId, userType, activeOnly);

        if (organizationId != null) {
            return userService.findByOrganizationId(organizationId)
                .filter(user -> userType == null || userType.equals(user.getUserType()))
                .filter(user -> !activeOnly || user.getIsActive())
                .collectList()
                .map(users -> ApiResponse.<java.util.List<UserResponse>>builder()
                    .success(true)
                    .message("Utilisateurs récupérés avec succès")
                    .data(users)
                    .count((long) users.size())
                    .build());
        } else {
            return userService.findAll()
                .filter(user -> userType == null || userType.equals(user.getUserType()))
                .filter(user -> !activeOnly || user.getIsActive())
                .collectList()
                .map(users -> ApiResponse.<java.util.List<UserResponse>>builder()
                    .success(true)
                    .message("Utilisateurs récupérés avec succès")
                    .data(users)
                    .count((long) users.size())
                    .build());
        }
    }

    @Operation(
        summary = "Récupérer un utilisateur par ID",
        description = "Retourne les détails d'un utilisateur spécifique"
    )
    @GetMapping("/{userId}")
    public Mono<ApiResponse<UserResponse>> getUserById(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId) {

        log.info("GET /users/{} - Fetching user details", userId);

        return userService.findById(userId)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Utilisateur trouvé avec succès")
                .data(user)
                .build())
            .switchIfEmpty(Mono.just(ApiResponse.<UserResponse>builder()
                .success(false)
                .message("Utilisateur non trouvé")
                .data(null)
                .build()))
            .doOnSuccess(response -> log.info("User details retrieved: {}", userId));
    }

    @Operation(
        summary = "Récupérer un utilisateur par email",
        description = "Retourne les détails d'un utilisateur par son adresse email"
    )
    @GetMapping("/email/{email}")
    public Mono<ApiResponse<UserResponse>> getUserByEmail(
        @Parameter(description = "Email de l'utilisateur")
        @PathVariable String email) {

        log.info("GET /users/email/{} - Fetching user by email", email);

        return userService.findByEmail(email)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message("Utilisateur trouvé avec succès")
                .data(user)
                .build())
            .switchIfEmpty(Mono.just(ApiResponse.<UserResponse>builder()
                .success(false)
                .message("Utilisateur non trouvé avec cet email")
                .data(null)
                .build()))
            .doOnSuccess(response -> log.info("User found by email: {}", email));
    }

    @Operation(
        summary = "Mettre à jour le statut d'un utilisateur",
        description = "Active ou désactive un compte utilisateur"
    )
    @PutMapping("/{userId}/status")
    public Mono<ApiResponse<UserResponse>> updateUserStatus(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "Nouveau statut")
        @RequestParam Boolean isActive,
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID updatedBy) {

        log.info("PUT /users/{}/status - Updating status to: {}", userId, isActive);

        return userService.updateUserStatus(userId, isActive, updatedBy)
            .map(user -> ApiResponse.<UserResponse>builder()
                .success(true)
                .message(isActive ? "Utilisateur activé avec succès" : "Utilisateur désactivé avec succès")
                .data(user)
                .build())
            .doOnSuccess(response -> log.info("User status updated successfully: {}", userId))
            .doOnError(error -> log.error("Failed to update user status: {}", userId, error));
    }

    @Operation(
        summary = "Récupérer le personnel d'une organisation",
        description = "Retourne tous les membres du personnel d'une organisation"
    )
    @GetMapping("/organization/{organizationId}/personnel")
    public Mono<ApiResponse<java.util.List<UserResponse>>> getOrganizationPersonnel(
        @Parameter(description = "ID de l'organisation")
        @PathVariable UUID organizationId) {

        log.info("GET /users/organization/{}/personnel - Fetching personnel", organizationId);

        return userService.findPersonnelByOrganization(organizationId)
            .collectList()
            .map(personnel -> ApiResponse.<java.util.List<UserResponse>>builder()
                .success(true)
                .message("Personnel de l'organisation récupéré avec succès")
                .data(personnel)
                .count((long) personnel.size())
                .build())
            .doOnSuccess(response -> log.info("Retrieved {} personnel for organization: {}",
                response.getData().size(), organizationId));
    }

    @Operation(
        summary = "Récupérer le personnel d'une agence",
        description = "Retourne tous les membres du personnel d'une agence"
    )
    @GetMapping("/agency/{agencyId}/personnel")
    public Mono<ApiResponse<java.util.List<UserResponse>>> getAgencyPersonnel(
        @Parameter(description = "ID de l'agence")
        @PathVariable UUID agencyId) {

        log.info("GET /users/agency/{}/personnel - Fetching personnel", agencyId);

        return userService.findPersonnelByAgency(agencyId)
            .collectList()
            .map(personnel -> ApiResponse.<java.util.List<UserResponse>>builder()
                .success(true)
                .message("Personnel de l'agence récupéré avec succès")
                .data(personnel)
                .count((long) personnel.size())
                .build())
            .doOnSuccess(response -> log.info("Retrieved {} personnel for agency: {}",
                response.getData().size(), agencyId));
    }

    @Operation(
        summary = "Récupérer les utilisateurs par type",
        description = "Retourne tous les utilisateurs d'un type spécifique"
    )
    @GetMapping("/type/{userType}")
    public Mono<ApiResponse<java.util.List<UserResponse>>> getUsersByType(
        @Parameter(description = "Type d'utilisateur")
        @PathVariable UserType userType,
        @Parameter(description = "ID de l'organisation (optionnel)")
        @RequestParam(required = false) UUID organizationId) {

        log.info("GET /users/type/{} - Fetching users by type for organization: {}", userType, organizationId);

        return userService.findByUserType(userType)
            .filter(user -> organizationId == null || organizationId.equals(user.getOrganizationId()))
            .collectList()
            .map(users -> ApiResponse.<java.util.List<UserResponse>>builder()
                .success(true)
                .message("Utilisateurs du type " + userType.getDisplayName() + " récupérés avec succès")
                .data(users)
                .count((long) users.size())
                .build())
            .doOnSuccess(response -> log.info("Retrieved {} users of type: {}",
                response.getData().size(), userType));
    }

    @Operation(
        summary = "Vérifier si un email existe",
        description = "Vérifie si une adresse email est déjà utilisée"
    )
    @GetMapping("/check-email")
    public Mono<ApiResponse<Boolean>> checkEmailExists(
        @Parameter(description = "Adresse email à vérifier")
        @RequestParam String email) {

        log.info("GET /users/check-email - Checking email: {}", email);

        return userService.existsByEmail(email)
            .map(exists -> ApiResponse.<Boolean>builder()
                .success(true)
                .message(exists ? "Email déjà utilisé" : "Email disponible")
                .data(exists)
                .build())
            .doOnSuccess(response -> log.info("Email {} exists: {}", email, response.getData()));
    }

    @Operation(
        summary = "Statistiques des utilisateurs",
        description = "Retourne les statistiques des utilisateurs d'une organisation"
    )
    @GetMapping("/organization/{organizationId}/stats")
    public Mono<ApiResponse<UserStatsResponse>> getUserStats(
        @Parameter(description = "ID de l'organisation")
        @PathVariable UUID organizationId) {

        log.info("GET /users/organization/{}/stats - Getting user statistics", organizationId);

        return userService.getUserStats(organizationId)
            .map(stats -> ApiResponse.<UserStatsResponse>builder()
                .success(true)
                .message("Statistiques des utilisateurs récupérées avec succès")
                .data(stats)
                .build())
            .doOnSuccess(response -> log.info("User statistics retrieved for organization: {}", organizationId));
    }

    @Operation(
        summary = "Rechercher des utilisateurs",
        description = "Recherche des utilisateurs par nom, email ou ID employé"
    )
    @GetMapping("/search")
    public Mono<ApiResponse<java.util.List<UserResponse>>> searchUsers(
        @Parameter(description = "Terme de recherche")
        @RequestParam String query,
        @Parameter(description = "ID de l'organisation (optionnel)")
        @RequestParam(required = false) UUID organizationId,
        @Parameter(description = "Type d'utilisateur (optionnel)")
        @RequestParam(required = false) UserType userType) {

        log.info("GET /users/search - Searching users with query: {} for organization: {}", query, organizationId);

        return userService.findAll()
            .filter(user -> organizationId == null || organizationId.equals(user.getOrganizationId()))
            .filter(user -> userType == null || userType.equals(user.getUserType()))
            .filter(user -> matchesSearchQuery(user, query))
            .collectList()
            .map(users -> ApiResponse.<java.util.List<UserResponse>>builder()
                .success(true)
                .message("Recherche terminée avec succès")
                .data(users)
                .count((long) users.size())
                .build())
            .doOnSuccess(response -> log.info("Search completed, found {} users", response.getData().size()));
    }

    @Operation(
        summary = "Supprimer un utilisateur",
        description = "Supprime définitivement un utilisateur (action irréversible)"
    )
    @DeleteMapping("/{userId}")
    public Mono<ApiResponse<String>> deleteUser(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "ID de l'utilisateur connecté")
        @RequestHeader("X-User-Id") UUID deletedBy) {

        log.info("DELETE /users/{} - Deleting user", userId);

        return userService.deleteById(userId)
            .then(Mono.just(ApiResponse.<String>builder()
                .success(true)
                .message("Utilisateur supprimé avec succès")
                .data("User deleted")
                .build()))
            .doOnSuccess(response -> log.info("User deleted successfully: {}", userId))
            .doOnError(error -> log.error("Failed to delete user: {}", userId, error));
    }

    /**
     * Vérifie si un utilisateur correspond à la requête de recherche
     */
    private boolean matchesSearchQuery(UserResponse user, String query) {
        if (query == null || query.trim().isEmpty()) {
            return true;
        }

        String lowerQuery = query.toLowerCase().trim();

        return (user.getFirstName() != null && user.getFirstName().toLowerCase().contains(lowerQuery)) ||
            (user.getLastName() != null && user.getLastName().toLowerCase().contains(lowerQuery)) ||
            (user.getFullName() != null && user.getFullName().toLowerCase().contains(lowerQuery)) ||
            (user.getEmail() != null && user.getEmail().toLowerCase().contains(lowerQuery)) ||
            (user.getEmployeeId() != null && user.getEmployeeId().toLowerCase().contains(lowerQuery)) ||
            (user.getDepartment() != null && user.getDepartment().toLowerCase().contains(lowerQuery)) ||
            (user.getPosition() != null && user.getPosition().toLowerCase().contains(lowerQuery));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\UserRoleReactiveController.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.UserRoleReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import jakarta.validation.Valid;
import java.time.LocalDateTime;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/user-roles")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "User Role Assignment", description = "APIs d'assignation des rôles aux utilisateurs")
public class UserRoleReactiveController {

    private final UserRoleReactiveService userRoleService;

    @PostMapping(produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseStatus(HttpStatus.CREATED)
    @Operation(summary = "Assigner un rôle", description = "Assigne un rôle à un utilisateur")
    @PreAuthorize("hasPermission('USER', 'MANAGE_ROLES')")
    public Mono<ApiResponse<UserRoleResponse>> assignRole(
        @Valid @RequestBody AssignRoleRequest request,
        @Parameter(description = "ID de l'utilisateur assignant le rôle")
        @RequestHeader("X-User-Id") UUID assignedBy) {

        log.info("POST /api/v1/user-roles - Assigning role {} to user {}",
            request.getRoleId(), request.getUserId());

        return userRoleService.assignRole(request, assignedBy)
            .map(userRole -> ApiResponse.<UserRoleResponse>builder()
                .success(true)
                .message("Rôle assigné avec succès")
                .data(userRole)
                .build())
            .doOnSuccess(response -> log.info("Role assigned: {}", response.getData().getId()))
            .doOnError(error -> log.error("Failed to assign role", error));
    }

    @DeleteMapping("/{userId}/roles/{roleId}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @Operation(summary = "Révoquer un rôle", description = "Révoque un rôle spécifique d'un utilisateur")
    @PreAuthorize("hasPermission('USER', 'MANAGE_ROLES')")
    public Mono<ApiResponse<Void>> revokeRole(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId,
        @Parameter(description = "ID de l'utilisateur révoquant le rôle")
        @RequestHeader("X-User-Id") UUID revokedBy) {

        log.info("DELETE /api/v1/user-roles/{}/roles/{} - Revoking role", userId, roleId);

        return userRoleService.revokeRole(userId, roleId, revokedBy)
            .then(Mono.just(ApiResponse.<Void>builder()
                .success(true)
                .message("Rôle révoqué avec succès")
                .build()))
            .doOnSuccess(response -> log.info("Role revoked for user: {}", userId))
            .doOnError(error -> log.error("Failed to revoke role", error));
    }

    @GetMapping(value = "/{userId}/roles", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir les rôles d'un utilisateur", description = "Récupère tous les rôles actifs d'un utilisateur")
    @PreAuthorize("hasPermission('USER', 'READ')")
    public Mono<ApiResponse<Flux<UserRoleResponse>>> getUserRoles(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId) {

        log.info("GET /api/v1/user-roles/{}/roles - Getting user roles", userId);

        Flux<UserRoleResponse> userRoles = userRoleService.getUserRoles(userId);

        return Mono.just(ApiResponse.<Flux<UserRoleResponse>>builder()
            .success(true)
            .message("Rôles utilisateur récupérés avec succès")
            .data(userRoles)
            .build());
    }

    @GetMapping(value = "/roles/{roleId}/users", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Obtenir les utilisateurs par rôle", description = "Récupère tous les utilisateurs ayant un rôle spécifique")
    @PreAuthorize("hasPermission('ROLE', 'READ')")
    public Mono<ApiResponse<Flux<UserRoleResponse>>> getUsersByRole(
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId) {

        log.info("GET /api/v1/user-roles/roles/{}/users - Getting users by role", roleId);

        Flux<UserRoleResponse> userRoles = userRoleService.getUsersByRole(roleId);

        return Mono.just(ApiResponse.<Flux<UserRoleResponse>>builder()
            .success(true)
            .message("Utilisateurs avec le rôle récupérés avec succès")
            .data(userRoles)
            .build());
    }

    @DeleteMapping("/{userId}/roles")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @Operation(summary = "Révoquer tous les rôles", description = "Révoque tous les rôles d'un utilisateur")
    @PreAuthorize("hasPermission('USER', 'MANAGE_ROLES')")
    public Mono<ApiResponse<Void>> revokeAllUserRoles(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "ID de l'utilisateur révoquant les rôles")
        @RequestHeader("X-User-Id") UUID revokedBy) {

        log.info("DELETE /api/v1/user-roles/{}/roles - Revoking all roles", userId);

        return userRoleService.revokeAllUserRoles(userId, revokedBy)
            .then(Mono.just(ApiResponse.<Void>builder()
                .success(true)
                .message("Tous les rôles révoqués avec succès")
                .build()))
            .doOnSuccess(response -> log.info("All roles revoked for user: {}", userId));
    }

    @PutMapping(value = "/{userId}/roles/{roleId}/activate", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Activer un rôle", description = "Active un rôle temporairement désactivé")
    @PreAuthorize("hasPermission('USER', 'MANAGE_ROLES')")
    public Mono<ApiResponse<UserRoleResponse>> activateRole(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId) {

        log.info("PUT /api/v1/user-roles/{}/roles/{}/activate - Activating role", userId, roleId);

        return userRoleService.activateRole(userId, roleId)
            .map(userRole -> ApiResponse.<UserRoleResponse>builder()
                .success(true)
                .message("Rôle activé avec succès")
                .data(userRole)
                .build());
    }

    @PutMapping(value = "/{userId}/roles/{roleId}/extend", produces = MediaType.APPLICATION_JSON_VALUE)
    @Operation(summary = "Étendre l'expiration", description = "Étend la date d'expiration d'un rôle")
    @PreAuthorize("hasPermission('USER', 'MANAGE_ROLES')")
    public Mono<ApiResponse<UserRoleResponse>> extendRoleExpiration(
        @Parameter(description = "ID de l'utilisateur")
        @PathVariable UUID userId,
        @Parameter(description = "ID du rôle")
        @PathVariable UUID roleId,
        @Valid @RequestBody ExtendRoleExpirationRequest request) {

        log.info("PUT /api/v1/user-roles/{}/roles/{}/extend - Extending role expiration", userId, roleId);

        return userRoleService.extendRoleExpiration(userId, roleId, request.getNewExpirationDate())
            .map(userRole -> ApiResponse.<UserRoleResponse>builder()
                .success(true)
                .message("Expiration du rôle étendue avec succès")
                .data(userRole)
                .build());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AgencyBusinessSettings.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.*;
import lombok.*;

/**
 * Paramètres business d'une agence
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AgencyBusinessSettings {

    @JsonProperty("allow_online_booking")
    private Boolean allowOnlineBooking = true;

    @JsonProperty("require_deposit")
    private Boolean requireDeposit = true;

    @JsonProperty("deposit_percentage")
    @DecimalMin(value = "0.0", message = "Deposit percentage must be positive")
    @DecimalMax(value = "100.0", message = "Deposit percentage cannot exceed 100%")
    private Double depositPercentage = 30.0;

    @JsonProperty("min_rental_hours")
    @Min(value = 1, message = "Minimum rental hours must be at least 1")
    private Integer minRentalHours = 1;

    @JsonProperty("max_advance_booking_days")
    @Min(value = 1, message = "Maximum advance booking days must be at least 1")
    private Integer maxAdvanceBookingDays = 30;

    @JsonProperty("auto_confirm_booking")
    private Boolean autoConfirmBooking = false;

    @JsonProperty("require_driver_license")
    private Boolean requireDriverLicense = true;

    @JsonProperty("min_age_requirement")
    @Min(value = 18, message = "Minimum age must be at least 18")
    private Integer minAgeRequirement = 21;

    @JsonProperty("allow_international_license")
    private Boolean allowInternationalLicense = true;

    @JsonProperty("require_credit_card")
    private Boolean requireCreditCard = false;

    @JsonProperty("cancellation_deadline_hours")
    @Min(value = 1, message = "Cancellation deadline must be at least 1 hour")
    private Integer cancellationDeadlineHours = 24;

    @JsonProperty("late_return_penalty_rate")
    @DecimalMin(value = "0.0", message = "Penalty rate must be positive")
    private Double lateReturnPenaltyRate = 0.1; // 10% par heure de retard
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AgencyCountResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.util.UUID;

/**
 * DTO pour le comptage des agences
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AgencyCountResponse {

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("total_agencies")
    private Integer totalAgencies;

    @JsonProperty("active_agencies")
    private Integer activeAgencies;

    @JsonProperty("inactive_agencies")
    private Integer inactiveAgencies;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AgencyRedirectInfo.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.Data;

import java.util.UUID;

@Data
public class AgencyRedirectInfo {
    @JsonProperty("personnelId")
    private UUID personnelId;

    @JsonProperty("organizationId")
    private UUID organizationId;

    @JsonProperty("agencyId")
    private UUID agencyId;

    @JsonProperty("userType")
    private UserType userType;

    @JsonProperty("employeeId")
    private String employeeId;

    @JsonProperty("department")
    private String department;

    @JsonProperty("position")
    private String position;

    @JsonProperty("requiresPasswordChange")
    private Boolean requiresPasswordChange;

    @JsonProperty("redirectUrl")
    private String redirectUrl; // URL de redirection vers l'agence

    @JsonProperty("agencyName")
    private String agencyName; // Nom de l'agence (à récupérer)

    @JsonProperty("permissions")
    private java.util.List<String> permissions; // Permissions spécifiques au rôle
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AgencyResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

/**
 * DTO de réponse pour une agence
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AgencyResponse {

    @JsonProperty("id")
    private UUID id;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("name")
    private String name;

    @JsonProperty("description")
    private String description;

    @JsonProperty("address")
    private String address;

    @JsonProperty("city")
    private String city;

    @JsonProperty("country")
    private String country;

    @JsonProperty("postal_code")
    private String postalCode;

    @JsonProperty("region")
    private String region;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("email")
    private String email;

    @JsonProperty("latitude")
    private Double latitude;

    @JsonProperty("longitude")
    private Double longitude;

    @JsonProperty("full_address")
    private String fullAddress;

    @JsonProperty("geofence_zone_id")
    private String geofenceZoneId;

    @JsonProperty("geofence_radius")
    private Double geofenceRadius;

    @JsonProperty("has_location")
    private Boolean hasLocation;

    @JsonProperty("has_geofencing")
    private Boolean hasGeofencing;

    @JsonProperty("manager_id")
    private UUID managerId;

    @JsonProperty("is_24_hours")
    private Boolean is24Hours;

    @JsonProperty("is_currently_open")
    private Boolean isCurrentlyOpen;

    @JsonProperty("timezone")
    private String timezone;

    @JsonProperty("currency")
    private String currency;

    @JsonProperty("language")
    private String language;

    @JsonProperty("working_hours")
    private Map<String, WorkingHoursInfo> workingHours;

    @JsonProperty("allow_online_booking")
    private Boolean allowOnlineBooking;

    @JsonProperty("require_deposit")
    private Boolean requireDeposit;

    @JsonProperty("deposit_percentage")
    private Double depositPercentage;

    @JsonProperty("min_rental_hours")
    private Integer minRentalHours;

    @JsonProperty("max_advance_booking_days")
    private Integer maxAdvanceBookingDays;

    @JsonProperty("total_vehicles")
    private Integer totalVehicles;

    @JsonProperty("active_vehicles")
    private Integer activeVehicles;

    @JsonProperty("total_drivers")
    private Integer totalDrivers;

    @JsonProperty("active_drivers")
    private Integer activeDrivers;

    @JsonProperty("total_personnel")
    private Integer totalPersonnel;

    @JsonProperty("total_rentals")
    private Integer totalRentals;

    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue;

    @JsonProperty("vehicle_utilization_rate")
    private Double vehicleUtilizationRate;

    @JsonProperty("driver_activity_rate")
    private Double driverActivityRate;

    @JsonProperty("logo_url")
    private String logoUrl;

    @JsonProperty("primary_color")
    private String primaryColor;

    @JsonProperty("secondary_color")
    private String secondaryColor;

    @JsonProperty("is_active")
    private Boolean isActive;

    @JsonProperty("created_at")
    private LocalDateTime createdAt;

    @JsonProperty("updated_at")
    private LocalDateTime updatedAt;

    @JsonProperty("created_by")
    private UUID createdBy;

    @JsonProperty("updated_by")
    private UUID updatedBy;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AgencyStatisticsRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * DTO pour la mise à jour des statistiques d'agence
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AgencyStatisticsRequest {

    @JsonProperty("vehicle_stats")
    private VehicleStatistics vehicleStats;

    @JsonProperty("driver_stats")
    private DriverStatistics driverStats;

    @JsonProperty("personnel_count")
    private Integer personnelCount;

    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue;

    @JsonProperty("total_rentals_increment")
    private Integer totalRentalsIncrement;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class VehicleStatistics {
        @JsonProperty("total")
        private Integer total;

        @JsonProperty("active")
        private Integer active;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class DriverStatistics {
        @JsonProperty("total")
        private Integer total;

        @JsonProperty("active")
        private Integer active;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AgencyStatisticsResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse pour les statistiques d'agence
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AgencyStatisticsResponse {

    @JsonProperty("agency_id")
    private UUID agencyId;

    @JsonProperty("total_vehicles")
    private Integer totalVehicles;

    @JsonProperty("active_vehicles")
    private Integer activeVehicles;

    @JsonProperty("total_drivers")
    private Integer totalDrivers;

    @JsonProperty("active_drivers")
    private Integer activeDrivers;

    @JsonProperty("total_personnel")
    private Integer totalPersonnel;

    @JsonProperty("total_rentals")
    private Integer totalRentals;

    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue;

    @JsonProperty("vehicle_utilization_rate")
    private Double vehicleUtilizationRate;

    @JsonProperty("driver_activity_rate")
    private Double driverActivityRate;

    @JsonProperty("last_updated")
    private LocalDateTime lastUpdated;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\ApiResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * DTO de réponse API standard
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ApiResponse<T> {

    @JsonProperty("success")
    private Boolean success;

    @JsonProperty("message")
    private String message;

    @JsonProperty("data")
    private T data;

    @JsonProperty("timestamp")
    @Builder.Default
    private LocalDateTime timestamp = LocalDateTime.now();

    @JsonProperty("count")
    private Long count;

    @JsonProperty("total")
    private Long total;

    @JsonProperty("page")
    private Integer page;

    @JsonProperty("size")
    private Integer size;

    public static <T> ApiResponse<T> success(T data, String message) {
        return ApiResponse.<T>builder()
            .success(true)
            .message(message)
            .data(data)
            .build();
    }

    public static <T> ApiResponse<T> error(String message) {
        return ApiResponse.<T>builder()
            .success(false)
            .message(message)
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AssignRoleRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AssignRoleRequest {

    @NotNull(message = "User ID is required")
    @JsonProperty("user_id")
    private UUID userId;

    @NotNull(message = "Role ID is required")
    @JsonProperty("role_id")
    private UUID roleId;

    @NotNull(message = "Organization ID is required")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("agency_id")
    private UUID agencyId;

    @JsonProperty("expires_at")
    private LocalDateTime expiresAt;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\AuthResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Builder;
import lombok.Data;

/**
 * Réponse d'authentification (Mise à jour avec support personnel)
 */
@Data
@Builder
public class AuthResponse {
    @JsonProperty("accessToken")
    private String accessToken;

    @JsonProperty("refreshToken")
    private String refreshToken;

    @JsonProperty("tokenType")
    private String tokenType;

    @JsonProperty("expiresIn")
    private long expiresIn;

    @JsonProperty("user")
    private UserResponse user;

    // NOUVEAUX CHAMPS pour la gestion du personnel
    @JsonProperty("isPersonnel")
    private Boolean isPersonnel;

    @JsonProperty("agencyRedirectInfo")
    private AgencyRedirectInfo agencyRedirectInfo;

    @JsonProperty("requiresPasswordChange")
    private Boolean requiresPasswordChange;

    @JsonProperty("loginMessage")
    private String loginMessage;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\ChangePasswordRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class ChangePasswordRequest {
    @JsonProperty("currentPassword")
    @NotBlank(message = "Current password is required")
    private String currentPassword;

    @JsonProperty("newPassword")
    @NotBlank(message = "New password is required")
    @Size(min = 8, message = "New password must be at least 8 characters")
    private String newPassword;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\CheckMultiplePermissionsRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotEmpty;
import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CheckMultiplePermissionsRequest {

    @NotEmpty(message = "At least one permission is required")
    @JsonProperty("permissions")
    private Set<String> permissions;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\CloneRoleRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CloneRoleRequest {

    @NotBlank(message = "New role name is required")
    @Size(min = 2, max = 100, message = "Role name must be between 2 and 100 characters")
    @JsonProperty("new_name")
    private String newName;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\CreateAgencyRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.*;
import lombok.*;
import java.util.Map;
import java.util.UUID;

/**
 * DTO pour la création d'une agence
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CreateAgencyRequest {

    @NotNull(message = "Organization ID is required")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @NotBlank(message = "Agency name is required")
    @Size(min = 2, max = 100, message = "Agency name must be between 2 and 100 characters")
    @JsonProperty("name")
    private String name;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @JsonProperty("description")
    private String description;

    // === ADRESSE ===
    @NotBlank(message = "Address is required")
    @Size(max = 255, message = "Address must not exceed 255 characters")
    @JsonProperty("address")
    private String address;

    @NotBlank(message = "City is required")
    @Size(max = 100, message = "City must not exceed 100 characters")
    @JsonProperty("city")
    private String city;

    @Size(max = 100, message = "Country must not exceed 100 characters")
    @JsonProperty("country")
    private String country = "CM";

    @Size(max = 20, message = "Postal code must not exceed 20 characters")
    @JsonProperty("postal_code")
    private String postalCode;

    @Size(max = 100, message = "Region must not exceed 100 characters")
    @JsonProperty("region")
    private String region;

    // === CONTACT ===
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @JsonProperty("phone")
    private String phone;

    @Email(message = "Email should be valid")
    @JsonProperty("email")
    private String email;

    // === GÉOLOCALISATION ===
    @JsonProperty("latitude")
    private Double latitude;

    @JsonProperty("longitude")
    private Double longitude;

    @JsonProperty("geofence_zone_id")
    private String geofenceZoneId;

    @PositiveOrZero(message = "Geofence radius must be positive or zero")
    @JsonProperty("geofence_radius")
    private Double geofenceRadius;

    // === GESTIONNAIRE ===
    @JsonProperty("manager_id")
    private UUID managerId;

    // === CONFIGURATION ===
    @JsonProperty("is_24_hours")
    private Boolean is24Hours = false;

    @JsonProperty("timezone")
    private String timezone = "Africa/Douala";

    @JsonProperty("currency")
    private String currency = "XAF";

    @JsonProperty("language")
    private String language = "fr";

    // === HORAIRES DE TRAVAIL ===
    @JsonProperty("working_hours")
    private Map<String, WorkingHoursInfo> workingHours;

    // === PARAMÈTRES BUSINESS ===
    @JsonProperty("business_settings")
    private AgencyBusinessSettings businessSettings;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\CreateDriverRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

import inc.yowyob.rental_api_reactive.application.dto.Money;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import inc.yowyob.rental_api_reactive.application.dto.WorkingHours;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.time.LocalDate;
import java.util.UUID;

@Data
public class CreateDriverRequest {

    @NotNull(message = "User ID is required")
    @JsonProperty("user_id")
    private UUID userId;

    @NotNull(message = "Organization ID is required")
    @JsonProperty("organization_id")
    private UUID organizationId;

     @NotNull(message = "L'ID de l'agence est requis.")
    @JsonProperty("agency_id")
    private UUID agencyId;

    @JsonProperty("date_of_birth")
    @NotNull(message = "La date de naissance est requise.")
    private LocalDate dateOfBirth;

    @JsonProperty("license_number")
    @NotBlank(message = "Le numéro de permis est requis.")
    private String licenseNumber;

    @JsonProperty("license_type")
    @NotBlank(message = "Le type de permis est requis.")
    private String licenseType;

    @JsonProperty("licenseExpiry")
    @NotNull @Future private LocalDate licenseExpiry;
    
    @JsonProperty("experience")
    @NotNull @Min(0) private Integer experience;

    @JsonProperty("idCardUrl")
    private String idCardUrl;            // URL or identifier of ID card
    
    @JsonProperty("driverLicenceUrl")
    private String driverLicenseUrl;     // URL or identifier of license

     // Staff info

    @NotNull
    @JsonProperty("userType")
    private UserType userType = UserType.DRIVER;

    @JsonProperty("employeeId")
    @NotBlank private String employeeId;

    @JsonProperty("cni")
    private String cni;

    @JsonProperty("position")
    @NotBlank private String position;

    @JsonProperty("department")
    private String department;

    @JsonProperty("staffStatus")
    @NotNull private String staffStatus;

    @JsonProperty("hourlyRate")
    private Money hourlyRate;

    @JsonProperty("workingHours")
    private WorkingHours workingHours;

    @JsonProperty("hireDate")
    @NotNull private LocalDate hireDate;

    public int getAge() {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getAge'");
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\CreateOrganizationRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.OrganizationType;
import jakarta.validation.constraints.*;
import lombok.*;
import java.util.UUID;

/**
 * DTO pour la création d'une organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CreateOrganizationRequest {

    @NotBlank(message = "Organization name is required")
    @Size(min = 2, max = 100, message = "Organization name must be between 2 and 100 characters")
    @JsonProperty("name")
    private String name;

    @NotNull(message = "Organization type is required")
    @JsonProperty("organization_type")
    private OrganizationType organizationType;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @JsonProperty("description")
    private String description;

    @NotNull(message = "Owner ID is required")
    @JsonProperty("owner_id")
    private UUID ownerId;

    // === INFORMATIONS LÉGALES ===
    @JsonProperty("registration_number")
    private String registrationNumber;

    @JsonProperty("tax_number")
    private String taxNumber;

    @JsonProperty("business_license")
    private String businessLicense;

    // === ADRESSE ===
    @NotBlank(message = "Address is required")
    @JsonProperty("address")
    private String address;

    @NotBlank(message = "City is required")
    @JsonProperty("city")
    private String city;

    @JsonProperty("country")
    private String country = "CM";

    @JsonProperty("postal_code")
    private String postalCode;

    @JsonProperty("region")
    private String region;

    // === CONTACT ===
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @JsonProperty("phone")
    private String phone;

    @Email(message = "Email should be valid")
    @JsonProperty("email")
    private String email;

    @JsonProperty("website")
    private String website;

    // === CONFIGURATION ===
    @JsonProperty("currency")
    private String currency = "XAF";

    @JsonProperty("timezone")
    private String timezone = "Africa/Douala";

    @JsonProperty("language")
    private String language = "fr";

    // === BRANDING ===
    @JsonProperty("primary_color")
    private String primaryColor = "#3b82f6";

    @JsonProperty("secondary_color")
    private String secondaryColor = "#1e40af";

    // === POLITIQUES ET PARAMÈTRES ===
    @JsonProperty("policies")
    private OrganizationPolicies policies;

    @JsonProperty("settings")
    private OrganizationSettings settings;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\CreatePersonnelRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import jakarta.validation.constraints.*;
import lombok.Data;

import java.util.UUID;

@Data
public class CreatePersonnelRequest {
    @JsonProperty("email")
    @NotBlank(message = "Email est requis")
    @Email(message = "Format email invalide")
    private String email;

    @JsonProperty("firstName")
    @NotBlank(message = "Prénom est requis")
    @Size(min = 2, max = 50, message = "Prénom doit être entre 2 et 50 caractères")
    private String firstName;

    @JsonProperty("lastName")
    @NotBlank(message = "Nom est requis")
    @Size(min = 2, max = 50, message = "Nom doit être entre 2 et 50 caractères")
    private String lastName;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("userType")
    @NotNull(message = "Type d'utilisateur est requis")
    private UserType userType; // AGENCY_MANAGER, RENTAL_AGENT, DRIVER

    @JsonProperty("organizationId")
    @NotNull(message = "ID organisation est requis")
    private UUID organizationId;

    @JsonProperty("agencyId")
    private UUID agencyId; // Optionnel, peut être assigné plus tard

    @JsonProperty("temporaryPassword")
    @NotBlank(message = "Mot de passe temporaire est requis")
    @Size(min = 8, message = "Mot de passe doit faire au moins 8 caractères")
    private String temporaryPassword;

    // Informations employé
    @JsonProperty("employeeId")
    private String employeeId; // ID employé interne à l'organisation

    @JsonProperty("department")
    private String department; // Service/Département

    @JsonProperty("position")
    private String position; // Poste/Fonction

    @JsonProperty("supervisorId")
    private UUID supervisorId; // Superviseur direct
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\CreateRoleRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.RoleType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.util.Set;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class CreateRoleRequest {

    @NotBlank(message = "Role name is required")
    @Size(min = 2, max = 100, message = "Role name must be between 2 and 100 characters")
    @JsonProperty("name")
    private String name;

    @Size(max = 255, message = "Description must not exceed 255 characters")
    @JsonProperty("description")
    private String description;

    @NotNull(message = "Organization ID is required")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("role_type")
    private RoleType roleType;

    @Min(value = 0, message = "Priority must be positive")
    @Max(value = 100, message = "Priority must not exceed 100")
    @JsonProperty("priority")
    private Integer priority;

    @JsonProperty("permissions")
    private Set<String> permissions;

    @Pattern(regexp = "^#[0-9A-Fa-f]{6}$", message = "Color must be a valid hex color")
    @JsonProperty("color")
    private String color;

    @Size(max = 50, message = "Icon name must not exceed 50 characters")
    @JsonProperty("icon")
    private String icon;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\DeactivateAccountRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class DeactivateAccountRequest {
    @JsonProperty("reason")
    @NotBlank(message = "Reason for deactivation is required")
    private String reason;

    @JsonProperty("feedback")
    private String feedback;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\DriverResponse.java ---

```java
// PATH: src/main/java/inc/yowyob/rental_api_reactive/infrastructure/web/dto/DriverResponse.java

package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
// import inc.yowyob.rental_api_reactive.application.dto.DriverStatus;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Period;
import java.util.List;
import java.util.UUID;

/**
 * DTO de réponse complet représentant un chauffeur.
 * Il combine les informations personnelles de l'entité User avec les informations 
 * professionnelles de l'entité Driver pour fournir une vue unifiée et pratique à l'API.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class DriverResponse {

    // --- IDENTIFIANTS CLÉS ---
    @JsonProperty("driver_id")
    private UUID driverId;

    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("agency_id")
    private UUID agencyId;

    // --- INFORMATIONS PERSONNELLES (de l'entité User) ---
    @JsonProperty("first_name")
    private String firstName;

    @JsonProperty("last_name")
    private String lastName;

    @JsonProperty("full_name")
    private String fullName;

    @JsonProperty("email")
    private String email;

    @JsonProperty("phone")
    private String phone;
    
    @JsonProperty("profile_image_url")
    private String profileImageUrl;

    @JsonProperty("user_type")
    private UserType userType;


    // --- INFORMATIONS PROFESSIONNELLES (de l'entité Driver) ---
    @JsonProperty("date_of_birth")
    private LocalDate dateOfBirth;

    @JsonProperty("license_number")
    private String licenseNumber;

    @JsonProperty("license_type")
    private String licenseType;

    @JsonProperty("license_expiry_date")
    private LocalDate licenseExpiryDate;

    @JsonProperty("experience_years")
    private Integer experienceYears;

    @JsonProperty("rating")
    private Double rating;
    
    // @JsonProperty("status")
    // private DriverStatus status;

    // @JsonProperty("is_available")
    // private Boolean isAvailable;


    // --- INFORMATIONS D'EMPLOYÉ (de l'entité Driver) ---
    @JsonProperty("employee_id")
    private String employeeId; // Matricule

    @JsonProperty("position")
    private String position;

    @JsonProperty("hire_date")
    private LocalDate hireDate;
    
    @JsonProperty("staff_status")
    private String staffStatus;

    


    // --- CHAMPS CALCULÉS (pour la commodité du frontend) ---
    /**
     * Calcule l'âge actuel du chauffeur. Non stocké en base.
     */
    @JsonProperty("age")
    public Integer getAge() {
        if (this.dateOfBirth == null) {
            return null;
        }
        return Period.between(this.dateOfBirth, LocalDate.now()).getYears();
    }

    /**
     * Calcule le nombre d'années de service. Non stocké en base.
     */
    @JsonProperty("years_of_service")
    public Integer getYearsOfService() {
        if (this.hireDate == null) {
            return null;
        }
        return Period.between(this.hireDate, LocalDate.now()).getYears();
    }
    
    /**
     * Vérifie si le permis de conduire a expiré. Non stocké en base.
     */
    @JsonProperty("is_license_expired")
    public Boolean getIsLicenseExpired() {
        if (this.licenseExpiryDate == null) {
            return null; // ou false si une licence sans date d'expiration est considérée comme valide
        }
        return LocalDate.now().isAfter(this.licenseExpiryDate);
    }
    

    // --- AUDIT ---
    @JsonProperty("created_at")
    private LocalDateTime createdAt;

    @JsonProperty("updated_at")
    private LocalDateTime updatedAt;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\EmployeeInfoResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
public class EmployeeInfoResponse {
    @JsonProperty("employeeId")
    private String employeeId;

    @JsonProperty("department")
    private String department;

    @JsonProperty("position")
    private String position;

    @JsonProperty("supervisorId")
    private UUID supervisorId;

    @JsonProperty("hiredAt")
    private LocalDateTime hiredAt;

    @JsonProperty("mustChangePassword")
    private Boolean mustChangePassword;

    @JsonProperty("organizationId")
    private UUID organizationId;

    @JsonProperty("agencyId")
    private UUID agencyId;

    @JsonProperty("isAssignedToAgency")
    public Boolean getIsAssignedToAgency() {
        return agencyId != null;
    }

    @JsonProperty("yearsOfService")
    public Integer getYearsOfService() {
        if (hiredAt == null) return null;
        return (int) java.time.temporal.ChronoUnit.YEARS.between(hiredAt.toLocalDate(), java.time.LocalDate.now());
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\ExtendRoleExpirationRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExtendRoleExpirationRequest {

    @NotNull(message = "New expiration date is required")
    @Future(message = "Expiration date must be in the future")
    @JsonProperty("new_expiration_date")
    private LocalDateTime newExpirationDate;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\ForgotPasswordRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class ForgotPasswordRequest {
    @JsonProperty("email")
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\LoginRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class LoginRequest {
    @JsonProperty("email")
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;

    @JsonProperty("password")
    @NotBlank(message = "Password is required")
    private String password;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\MultiplePermissionCheckResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MultiplePermissionCheckResponse {

    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("permissions")
    private Set<String> permissions;

    @JsonProperty("has_all_permissions")
    private Boolean hasAllPermissions;

    @JsonProperty("has_any_permissions")
    private Boolean hasAnyPermissions;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\NotificationSettingsRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class NotificationSettingsRequest {
    @JsonProperty("emailNotifications")
    private Boolean emailNotifications;

    @JsonProperty("smsNotifications")
    private Boolean smsNotifications;

    @JsonProperty("pushNotifications")
    private Boolean pushNotifications;

    @JsonProperty("marketingEmails")
    private Boolean marketingEmails;

    @JsonProperty("securityAlerts")
    private Boolean securityAlerts;

    @JsonProperty("systemUpdates")
    private Boolean systemUpdates;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OnboardingCompletedResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse pour la finalisation d'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingCompletedResponse {

    @JsonProperty("session_id")
    private UUID sessionId;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("message")
    private String message;

    @JsonProperty("completed_at")
    private LocalDateTime completedAt;

    @JsonProperty("access_token")
    private String accessToken;

    @JsonProperty("refresh_token")
    private String refreshToken;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OnboardingCompletionResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * Réponse de finalisation d'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingCompletionResponse {
    @JsonProperty("success")
    private Boolean success;

    @JsonProperty("message")
    private String message;

    @JsonProperty("user")
    private UserResponse user;

    @JsonProperty("organization")
    private OrganizationResponse organization;

    @JsonProperty("subscription")
    private SubscriptionResponse subscription;

    @JsonProperty("next_steps")
    private String nextSteps;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OnboardingOrganizationRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * Requête d'informations organisation pour l'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingOrganizationRequest {
    @JsonProperty("name")
    private String name;

    @JsonProperty("organization_type")
    private inc.yowyob.rental_api_reactive.application.dto.OrganizationType organizationType;

    @JsonProperty("description")
    private String description;

    @JsonProperty("address")
    private String address;

    @JsonProperty("city")
    private String city;

    @JsonProperty("country")
    private String country;

    @JsonProperty("postal_code")
    private String postalCode;

    @JsonProperty("region")
    private String region;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("email")
    private String email;

    @JsonProperty("website")
    private String website;

    @JsonProperty("registration_number")
    private String registrationNumber;

    @JsonProperty("tax_number")
    private String taxNumber;

    @JsonProperty("business_license")
    private String businessLicense;

    @JsonProperty("currency")
    private String currency;

    @JsonProperty("timezone")
    private String timezone;

    @JsonProperty("language")
    private String language;

    @JsonProperty("primary_color")
    private String primaryColor;

    @JsonProperty("secondary_color")
    private String secondaryColor;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OnboardingOwnerRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * Requête d'informations propriétaire pour l'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingOwnerRequest {
    @JsonProperty("email")
    private String email;

    @JsonProperty("password")
    private String password;

    @JsonProperty("first_name")
    private String firstName;

    @JsonProperty("last_name")
    private String lastName;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("address")
    private String address;

    @JsonProperty("city")
    private String city;

    @JsonProperty("country")
    private String country;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OnboardingResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.time.LocalDateTime;

/**
 * Réponse d'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingResponse {
    @JsonProperty("session_token")
    private String sessionToken;

    @JsonProperty("current_step")
    private Integer currentStep;

    @JsonProperty("max_step")
    private Integer maxStep;

    @JsonProperty("is_completed")
    private Boolean isCompleted;

    @JsonProperty("expires_at")
    private LocalDateTime expiresAt;

    @JsonProperty("has_owner_info")
    private Boolean hasOwnerInfo;

    @JsonProperty("has_organization_info")
    private Boolean hasOrganizationInfo;

    @JsonProperty("has_subscription_info")
    private Boolean hasSubscriptionInfo;

    @JsonProperty("created_at")
    private LocalDateTime createdAt;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OnboardingSessionResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse pour les sessions d'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingSessionResponse {

    @JsonProperty("id")
    private UUID id;

    @JsonProperty("session_token")
    private String sessionToken;

    @JsonProperty("current_step")
    private Integer currentStep;

    @JsonProperty("max_step")
    private Integer maxStep;

    @JsonProperty("is_completed")
    private Boolean isCompleted;

    @JsonProperty("expires_at")
    private LocalDateTime expiresAt;

    @JsonProperty("owner_info_completed")
    private Boolean ownerInfoCompleted;

    @JsonProperty("organization_info_completed")
    private Boolean organizationInfoCompleted;

    @JsonProperty("subscription_info_completed")
    private Boolean subscriptionInfoCompleted;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("completed_at")
    private LocalDateTime completedAt;

    @JsonProperty("created_at")
    private LocalDateTime createdAt;

    @JsonProperty("updated_at")
    private LocalDateTime updatedAt;

    @JsonProperty("completion_percentage")
    public Double getCompletionPercentage() {
        int completed = 0;
        if (Boolean.TRUE.equals(ownerInfoCompleted)) completed++;
        if (Boolean.TRUE.equals(organizationInfoCompleted)) completed++;
        if (Boolean.TRUE.equals(subscriptionInfoCompleted)) completed++;

        return (double) completed / maxStep * 100.0;
    }

    @JsonProperty("is_expired")
    public Boolean getIsExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

    @JsonProperty("is_valid")
    public Boolean getIsValid() {
        return !getIsExpired() && !isCompleted;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OnboardingSubscriptionRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.PaymentMethod;
import lombok.*;
import java.util.UUID;

/**
 * Requête d'informations abonnement pour l'onboarding
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OnboardingSubscriptionRequest {
    @JsonProperty("subscription_plan_id")
    private UUID subscriptionPlanId;

    @JsonProperty("payment_method")
    private PaymentMethod paymentMethod;

    @JsonProperty("payment_reference")
    private String paymentReference;

    @JsonProperty("auto_renew")
    private Boolean autoRenew;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OrganizationDashboardResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.util.UUID;

/**
 * DTO pour le tableau de bord d'organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrganizationDashboardResponse {

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("total_agencies")
    private Integer totalAgencies;

    @JsonProperty("active_agencies")
    private Integer activeAgencies;

    @JsonProperty("total_vehicles")
    private Integer totalVehicles;

    @JsonProperty("total_drivers")
    private Integer totalDrivers;

    @JsonProperty("total_users")
    private Integer totalUsers;

    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue;

    @JsonProperty("total_rentals")
    private Integer totalRentals;

    @JsonProperty("agency_utilization")
    private Double agencyUtilization;

    @JsonProperty("vehicle_utilization")
    private Double vehicleUtilization;

    @JsonProperty("subscription_status")
    private String subscriptionStatus;

    @JsonProperty("alerts_count")
    private Integer alertsCount;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OrganizationInfoRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;

/**
 * DTO pour les informations de l'organisation (Étape 2)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OrganizationInfoRequest {

    @NotBlank(message = "Organization name is required")
    @Size(min = 2, max = 100, message = "Organization name must be between 2 and 100 characters")
    @JsonProperty("organization_name")
    private String organizationName;

    @NotBlank(message = "Organization type is required")
    @JsonProperty("organization_type")
    private String organizationType;

    @JsonProperty("registration_number")
    private String registrationNumber;

    @JsonProperty("tax_number")
    private String taxNumber;

    @NotBlank(message = "Address is required")
    @Size(max = 255, message = "Address must not exceed 255 characters")
    @JsonProperty("address")
    private String address;

    @NotBlank(message = "City is required")
    @Size(max = 100, message = "City must not exceed 100 characters")
    @JsonProperty("city")
    private String city;

    @NotBlank(message = "Country is required")
    @Size(max = 100, message = "Country must not exceed 100 characters")
    @JsonProperty("country")
    private String country;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @JsonProperty("description")
    private String description;

    // Politiques de l'organisation
    @JsonProperty("allows_driver_rental")
    private Boolean allowsDriverRental = true;

    @JsonProperty("allows_driverless_rental")
    private Boolean allowsDriverlessRental = true;

    @JsonProperty("require_deposit")
    private Boolean requireDeposit = true;

    @JsonProperty("default_deposit_amount")
    private Double defaultDepositAmount;

    @JsonProperty("cancellation_policy")
    private String cancellationPolicy;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OrganizationPolicies.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.time.LocalDateTime;

/**
 * Politiques d'organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrganizationPolicies {

    @JsonProperty("rental_policy")
    private RentalPolicy rentalPolicy;

    @JsonProperty("cancellation_policy")
    private CancellationPolicy cancellationPolicy;

    @JsonProperty("privacy_policy")
    private PrivacyPolicy privacyPolicy;

    @JsonProperty("terms_of_service")
    private TermsOfService termsOfService;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class RentalPolicy {
        @JsonProperty("min_rental_duration_hours")
        private Integer minRentalDurationHours = 1;

        @JsonProperty("max_rental_duration_days")
        private Integer maxRentalDurationDays = 30;

        @JsonProperty("require_deposit")
        private Boolean requireDeposit = true;

        @JsonProperty("default_deposit_percentage")
        private Double defaultDepositPercentage = 30.0;

        @JsonProperty("allow_one_way_rentals")
        private Boolean allowOneWayRentals = false;

        @JsonProperty("fuel_policy")
        private String fuelPolicy = "FULL_TO_FULL";
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class CancellationPolicy {
        @JsonProperty("free_cancellation_hours")
        private Integer freeCancellationHours = 24;

        @JsonProperty("cancellation_fee_percentage")
        private Double cancellationFeePercentage = 0.0;

        @JsonProperty("no_show_penalty_percentage")
        private Double noShowPenaltyPercentage = 100.0;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class PrivacyPolicy {
        @JsonProperty("data_retention_days")
        private Integer dataRetentionDays = 2555; // 7 ans

        @JsonProperty("allow_marketing_emails")
        private Boolean allowMarketingEmails = true;

        @JsonProperty("share_data_with_partners")
        private Boolean shareDataWithPartners = false;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class TermsOfService {
        @JsonProperty("version")
        private String version = "1.0";

        @JsonProperty("last_updated")
        private LocalDateTime lastUpdated;

        @JsonProperty("acceptance_required")
        private Boolean acceptanceRequired = true;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OrganizationResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.OrganizationType;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse pour une organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrganizationResponse {

    @JsonProperty("id")
    private UUID id;

    @JsonProperty("name")
    private String name;

    @JsonProperty("organization_type")
    private OrganizationType organizationType;

    @JsonProperty("description")
    private String description;

    @JsonProperty("owner_id")
    private UUID ownerId;

    @JsonProperty("registration_number")
    private String registrationNumber;

    @JsonProperty("tax_number")
    private String taxNumber;

    @JsonProperty("business_license")
    private String businessLicense;

    @JsonProperty("address")
    private String address;

    @JsonProperty("city")
    private String city;

    @JsonProperty("country")
    private String country;

    @JsonProperty("postal_code")
    private String postalCode;

    @JsonProperty("region")
    private String region;

    @JsonProperty("full_address")
    private String fullAddress;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("email")
    private String email;

    @JsonProperty("website")
    private String website;

    @JsonProperty("is_verified")
    private Boolean isVerified;

    @JsonProperty("verification_date")
    private LocalDateTime verificationDate;

    @JsonProperty("verified_by")
    private UUID verifiedBy;

    @JsonProperty("max_agencies")
    private Integer maxAgencies;

    @JsonProperty("max_vehicles")
    private Integer maxVehicles;

    @JsonProperty("max_drivers")
    private Integer maxDrivers;

    @JsonProperty("max_users")
    private Integer maxUsers;

    @JsonProperty("current_agencies")
    private Integer currentAgencies;

    @JsonProperty("current_vehicles")
    private Integer currentVehicles;

    @JsonProperty("current_drivers")
    private Integer currentDrivers;

    @JsonProperty("current_users")
    private Integer currentUsers;

    @JsonProperty("can_create_agency")
    private Boolean canCreateAgency;

    @JsonProperty("can_add_vehicle")
    private Boolean canAddVehicle;

    @JsonProperty("can_add_driver")
    private Boolean canAddDriver;

    @JsonProperty("can_add_user")
    private Boolean canAddUser;

    @JsonProperty("agency_usage_percentage")
    private Double agencyUsagePercentage;

    @JsonProperty("vehicle_usage_percentage")
    private Double vehicleUsagePercentage;

    @JsonProperty("driver_usage_percentage")
    private Double driverUsagePercentage;

    @JsonProperty("user_usage_percentage")
    private Double userUsagePercentage;

    @JsonProperty("currency")
    private String currency;

    @JsonProperty("timezone")
    private String timezone;

    @JsonProperty("language")
    private String language;

    @JsonProperty("logo_url")
    private String logoUrl;

    @JsonProperty("primary_color")
    private String primaryColor;

    @JsonProperty("secondary_color")
    private String secondaryColor;

    @JsonProperty("subscription_plan_id")
    private UUID subscriptionPlanId;

    @JsonProperty("subscription_expires_at")
    private LocalDateTime subscriptionExpiresAt;

    @JsonProperty("subscription_auto_renew")
    private Boolean subscriptionAutoRenew;

    @JsonProperty("is_subscription_active")
    private Boolean isSubscriptionActive;

    @JsonProperty("is_subscription_expiring_soon")
    private Boolean isSubscriptionExpiringSoon;

    @JsonProperty("total_rentals")
    private Integer totalRentals;

    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue;

    @JsonProperty("yearly_revenue")
    private Double yearlyRevenue;

    @JsonProperty("last_activity_at")
    private LocalDateTime lastActivityAt;

    @JsonProperty("is_active")
    private Boolean isActive;

    @JsonProperty("created_at")
    private LocalDateTime createdAt;

    @JsonProperty("updated_at")
    private LocalDateTime updatedAt;

    @JsonProperty("created_by")
    private UUID createdBy;

    @JsonProperty("updated_by")
    private UUID updatedBy;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OrganizationSettings.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * Paramètres d'organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrganizationSettings {

    @JsonProperty("notification_settings")
    private NotificationSettings notificationSettings;

    @JsonProperty("integration_settings")
    private IntegrationSettings integrationSettings;

    @JsonProperty("security_settings")
    private SecuritySettings securitySettings;

    @JsonProperty("business_settings")
    private BusinessSettings businessSettings;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class NotificationSettings {
        @JsonProperty("email_notifications")
        private Boolean emailNotifications = true;

        @JsonProperty("sms_notifications")
        private Boolean smsNotifications = false;

        @JsonProperty("push_notifications")
        private Boolean pushNotifications = true;

        @JsonProperty("booking_notifications")
        private Boolean bookingNotifications = true;

        @JsonProperty("payment_notifications")
        private Boolean paymentNotifications = true;

        @JsonProperty("maintenance_notifications")
        private Boolean maintenanceNotifications = true;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class IntegrationSettings {
        @JsonProperty("enable_api_access")
        private Boolean enableApiAccess = false;

        @JsonProperty("webhook_url")
        private String webhookUrl;

        @JsonProperty("payment_gateway")
        private String paymentGateway = "STRIPE";

        @JsonProperty("mapping_service")
        private String mappingService = "GOOGLE_MAPS";

        @JsonProperty("sms_provider")
        private String smsProvider = "TWILIO";
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class SecuritySettings {
        @JsonProperty("two_factor_auth_required")
        private Boolean twoFactorAuthRequired = false;

        @JsonProperty("password_expiry_days")
        private Integer passwordExpiryDays = 90;

        @JsonProperty("session_timeout_minutes")
        private Integer sessionTimeoutMinutes = 480; // 8 heures

        @JsonProperty("ip_whitelist_enabled")
        private Boolean ipWhitelistEnabled = false;

        @JsonProperty("audit_log_retention_days")
        private Integer auditLogRetentionDays = 365;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class BusinessSettings {
        @JsonProperty("operating_hours")
        private String operatingHours = "24/7";

        @JsonProperty("default_late_fee_rate")
        private Double defaultLateFeeRate = 0.1;

        @JsonProperty("damage_assessment_required")
        private Boolean damageAssessmentRequired = true;

        @JsonProperty("require_driver_verification")
        private Boolean requireDriverVerification = true;

        @JsonProperty("auto_insurance_included")
        private Boolean autoInsuranceIncluded = true;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OrganizationStatisticsRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * DTO pour la mise à jour des statistiques d'organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrganizationStatisticsRequest {

    @JsonProperty("resource_counters")
    private ResourceCounters resourceCounters;

    @JsonProperty("financial_stats")
    private FinancialStatistics financialStats;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class ResourceCounters {
        @JsonProperty("agencies")
        private Integer agencies;

        @JsonProperty("vehicles")
        private Integer vehicles;

        @JsonProperty("drivers")
        private Integer drivers;

        @JsonProperty("users")
        private Integer users;
    }

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class FinancialStatistics {
        @JsonProperty("monthly_revenue")
        private Double monthlyRevenue;

        @JsonProperty("yearly_revenue")
        private Double yearlyRevenue;

        @JsonProperty("total_rentals")
        private Integer totalRentals;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OrganizationStatisticsResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse pour les statistiques d'organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class OrganizationStatisticsResponse {

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("total_agencies")
    private Integer totalAgencies;

    @JsonProperty("active_agencies")
    private Integer activeAgencies;

    @JsonProperty("max_agencies")
    private Integer maxAgencies;

    @JsonProperty("total_vehicles")
    private Integer totalVehicles;

    @JsonProperty("max_vehicles")
    private Integer maxVehicles;

    @JsonProperty("total_drivers")
    private Integer totalDrivers;

    @JsonProperty("max_drivers")
    private Integer maxDrivers;

    @JsonProperty("total_users")
    private Integer totalUsers;

    @JsonProperty("max_users")
    private Integer maxUsers;

    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue;

    @JsonProperty("yearly_revenue")
    private Double yearlyRevenue;

    @JsonProperty("total_rentals")
    private Integer totalRentals;

    @JsonProperty("agency_usage_percentage")
    private Double agencyUsagePercentage;

    @JsonProperty("vehicle_usage_percentage")
    private Double vehicleUsagePercentage;

    @JsonProperty("driver_usage_percentage")
    private Double driverUsagePercentage;

    @JsonProperty("user_usage_percentage")
    private Double userUsagePercentage;

    @JsonProperty("is_subscription_active")
    private Boolean isSubscriptionActive;

    @JsonProperty("subscription_expires_at")
    private LocalDateTime subscriptionExpiresAt;

    @JsonProperty("last_activity_at")
    private LocalDateTime lastActivityAt;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\OwnerInfoRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.time.LocalDate;

/**
 * DTO pour les informations du propriétaire (Étape 1)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class OwnerInfoRequest {

    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    @JsonProperty("first_name")
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    @JsonProperty("last_name")
    private String lastName;

    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @JsonProperty("email")
    private String email;

    @NotBlank(message = "Phone is required")
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @JsonProperty("phone")
    private String phone;

    @NotBlank(message = "ID card number is required")
    @JsonProperty("id_card_number")
    private String idCardNumber;

    @NotBlank(message = "Address is required")
    @Size(max = 255, message = "Address must not exceed 255 characters")
    @JsonProperty("address")
    private String address;

    @NotBlank(message = "City is required")
    @Size(max = 100, message = "City must not exceed 100 characters")
    @JsonProperty("city")
    private String city;

    @NotBlank(message = "Country is required")
    @Size(max = 100, message = "Country must not exceed 100 characters")
    @JsonProperty("country")
    private String country;

    @Past(message = "Date of birth must be in the past")
    @JsonProperty("date_of_birth")
    private LocalDate dateOfBirth;

    @JsonProperty("nationality")
    private String nationality;

    @JsonProperty("profession")
    private String profession;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\PermissionCheckResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PermissionCheckResponse {

    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("permission")
    private String permission;

    @JsonProperty("has_permission")
    private Boolean hasPermission;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\PermissionComparisonResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PermissionComparisonResponse {

    @JsonProperty("user_id_1")
    private UUID userId1;

    @JsonProperty("user_id_2")
    private UUID userId2;

    @JsonProperty("common_permissions")
    private Set<String> commonPermissions;

    @JsonProperty("user_1_only_permissions")
    private Set<String> user1OnlyPermissions;

    @JsonProperty("user_2_only_permissions")
    private Set<String> user2OnlyPermissions;

    @JsonProperty("common_count")
    private Integer commonCount;

    @JsonProperty("user_1_only_count")
    private Integer user1OnlyCount;

    @JsonProperty("user_2_only_count")
    private Integer user2OnlyCount;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\PermissionResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PermissionResponse {

    @JsonProperty("code")
    private String code;

    @JsonProperty("description")
    private String description;

    @JsonProperty("resource")
    private String resource;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\PersonnelResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.Data;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
public class PersonnelResponse {
    @JsonProperty("id")
    private UUID id;

    @JsonProperty("email")
    private String email;

    @JsonProperty("firstName")
    private String firstName;

    @JsonProperty("lastName")
    private String lastName;

    @JsonProperty("fullName")
    private String fullName;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("userType")
    private UserType userType;

    @JsonProperty("organizationId")
    private UUID organizationId;

    @JsonProperty("agencyId")
    private UUID agencyId;

    @JsonProperty("profilePicture")
    private String profilePicture;

    // Informations employé
    @JsonProperty("employeeId")
    private String employeeId;

    @JsonProperty("department")
    private String department;

    @JsonProperty("position")
    private String position;

    @JsonProperty("supervisorId")
    private UUID supervisorId;

    @JsonProperty("hiredAt")
    private LocalDateTime hiredAt;

    // Statuts
    @JsonProperty("isActive")
    private Boolean isActive;

    @JsonProperty("isEmailVerified")
    private Boolean isEmailVerified;

    @JsonProperty("isPhoneVerified")
    private Boolean isPhoneVerified;

    @JsonProperty("mustChangePassword")
    private Boolean mustChangePassword;

    @JsonProperty("lastLoginAt")
    private LocalDateTime lastLoginAt;

    @JsonProperty("createdAt")
    private LocalDateTime createdAt;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\RefreshTokenRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class RefreshTokenRequest {
    @JsonProperty("refreshToken")
    @NotBlank(message = "Refresh token is required")
    private String refreshToken;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\RegisterRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.util.UUID;

@Data
public class RegisterRequest {
    @JsonProperty("email")
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;

    @JsonProperty("password")
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    private String password;

    @JsonProperty("firstName")
    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;

    @JsonProperty("lastName")
    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("userType")
    @NotNull(message = "User type is required")
    private UserType userType;

    @JsonProperty("organizationId")
    private UUID organizationId;

    @JsonProperty("agencyId")
    private UUID agencyId;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\ResetPasswordRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class ResetPasswordRequest {
    @JsonProperty("token")
    @NotBlank(message = "Reset token is required")
    private String token;

    @JsonProperty("newPassword")
    @NotBlank(message = "New password is required")
    @Size(min = 8, message = "New password must be at least 8 characters")
    private String newPassword;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\ResourceLimitInfo.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * Informations sur les limites d'une ressource
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ResourceLimitInfo {
    @JsonProperty("current")
    private Integer current;

    @JsonProperty("maximum")
    private Integer maximum;

    @JsonProperty("available")
    private Integer available;

    @JsonProperty("usage_percentage")
    private Double usagePercentage;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\ResourcePermissionsResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ResourcePermissionsResponse {

    @JsonProperty("resource")
    private String resource;

    @JsonProperty("permissions")
    private Set<PermissionResponse> permissions;

    @JsonProperty("total_count")
    private Integer totalCount;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\RolePermissionsResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RolePermissionsResponse {

    @JsonProperty("role_id")
    private UUID roleId;

    @JsonProperty("role_name")
    private String roleName;

    @JsonProperty("permissions")
    private Set<String> permissions;

    @JsonProperty("permission_details")
    private Set<PermissionResponse> permissionDetails;

    @JsonProperty("total_count")
    private Integer totalCount;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\RoleResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.RoleType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Set;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RoleResponse {

    @JsonProperty("id")
    private UUID id;

    @JsonProperty("name")
    private String name;

    @JsonProperty("description")
    private String description;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("role_type")
    private RoleType roleType;

    @JsonProperty("is_system_role")
    private Boolean isSystemRole;

    @JsonProperty("is_default_role")
    private Boolean isDefaultRole;

    @JsonProperty("priority")
    private Integer priority;

    @JsonProperty("permissions")
    private Set<String> permissions;

    @JsonProperty("permission_count")
    private Integer permissionCount;

    @JsonProperty("user_count")
    private Integer userCount;

    @JsonProperty("color")
    private String color;

    @JsonProperty("icon")
    private String icon;

    @JsonProperty("can_be_modified")
    private Boolean canBeModified;

    @JsonProperty("can_be_deleted")
    private Boolean canBeDeleted;

    @JsonProperty("created_at")
    private LocalDateTime createdAt;

    @JsonProperty("updated_at")
    private LocalDateTime updatedAt;

    @JsonProperty("created_by")
    private UUID createdBy;

    @JsonProperty("updated_by")
    private UUID updatedBy;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\SecurityContext.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;
import java.util.UUID;

/**
 * Contexte de sécurité pour l'utilisateur
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SecurityContext {
    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("user_type")
    private UserType userType;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("agency_id")
    private UUID agencyId;

    @JsonProperty("email")
    private String email;

    @JsonProperty("full_name")
    private String fullName;

    @JsonProperty("is_active")
    private Boolean isActive;

    @JsonProperty("is_email_verified")
    private Boolean isEmailVerified;
    @JsonProperty("permissions")
    private Set<String> permissions;

    @JsonProperty("roles")
    private Set<String> roles;

    @JsonProperty("organizations")
    private Set<UUID> organizations;

    @JsonProperty("is_super_admin")
    private Boolean isSuperAdmin;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\SubscriptionChangeValidation.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.util.List;
import java.util.UUID;

/**
 * Validation de changement d'abonnement
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SubscriptionChangeValidation {
    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("new_plan_id")
    private UUID newPlanId;

    @JsonProperty("is_upgrade")
    private Boolean isUpgrade;

    @JsonProperty("can_change")
    private Boolean canChange;

    @JsonProperty("agency_limit_sufficient")
    private Boolean agencyLimitSufficient;

    @JsonProperty("vehicle_limit_sufficient")
    private Boolean vehicleLimitSufficient;

    @JsonProperty("driver_limit_sufficient")
    private Boolean driverLimitSufficient;

    @JsonProperty("user_limit_sufficient")
    private Boolean userLimitSufficient;

    @JsonProperty("blocking_reasons")
    private List<String> blockingReasons;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\SubscriptionInfoRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotNull;
import java.util.UUID;

/**
 * DTO pour les informations de souscription (Étape 3)
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SubscriptionInfoRequest {

    @NotNull(message = "Subscription plan ID is required")
    @JsonProperty("subscription_plan_id")
    private UUID subscriptionPlanId;

    @JsonProperty("payment_method")
    private String paymentMethod;

    @JsonProperty("payment_token")
    private String paymentToken;

    @JsonProperty("billing_address")
    private String billingAddress;

    @JsonProperty("billing_city")
    private String billingCity;

    @JsonProperty("billing_country")
    private String billingCountry;

    @JsonProperty("accept_terms")
    private Boolean acceptTerms = false;

    @JsonProperty("newsletter_subscription")
    private Boolean newsletterSubscription = false;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\SubscriptionLimitsResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.*;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Réponse pour les limites d'abonnement
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SubscriptionLimitsResponse {
    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("subscription_active")
    private Boolean subscriptionActive;

    @JsonProperty("subscription_expires_at")
    private LocalDateTime subscriptionExpiresAt;

    @JsonProperty("agency_limits")
    private ResourceLimitInfo agencyLimits;

    @JsonProperty("vehicle_limits")
    private ResourceLimitInfo vehicleLimits;

    @JsonProperty("driver_limits")
    private ResourceLimitInfo driverLimits;

    @JsonProperty("user_limits")
    private ResourceLimitInfo userLimits;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\SubscriptionResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Réponse abonnement
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SubscriptionResponse {
    @JsonProperty("id")
    private UUID id;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("subscription_plan_id")
    private UUID subscriptionPlanId;

    @JsonProperty("status")
    private inc.yowyob.rental_api_reactive.application.dto.SubscriptionStatus status;

    @JsonProperty("start_date")
    private LocalDateTime startDate;

    @JsonProperty("end_date")
    private LocalDateTime endDate;

    @JsonProperty("amount")
    private java.math.BigDecimal amount;

    @JsonProperty("currency")
    private String currency;

    @JsonProperty("auto_renew")
    private Boolean autoRenew;

    @JsonProperty("is_active")
    private Boolean isActive;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\SubscriptionValidationResult.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import java.util.UUID;

/**
 * Résultat de validation d'abonnement
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class SubscriptionValidationResult {
    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("subscription_active")
    private Boolean subscriptionActive;

    @JsonProperty("can_create_agency")
    private Boolean canCreateAgency;

    @JsonProperty("can_add_vehicle")
    private Boolean canAddVehicle;

    @JsonProperty("can_add_driver")
    private Boolean canAddDriver;

    @JsonProperty("can_add_user")
    private Boolean canAddUser;

    @JsonProperty("agency_usage_percentage")
    private Double agencyUsagePercentage;

    @JsonProperty("vehicle_usage_percentage")
    private Double vehicleUsagePercentage;

    @JsonProperty("driver_usage_percentage")
    private Double driverUsagePercentage;

    @JsonProperty("user_usage_percentage")
    private Double userUsagePercentage;

    @JsonProperty("has_limit_warnings")
    private Boolean hasLimitWarnings;

    @JsonProperty("subscription_expiring_soon")
    private Boolean subscriptionExpiringSoon;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\TenantFilter.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.*;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

/**
 * Filtre multi-tenant pour les requêtes
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TenantFilter {
    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("user_type")
    private UserType userType;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("agency_id")
    private UUID agencyId;

    @JsonProperty("is_global_access")
    private Boolean isGlobalAccess = false;

    @JsonProperty("is_agency_restricted")
    private Boolean isAgencyRestricted = false;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UpdateAgencyRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.*;
import lombok.*;
import java.util.Map;
import java.util.UUID;

/**
 * DTO pour la mise à jour d'une agence
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateAgencyRequest {

    @Size(min = 2, max = 100, message = "Agency name must be between 2 and 100 characters")
    @JsonProperty("name")
    private String name;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @JsonProperty("description")
    private String description;

    @Size(max = 255, message = "Address must not exceed 255 characters")
    @JsonProperty("address")
    private String address;

    @Size(max = 100, message = "City must not exceed 100 characters")
    @JsonProperty("city")
    private String city;

    @Size(max = 100, message = "Country must not exceed 100 characters")
    @JsonProperty("country")
    private String country;

    @Size(max = 20, message = "Postal code must not exceed 20 characters")
    @JsonProperty("postal_code")
    private String postalCode;

    @Size(max = 100, message = "Region must not exceed 100 characters")
    @JsonProperty("region")
    private String region;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @JsonProperty("phone")
    private String phone;

    @Email(message = "Email should be valid")
    @JsonProperty("email")
    private String email;

    @JsonProperty("latitude")
    private Double latitude;

    @JsonProperty("longitude")
    private Double longitude;

    @JsonProperty("manager_id")
    private UUID managerId;

    @JsonProperty("is_24_hours")
    private Boolean is24Hours;

    @JsonProperty("timezone")
    private String timezone;

    @JsonProperty("working_hours")
    private Map<String, WorkingHoursInfo> workingHours;

    @JsonProperty("business_settings")
    private AgencyBusinessSettings businessSettings;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UpdateDriverRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.Money;
import inc.yowyob.rental_api_reactive.application.dto.WorkingHours;
import jakarta.validation.constraints.Future;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

@Data
public class UpdateDriverRequest {
     // Staff info
    @JsonProperty("position")
    private String position;

    @JsonProperty("department")
    private String department;

    @JsonProperty("staffStatus")
    private String staffStatus;

    @JsonProperty("hourlyRate")
    private Money hourlyRate;

    @JsonProperty("workingHours")
    private WorkingHours workingHours;

    @JsonProperty("dateOfBirth")
    private LocalDate dateOfBirth; // On peut autoriser la correction de la date de naissance
    // Driver info
    @JsonProperty("licenseNumber")
    private String licenseNumber;

    @JsonProperty("licenseType")
    private String licenseType;

    @JsonProperty("licenseExpiry")
    private LocalDate licenseExpiry;

    @JsonProperty("experience")
    private Integer experience;

    /**
     * La localisation actuelle du chauffeur (ex: "Douala, Bonapriso").
     */
    @JsonProperty("location")
    private String location;

    @JsonProperty("idCardUrl")
    private String idCardUrl;

    @JsonProperty("driverLicenseUrl")
    private String driverLicenseUrl;
     @JsonProperty("profileUrl")
    private String profileUrl;      // La photo de profile du driver

    /**
     * Liste des IDs de véhicules actuellement assignés.
     */
    @JsonProperty("assignedVehicleIds")
    private List<UUID> assignedVehicleIds;

    /**
     * Disponibilité du chauffeur pour de nouvelles courses.
     */
    @JsonProperty("available")
    private Boolean available;

    /**
     * Statut opérationnel du chauffeur (disponible, en course, hors service...).
    //  */
    // @JsonProperty("status")
    // private DriverStatus status;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UpdateOrganizationRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.OrganizationType;
import jakarta.validation.constraints.*;
import lombok.*;

/**
 * DTO pour la mise à jour d'une organisation
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateOrganizationRequest {

    @Size(min = 2, max = 100, message = "Organization name must be between 2 and 100 characters")
    @JsonProperty("name")
    private String name;

    @JsonProperty("organization_type")
    private OrganizationType organizationType;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @JsonProperty("description")
    private String description;

    @JsonProperty("registration_number")
    private String registrationNumber;

    @JsonProperty("tax_number")
    private String taxNumber;

    @JsonProperty("business_license")
    private String businessLicense;

    @JsonProperty("address")
    private String address;

    @JsonProperty("city")
    private String city;

    @JsonProperty("country")
    private String country;

    @JsonProperty("postal_code")
    private String postalCode;

    @JsonProperty("region")
    private String region;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @JsonProperty("phone")
    private String phone;

    @Email(message = "Email should be valid")
    @JsonProperty("email")
    private String email;

    @JsonProperty("website")
    private String website;

    @JsonProperty("currency")
    private String currency;

    @JsonProperty("timezone")
    private String timezone;

    @JsonProperty("language")
    private String language;

    @JsonProperty("primary_color")
    private String primaryColor;

    @JsonProperty("secondary_color")
    private String secondaryColor;

    @JsonProperty("policies")
    private OrganizationPolicies policies;

    @JsonProperty("settings")
    private OrganizationSettings settings;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UpdatePersonnelRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.Size;
import lombok.Data;

import java.util.UUID;

@Data
public class UpdatePersonnelRequest {
    @JsonProperty("firstName")
    @Size(min = 2, max = 50, message = "Prénom doit être entre 2 et 50 caractères")
    private String firstName;

    @JsonProperty("lastName")
    @Size(min = 2, max = 50, message = "Nom doit être entre 2 et 50 caractères")
    private String lastName;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("employeeId")
    private String employeeId;

    @JsonProperty("department")
    private String department;

    @JsonProperty("position")
    private String position;

    @JsonProperty("supervisorId")
    private UUID supervisorId;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UpdateProfileRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.Size;
import lombok.Data;

@Data
public class UpdateProfileRequest {
    @JsonProperty("firstName")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;

    @JsonProperty("lastName")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;

    @JsonProperty("phone")
    private String phone;

    @JsonProperty("address")
    private String address;

    @JsonProperty("city")
    private String city;

    @JsonProperty("country")
    private String country;

    @JsonProperty("profilePicture")
    private String profilePicture;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UpdateRoleRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.*;
import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UpdateRoleRequest {

    @Size(min = 2, max = 100, message = "Role name must be between 2 and 100 characters")
    @JsonProperty("name")
    private String name;

    @Size(max = 255, message = "Description must not exceed 255 characters")
    @JsonProperty("description")
    private String description;

    @Min(value = 0, message = "Priority must be positive")
    @Max(value = 100, message = "Priority must not exceed 100")
    @JsonProperty("priority")
    private Integer priority;

    @JsonProperty("permissions")
    private Set<String> permissions;

    @Pattern(regexp = "^#[0-9A-Fa-f]{6}$", message = "Color must be a valid hex color")
    @JsonProperty("color")
    private String color;

    @Size(max = 50, message = "Icon name must not exceed 50 characters")
    @JsonProperty("icon")
    private String icon;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UpdateSubscriptionRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.*;
import lombok.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO pour la mise à jour d'abonnement
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UpdateSubscriptionRequest {

    @NotNull(message = "Subscription plan ID is required")
    @JsonProperty("subscription_plan_id")
    private UUID subscriptionPlanId;

    @NotNull(message = "Expiration date is required")
    @JsonProperty("expires_at")
    private LocalDateTime expiresAt;

    @JsonProperty("auto_renew")
    private Boolean autoRenew = true;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UserPermissionsResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserPermissionsResponse {

    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("permissions")
    private Set<String> permissions;

    @JsonProperty("permission_details")
    private Set<PermissionResponse> permissionDetails;

    @JsonProperty("total_count")
    private Integer totalCount;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UserPreferencesRequest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

@Data
public class UserPreferencesRequest {
    @JsonProperty("preferredLanguage")
    private String preferredLanguage;

    @JsonProperty("timezone")
    private String timezone;

    @JsonProperty("emailNotifications")
    private Boolean emailNotifications;

    @JsonProperty("smsNotifications")
    private Boolean smsNotifications;

    @JsonProperty("currency")
    private String currency;

    @JsonProperty("dateFormat")
    private String dateFormat;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UserResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * DTO de réponse utilisateur
 */
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserResponse {
    @JsonProperty("id")
    public UUID id;

    @JsonProperty("email")
    public String email;

    @JsonProperty("firstName")
    public String firstName;

    @JsonProperty("lastName")
    public String lastName;

    @JsonProperty("fullName")
    public String fullName;

    @JsonProperty("phone")
    public String phone;

    @JsonProperty("userType")
    public UserType userType;

    @JsonProperty("organizationId")
    public UUID organizationId;

    @JsonProperty("agencyId")
    public UUID agencyId;

    @JsonProperty("profilePicture")
    public String profilePicture;

    @JsonProperty("address")
    public String address;

    @JsonProperty("city")
    public String city;

    @JsonProperty("country")
    public String country;

    @JsonProperty("isEmailVerified")
    public Boolean isEmailVerified;

    @JsonProperty("isPhoneVerified")
    public Boolean isPhoneVerified;

    @JsonProperty("preferredLanguage")
    public String preferredLanguage;

    @JsonProperty("timezone")
    public String timezone;

    @JsonProperty("currency")
    public String currency;

    @JsonProperty("dateFormat")
    public String dateFormat;

    @JsonProperty("emailNotifications")
    public Boolean emailNotifications;

    @JsonProperty("smsNotifications")
    public Boolean smsNotifications;

    @JsonProperty("pushNotifications")
    public Boolean pushNotifications;

    @JsonProperty("employeeId")
    public String employeeId;

    @JsonProperty("department")
    public String department;

    @JsonProperty("position")
    public String position;

    @JsonProperty("supervisorId")
    public UUID supervisorId;

    @JsonProperty("hiredAt")
    public LocalDateTime hiredAt;

    @JsonProperty("mustChangePassword")
    public Boolean mustChangePassword;

    @JsonProperty("isActive")
    public Boolean isActive;

    @JsonProperty("lastLoginAt")
    public LocalDateTime lastLoginAt;

    @JsonProperty("createdAt")
    public LocalDateTime createdAt;

    /**
     * Vérifie si l'utilisateur est du personnel
     */
    @JsonProperty("isPersonnel")
    public Boolean getIsPersonnel() {
        return userType == UserType.AGENCY_MANAGER ||
            userType == UserType.RENTAL_AGENT;
    }

    /**
     * Vérifie si l'utilisateur est un client
     */
    @JsonProperty("isClient")
    public Boolean getIsClient() {
        return userType == UserType.CLIENT;
    }

    /**
     * Vérifie si l'utilisateur est un administrateur
     */
    @JsonProperty("isAdmin")
    public Boolean getIsAdmin() {
        return userType == UserType.SUPER_ADMIN ||
            userType == UserType.ORGANIZATION_OWNER;
    }

    /**
     * Vérifie si l'utilisateur peut gérer une agence
     */
    @JsonProperty("canManageAgency")
    public Boolean getCanManageAgency() {
        return userType == UserType.ORGANIZATION_OWNER ||
            userType == UserType.AGENCY_MANAGER;
    }

    /**
     * Vérifie si l'utilisateur peut effectuer des locations
     */
    @JsonProperty("canHandleRentals")
    public Boolean getCanHandleRentals() {
        return userType == UserType.AGENCY_MANAGER ||
            userType == UserType.RENTAL_AGENT;
    }

    /**
     * Vérifie si l'utilisateur est assigné à une agence
     */
    @JsonProperty("isAssignedToAgency")
    public Boolean getIsAssignedToAgency() {
        return agencyId != null;
    }

    /**
     * Obtient le niveau hiérarchique de l'utilisateur
     */
    @JsonProperty("hierarchyLevel")
    public Integer getHierarchyLevel() {
        return userType != null ? userType.getHierarchyLevel() : 0;
    }

    /**
     * Indique si l'utilisateur a besoin de vérifier son email
     */
    @JsonProperty("needsEmailVerification")
    public Boolean getNeedsEmailVerification() {
        return !Boolean.TRUE.equals(isEmailVerified);
    }

    /**
     * Indique si l'utilisateur a besoin de vérifier son téléphone
     */
    @JsonProperty("needsPhoneVerification")
    public Boolean getNeedsPhoneVerification() {
        return !Boolean.TRUE.equals(isPhoneVerified);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UserRoleResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserRoleResponse {

    @JsonProperty("id")
    private UUID id;

    @JsonProperty("user_id")
    private UUID userId;

    @JsonProperty("role_id")
    private UUID roleId;

    @JsonProperty("role_name")
    private String roleName;

    @JsonProperty("organization_id")
    private UUID organizationId;

    @JsonProperty("agency_id")
    private UUID agencyId;

    @JsonProperty("assigned_at")
    private LocalDateTime assignedAt;

    @JsonProperty("expires_at")
    private LocalDateTime expiresAt;

    @JsonProperty("is_active")
    private Boolean isActive;

    @JsonProperty("is_expired")
    private Boolean isExpired;

    @JsonProperty("assigned_by")
    private UUID assignedBy;

    @JsonProperty("revoked_at")
    private LocalDateTime revokedAt;

    @JsonProperty("revoked_by")
    private UUID revokedBy;
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\UserStatsResponse.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;

/**
 * DTO pour les statistiques des utilisateurs
 */
@Data
public class UserStatsResponse {
    @JsonProperty("totalUsers")
    public Long totalUsers;

    @JsonProperty("activeUsers")
    public Long activeUsers;

    @JsonProperty("personnelCount")
    public Long personnelCount;

    @JsonProperty("clientCount")
    public Long clientCount;

    @JsonProperty("inactiveUsers")
    public Long getInactiveUsers() {
        return totalUsers - activeUsers;
    }

    @JsonProperty("personnelPercentage")
    public Double getPersonnelPercentage() {
        return totalUsers > 0 ? (personnelCount.doubleValue() / totalUsers.doubleValue()) * 100 : 0.0;
    }

    @JsonProperty("clientPercentage")
    public Double getClientPercentage() {
        return totalUsers > 0 ? (clientCount.doubleValue() / totalUsers.doubleValue()) * 100 : 0.0;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\dto\WorkingHoursInfo.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;

/**
 * Informations sur les horaires de travail
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class WorkingHoursInfo {

    @JsonProperty("is_open")
    private Boolean isOpen = true;

    @JsonProperty("open_time")
    private String openTime; // Format HH:mm

    @JsonProperty("close_time")
    private String closeTime; // Format HH:mm

    @JsonProperty("break_start")
    private String breakStart; // Format HH:mm (optionnel)

    @JsonProperty("break_end")
    private String breakEnd; // Format HH:mm (optionnel)
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\infrastructure\web\exception\GlobalReactiveExceptionHandler.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.exception;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.bind.support.WebExchangeBindException;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import jakarta.validation.ConstraintViolationException;
import java.util.stream.Collectors;

@RestControllerAdvice
@Slf4j
public class GlobalReactiveExceptionHandler {

    @ExceptionHandler(WebExchangeBindException.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleValidationErrors(
        WebExchangeBindException ex, ServerWebExchange exchange) {
        log.error("Validation error: {}", ex.getMessage());

        String errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.joining(", "));

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message("Erreurs de validation: " + errors)
            .data(null)
            .build();

        return Mono.just(ResponseEntity.badRequest().body(response));
    }

    @ExceptionHandler(ConstraintViolationException.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleConstraintViolation(
        ConstraintViolationException ex, ServerWebExchange exchange) {
        log.error("Constraint violation: {}", ex.getMessage());

        String errors = ex.getConstraintViolations()
            .stream()
            .map(violation -> violation.getPropertyPath() + ": " + violation.getMessage())
            .collect(Collectors.joining(", "));

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message("Violations de contraintes: " + errors)
            .data(null)
            .build();

        return Mono.just(ResponseEntity.badRequest().body(response));
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleIllegalArgument(
        IllegalArgumentException ex, ServerWebExchange exchange) {
        log.error("Illegal argument: {}", ex.getMessage());

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message(ex.getMessage())
            .data(null)
            .build();

        return Mono.just(ResponseEntity.badRequest().body(response));
    }

    @ExceptionHandler(IllegalStateException.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleIllegalState(
        IllegalStateException ex, ServerWebExchange exchange) {
        log.error("Illegal state: {}", ex.getMessage());

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message(ex.getMessage())
            .data(null)
            .build();

        return Mono.just(ResponseEntity.badRequest().body(response));
    }

    @ExceptionHandler(RuntimeException.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleRuntimeException(
        RuntimeException ex, ServerWebExchange exchange) {
        log.error("Runtime exception: {}", ex.getMessage(), ex);

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message("Erreur interne du serveur")
            .data(null)
            .build();

        return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response));
    }

    @ExceptionHandler(Exception.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleGenericException(
        Exception ex, ServerWebExchange exchange) {
        log.error("Unexpected error: {}", ex.getMessage(), ex);

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message("Une erreur inattendue s'est produite")
            .data(null)
            .build();

        return Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response));
    }

    /**
     * Handler pour les erreurs de session d'onboarding non trouvée
     */
    @ExceptionHandler(SessionNotFoundException.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleSessionNotFound(
        SessionNotFoundException ex, ServerWebExchange exchange) {
        log.error("Session not found: {}", ex.getMessage());

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message(ex.getMessage())
            .data(null)
            .build();

        return Mono.just(ResponseEntity.status(HttpStatus.NOT_FOUND).body(response));
    }

    /**
     * Handler pour les erreurs de session expirée
     */
    @ExceptionHandler(SessionExpiredException.class)
    public Mono<ResponseEntity<ApiResponse<Object>>> handleSessionExpired(
        SessionExpiredException ex, ServerWebExchange exchange) {
        log.error("Session expired: {}", ex.getMessage());

        ApiResponse<Object> response = ApiResponse.<Object>builder()
            .success(false)
            .message(ex.getMessage())
            .data(null)
            .build();

        return Mono.just(ResponseEntity.status(HttpStatus.GONE).body(response));
    }

    /**
     * Exception personnalisée pour session non trouvée
     */
    public static class SessionNotFoundException extends RuntimeException {
        public SessionNotFoundException(String message) {
            super(message);
        }
    }

    /**
     * Exception personnalisée pour session expirée
     */
    public static class SessionExpiredException extends RuntimeException {
        public SessionExpiredException(String message) {
            super(message);
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\config\CassandraReactiveConfig.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.config;

import com.fasterxml.jackson.databind.ObjectMapper; // <<< NOUVEAU
import inc.yowyob.rental_api_reactive.persistence.converter.JsonStringToMapConverter;
import inc.yowyob.rental_api_reactive.persistence.converter.MapToJsonStringConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.cassandra.config.AbstractReactiveCassandraConfiguration;
import org.springframework.data.cassandra.config.SchemaAction;
import org.springframework.data.cassandra.core.convert.CassandraCustomConversions;
import org.springframework.data.cassandra.core.cql.keyspace.CreateKeyspaceSpecification;
import org.springframework.data.cassandra.core.cql.keyspace.KeyspaceOption;
import org.springframework.data.cassandra.repository.config.EnableReactiveCassandraRepositories;

import java.util.Collections;
import java.util.List;

@Configuration
@EnableReactiveCassandraRepositories(basePackages = "inc.yowyob.rental_api_reactive.persistence.repository")
public class CassandraReactiveConfig extends AbstractReactiveCassandraConfiguration {

    private final String keyspaceName;
    private final String contactPoints;
    private final int port;
    private final String localDataCenter;
    private final ObjectMapper objectMapper;

    // <<< NOUVEAU : Injection par constructeur, c'est une meilleure pratique
    public CassandraReactiveConfig(
            @Value("${spring.cassandra.keyspace-name}") String keyspaceName,
            @Value("${spring.cassandra.contact-points}") String contactPoints,
            @Value("${spring.cassandra.port}") int port,
            @Value("${spring.cassandra.local-datacenter}") String localDataCenter,
            ObjectMapper objectMapper) {
        this.keyspaceName = keyspaceName;
        this.contactPoints = contactPoints;
        this.port = port;
        this.localDataCenter = localDataCenter;
        this.objectMapper = objectMapper;
    }

    @Override
    protected String getKeyspaceName() {
        return keyspaceName;
    }

    @Override
    protected String getContactPoints() {
        return contactPoints;
    }

    @Override
    protected int getPort() {
        return port;
    }

    @Override
    protected String getLocalDataCenter() {
        return localDataCenter;
    }

    @Override
    public SchemaAction getSchemaAction() {
        return SchemaAction.CREATE_IF_NOT_EXISTS;
    }

    @Override
    protected List<CreateKeyspaceSpecification> getKeyspaceCreations() {
        return Collections.singletonList(
                CreateKeyspaceSpecification.createKeyspace(getKeyspaceName())
                        .ifNotExists()
                        .with(KeyspaceOption.DURABLE_WRITES, true)
                        .withSimpleReplication(1L)
        );
    }

    @Override
    public String[] getEntityBasePackages() {
        return new String[]{"inc.yowyob.rental_api_reactive.persistence.entity"};
    }

    // On surcharge la méthode pour fournir nos convertisseurs personnalisés
    @Override
    public CassandraCustomConversions customConversions() {
        return new CassandraCustomConversions(List.of(
                new MapToJsonStringConverter(objectMapper),
                new JsonStringToMapConverter(objectMapper)
        ));
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\converter\JsonStringToMapConverter.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.converter;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;

import java.util.Map;

@ReadingConverter // Annotation importante pour indiquer une conversion en lecture
@RequiredArgsConstructor
public class JsonStringToMapConverter implements Converter<String, Map<String, Object>> {

    private final ObjectMapper objectMapper;

    @Override
    @SneakyThrows
    public Map<String, Object> convert(@NonNull String source) {
        // Convertit la chaîne JSON en Map.
        // TypeReference est nécessaire pour gérer correctement les types génériques.
        return objectMapper.readValue(source, new TypeReference<>() {});
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\converter\MapToJsonStringConverter.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.converter;

import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.WritingConverter;

import java.util.Map;

@WritingConverter // Annotation importante pour indiquer une conversion en écriture
@RequiredArgsConstructor
public class MapToJsonStringConverter implements Converter<Map<String, Object>, String> {

    private final ObjectMapper objectMapper;

    @Override
    @SneakyThrows // Gère les exceptions de Jackson pour nous
    public String convert(@NonNull Map<String, Object> source) {
        // Convertit la Map en une chaîne de caractères JSON
        return objectMapper.writeValueAsString(source);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\Agency.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.time.LocalTime;
import java.util.UUID;

/**
 * Entité Agency pour la gestion des agences
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Table("agencies")
public class Agency extends BaseEntity {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    @NotNull(message = "Organization ID is required")
    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @NotBlank(message = "Agency name is required")
    @Size(min = 2, max = 100, message = "Agency name must be between 2 and 100 characters")
    @Column("name")
    @JsonProperty("name")
    private String name;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @Column("description")
    @JsonProperty("description")
    private String description;

    // === ADRESSE ===
    @NotBlank(message = "Address is required")
    @Size(max = 255, message = "Address must not exceed 255 characters")
    @Column("address")
    @JsonProperty("address")
    private String address;

    @NotBlank(message = "City is required")
    @Size(max = 100, message = "City must not exceed 100 characters")
    @Column("city")
    @JsonProperty("city")
    private String city;

    @NotBlank(message = "Country is required")
    @Size(max = 100, message = "Country must not exceed 100 characters")
    @Column("country")
    @JsonProperty("country")
    private String country = "CM";

    @Size(max = 20, message = "Postal code must not exceed 20 characters")
    @Column("postal_code")
    @JsonProperty("postal_code")
    private String postalCode;

    @Size(max = 100, message = "Region must not exceed 100 characters")
    @Column("region")
    @JsonProperty("region")
    private String region;

    // === CONTACT ===
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @Column("phone")
    @JsonProperty("phone")
    private String phone;

    @Email(message = "Email should be valid")
    @Column("email")
    @JsonProperty("email")
    private String email;

    // === GÉOLOCALISATION ===
    @Column("latitude")
    @JsonProperty("latitude")
    private Double latitude;

    @Column("longitude")
    @JsonProperty("longitude")
    private Double longitude;

    @Column("geofence_zone_id")
    @JsonProperty("geofence_zone_id")
    private String geofenceZoneId;

    @PositiveOrZero(message = "Geofence radius must be positive or zero")
    @Column("geofence_radius")
    @JsonProperty("geofence_radius")
    private Double geofenceRadius;

    // === GESTIONNAIRE ===
    @Column("manager_id")
    @JsonProperty("manager_id")
    private UUID managerId;

    // === CONFIGURATION ===
    @Column("is_24_hours")
    @JsonProperty("is_24_hours")
    private Boolean is24Hours = false;

    @Column("timezone")
    @JsonProperty("timezone")
    private String timezone = "Africa/Douala";

    @Column("currency")
    @JsonProperty("currency")
    private String currency = "XAF";

    @Column("language")
    @JsonProperty("language")
    private String language = "fr";

    // === HORAIRES D'OUVERTURE (stockés en JSON) ===
    @Column("working_hours")
    @JsonProperty("working_hours")
    private String workingHours; // JSON format: {"MONDAY": {"open": "08:00", "close": "18:00"}}

    // === PARAMÈTRES BUSINESS ===
    @Column("allow_online_booking")
    @JsonProperty("allow_online_booking")
    private Boolean allowOnlineBooking = true;

    @Column("require_deposit")
    @JsonProperty("require_deposit")
    private Boolean requireDeposit = true;

    @Column("deposit_percentage")
    @JsonProperty("deposit_percentage")
    private Double depositPercentage = 30.0;

    @Column("min_rental_hours")
    @JsonProperty("min_rental_hours")
    private Integer minRentalHours = 1;

    @Column("max_advance_booking_days")
    @JsonProperty("max_advance_booking_days")
    private Integer maxAdvanceBookingDays = 30;

    // === STATISTIQUES ===
    @Column("total_vehicles")
    @JsonProperty("total_vehicles")
    private Integer totalVehicles = 0;

    @Column("active_vehicles")
    @JsonProperty("active_vehicles")
    private Integer activeVehicles = 0;

    @Column("total_drivers")
    @JsonProperty("total_drivers")
    private Integer totalDrivers = 0;

    @Column("active_drivers")
    @JsonProperty("active_drivers")
    private Integer activeDrivers = 0;

    @Column("total_personnel")
    @JsonProperty("total_personnel")
    private Integer totalPersonnel = 0;

    @Column("total_rentals")
    @JsonProperty("total_rentals")
    private Integer totalRentals = 0;

    @Column("monthly_revenue")
    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue = 0.0;

    // === MÉTADONNÉES ===
    @Column("logo_url")
    @JsonProperty("logo_url")
    private String logoUrl;

    @Column("primary_color")
    @JsonProperty("primary_color")
    private String primaryColor = "#3b82f6";

    @Column("secondary_color")
    @JsonProperty("secondary_color")
    private String secondaryColor = "#1e40af";

    // Constructors
    public Agency(UUID organizationId, String name, String address, String city) {
        this.id = UUID.randomUUID();
        this.organizationId = organizationId;
        this.name = name;
        this.address = address;
        this.city = city;
        prePersist();
    }

    // === MÉTHODES UTILITAIRES ===

    /**
     * Obtient l'adresse complète
     */
    @JsonProperty("full_address")
    public String getFullAddress() {
        StringBuilder address = new StringBuilder(this.address);
        if (city != null) address.append(", ").append(city);
        if (region != null) address.append(", ").append(region);
        if (country != null) address.append(", ").append(country);
        return address.toString();
    }

    /**
     * Vérifie si l'agence est ouverte actuellement
     */
    @JsonProperty("is_currently_open")
    public boolean isCurrentlyOpen() {
        if (is24Hours) return true;

        // Logique d'horaires à implémenter selon les working_hours
        LocalTime now = LocalTime.now();
        // TODO: Implémenter la vérification des horaires selon le jour
        return true;
    }

    /**
     * Vérifie si l'agence a une géolocalisation définie
     */
    @JsonProperty("has_location")
    public boolean hasLocation() {
        return latitude != null && longitude != null;
    }

    /**
     * Vérifie si l'agence a un géofencing configuré
     */
    @JsonProperty("has_geofencing")
    public boolean hasGeofencing() {
        return geofenceZoneId != null || (hasLocation() && geofenceRadius != null && geofenceRadius > 0);
    }

    /**
     * Calcule le taux d'occupation des véhicules
     */
    @JsonProperty("vehicle_utilization_rate")
    public double getVehicleUtilizationRate() {
        if (totalVehicles == null || totalVehicles == 0) return 0.0;
        return (activeVehicles != null ? activeVehicles : 0) * 100.0 / totalVehicles;
    }

    /**
     * Calcule le taux d'activité des chauffeurs
     */
    @JsonProperty("driver_activity_rate")
    public double getDriverActivityRate() {
        if (totalDrivers == null || totalDrivers == 0) return 0.0;
        return (activeDrivers != null ? activeDrivers : 0) * 100.0 / totalDrivers;
    }

    /**
     * Met à jour les statistiques des véhicules
     */
    public void updateVehicleStats(int total, int active) {
        this.totalVehicles = total;
        this.activeVehicles = active;
        preUpdate();
    }

    /**
     * Met à jour les statistiques des chauffeurs
     */
    public void updateDriverStats(int total, int active) {
        this.totalDrivers = total;
        this.activeDrivers = active;
        preUpdate();
    }

    /**
     * Met à jour le nombre de personnel
     */
    public void updatePersonnelCount(int count) {
        this.totalPersonnel = count;
        preUpdate();
    }

    /**
     * Incrémente le nombre de locations
     */
    public void incrementRentals() {
        this.totalRentals = (totalRentals != null ? totalRentals : 0) + 1;
        preUpdate();
    }

    /**
     * Met à jour le chiffre d'affaires mensuel
     */
    public void updateMonthlyRevenue(double revenue) {
        this.monthlyRevenue = revenue;
        preUpdate();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\BaseEntity.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import org.springframework.data.cassandra.core.mapping.Column;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
public abstract class BaseEntity {

    @Column("is_active")
    @JsonProperty("is_active")
    protected Boolean isActive = true;

    @Column("created_at")
    @JsonProperty("created_at")
    protected LocalDateTime createdAt;

    @Column("updated_at")
    @JsonProperty("updated_at")
    protected LocalDateTime updatedAt;

    /**
     * Méthode appelée avant la persistance
     */
    public void prePersist() {
        LocalDateTime now = LocalDateTime.now();
        if (createdAt == null) {
            createdAt = now;
        }
        updatedAt = now;
        if (isActive == null) {
            isActive = true;
        }
    }

    /**
     * Méthode appelée avant la mise à jour
     */
    public void preUpdate() {
        updatedAt = LocalDateTime.now();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\Driver.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.Money;
import inc.yowyob.rental_api_reactive.application.dto.WorkingHours;
import jakarta.validation.constraints.*;
import lombok.*;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;
import org.springframework.data.cassandra.core.mapping.Table;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Table("drivers")
public class Driver extends BaseEntity {
    
    @PrimaryKeyColumn(name = "driver_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED)
    @JsonProperty("driver_id")
    private UUID driverId;

    @NotNull(message = "User ID is required")
    @Column("user_id")
    @JsonProperty("user_id")
    private UUID userId;

    @NotNull(message = "Organization ID is required")
    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @Column("agency_id")
    @JsonProperty("agency_id")
    private UUID agencyId; // Lien vers l'agence (peut être null)

    @Column("date_of_birth")
    @NotNull
    private LocalDate dateOfBirth;

    @Column("license_number")
    @NotBlank(message = "License number is required")
    private String licenseNumber;

    @Column("license_type")
    @NotBlank(message = "License type is required")
    private String licenseType;

    @Column("license_expiry")
    private LocalDate licenseExpiryDate;

    @Column("experience")
    @Min(0)
    private Integer experience; // Années d'expérience

    @Column("location")
    private String location;

    @Column("id_card_url")
    private String idCardUrl;

    @Column("driver_license_url")
    private String driverLicenseUrl;

    @Column("assigned_vehicle_ids")
    private List<UUID> assignedVehicleIds;

    @NotNull(message = "Availability status is required")
    @Column("available")
    @JsonProperty("available")
    private Boolean available = true;

    @Column("rating")
    @DecimalMin(value = "0.0") @DecimalMax(value = "5.0")
    @JsonProperty("rating")
    private Double rating = 0.0;

    @Column("insurance_provider")
    @JsonProperty("insuranceProvider")
    private String insuranceProvider;

    @Column("insurance_policy")
    @JsonProperty("insurancePolicy")
    private String insurancePolicy;

    // @Column("status")
    // @JsonProperty("status")
    // private DriverStatus status = DriverStatus.AVAILABLE;

    @Column("status_updated_at")
    @JsonProperty("status_updated_at")
    private LocalDateTime statusUpdatedAt;

    @Column("status_updated_by")
    @JsonProperty("status_updated_by")
    private UUID statusUpdatedBy;

   // --- Attributs de Staff ---
    @Column("employee_id") // Nom de la colonne dans Cassandra
    @JsonProperty("employeeId")
    private String employeeId; // ID employé interne à l'organisation

    @Column("department")
    @JsonProperty("department")
    private String department; // Service/Département

    @Column("position")
    @JsonProperty("position")
    private String position; // Poste/Fonction

    @Column("staff_status")
    @JsonProperty("staffStatus")
    private String staffStatus; // Utiliser une enum (ON_SHIFT, ON_LEAVE, etc.)

    @Column("hourly_rate")
    @JsonProperty("hourlyRate")
    private Money hourlyRate;

    @Column("working_hours")
    @JsonProperty("workingHours")
    private WorkingHours workingHours;

    @Column("hire_date")
    @JsonProperty("hireDate")
    private LocalDate hireDate; // Date d'embauche
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\OnboardingSession.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Table("onboarding_sessions")
public class OnboardingSession extends BaseEntity {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    @Column("session_token")
    @JsonProperty("session_token")
    private String sessionToken;

    @Column("current_step")
    @JsonProperty("current_step")
    private Integer currentStep = 1;

    @Column("max_step")
    @JsonProperty("max_step")
    private Integer maxStep = 3;

    @Column("is_completed")
    @JsonProperty("is_completed")
    private Boolean isCompleted = false;

    @Column("expires_at")
    @JsonProperty("expires_at")
    private LocalDateTime expiresAt;

    // Données des étapes stockées en JSON
    @Column("owner_info")
    @JsonProperty("owner_info")
    private String ownerInfo;

    @Column("organization_info")
    @JsonProperty("organization_info")
    private String organizationInfo;

    @Column("subscription_info")
    @JsonProperty("subscription_info")
    private String subscriptionInfo;

    // Résultats finaux
    @Column("user_id")
    @JsonProperty("user_id")
    private UUID userId;

    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @Column("completed_at")
    @JsonProperty("completed_at")
    private LocalDateTime completedAt;

    // Constructors
    public OnboardingSession() {
        this.id = UUID.randomUUID();
        this.sessionToken = UUID.randomUUID().toString();
        this.expiresAt = LocalDateTime.now().plusHours(24);
        prePersist();
    }

    /**
     * Passe à l'étape suivante
     */
    public void nextStep() {
        if (currentStep < maxStep) {
            currentStep++;
        }
    }

    /**
     * Marque la session comme terminée
     */
    public void complete(UUID organizationId) {
        this.isCompleted = true;
        this.organizationId = organizationId;
        this.completedAt = LocalDateTime.now();
        this.currentStep = maxStep;
    }

    /**
     * Vérifie si la session a expiré
     */
    @JsonProperty("is_expired")
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

    /**
     * Vérifie si la session est valide
     */
    @JsonProperty("is_valid")
    public boolean isValid() {
        return !isExpired() && !isCompleted;
    }

    /**
     * Met à jour les informations d'une étape
     */
    public void updateOwnerInfo(String ownerInfo) {
        this.ownerInfo = ownerInfo;
        this.updatedAt = LocalDateTime.now();
    }

    public void updateOrganizationInfo(String organizationInfo) {
        this.organizationInfo = organizationInfo;
        this.updatedAt = LocalDateTime.now();
    }

    public void updateSubscriptionInfo(String subscriptionInfo) {
        this.subscriptionInfo = subscriptionInfo;
        this.updatedAt = LocalDateTime.now();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\Organization.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.OrganizationType;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Entité Organization
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Table("organizations")
public class Organization extends BaseEntity {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    // === INFORMATIONS DE BASE ===
    @NotBlank(message = "Organization name is required")
    @Size(min = 2, max = 100, message = "Organization name must be between 2 and 100 characters")
    @Column("name")
    @JsonProperty("name")
    private String name;

    @NotNull(message = "Organization type is required")
    @Column("organization_type")
    @JsonProperty("organization_type")
    private OrganizationType organizationType;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @Column("description")
    @JsonProperty("description")
    private String description;

    @NotNull(message = "Owner ID is required")
    @Column("owner_id")
    @JsonProperty("owner_id")
    private UUID ownerId;

    // === INFORMATIONS LÉGALES ===
    @Column("registration_number")
    @JsonProperty("registration_number")
    private String registrationNumber;

    @Column("tax_number")
    @JsonProperty("tax_number")
    private String taxNumber;

    @Column("business_license")
    @JsonProperty("business_license")
    private String businessLicense;

    // === ADRESSE ===
    @NotBlank(message = "Address is required")
    @Column("address")
    @JsonProperty("address")
    private String address;

    @NotBlank(message = "City is required")
    @Column("city")
    @JsonProperty("city")
    private String city;

    @NotBlank(message = "Country is required")
    @Column("country")
    @JsonProperty("country")
    private String country = "CM";

    @Column("postal_code")
    @JsonProperty("postal_code")
    private String postalCode;

    @Column("region")
    @JsonProperty("region")
    private String region;

    // === CONTACT ===
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @Column("phone")
    @JsonProperty("phone")
    private String phone;

    @Email(message = "Email should be valid")
    @Column("email")
    @JsonProperty("email")
    private String email;

    @Column("website")
    @JsonProperty("website")
    private String website;

    // === VÉRIFICATION ===
    @Column("is_verified")
    @JsonProperty("is_verified")
    private Boolean isVerified = false;

    @Column("verification_date")
    @JsonProperty("verification_date")
    private LocalDateTime verificationDate;

    @Column("verified_by")
    @JsonProperty("verified_by")
    private UUID verifiedBy;

    // === LIMITES D'ABONNEMENT ===
    @Column("max_agencies")
    @JsonProperty("max_agencies")
    private Integer maxAgencies = 1;

    @Column("max_vehicles")
    @JsonProperty("max_vehicles")
    private Integer maxVehicles = 10;

    @Column("max_drivers")
    @JsonProperty("max_drivers")
    private Integer maxDrivers = 5;

    @Column("max_users")
    @JsonProperty("max_users")
    private Integer maxUsers = 10;

    // === COMPTEURS ACTUELS ===
    @Column("current_agencies")
    @JsonProperty("current_agencies")
    private Integer currentAgencies = 0;

    @Column("current_vehicles")
    @JsonProperty("current_vehicles")
    private Integer currentVehicles = 0;

    @Column("current_drivers")
    @JsonProperty("current_drivers")
    private Integer currentDrivers = 0;

    @Column("current_users")
    @JsonProperty("current_users")
    private Integer currentUsers = 0;

    // === CONFIGURATION ===
    @Column("currency")
    @JsonProperty("currency")
    private String currency = "XAF";

    @Column("timezone")
    @JsonProperty("timezone")
    private String timezone = "Africa/Douala";

    @Column("language")
    @JsonProperty("language")
    private String language = "fr";

    // === BRANDING ===
    @Column("logo_url")
    @JsonProperty("logo_url")
    private String logoUrl;

    @Column("primary_color")
    @JsonProperty("primary_color")
    private String primaryColor = "#3b82f6";

    @Column("secondary_color")
    @JsonProperty("secondary_color")
    private String secondaryColor = "#1e40af";

    // === POLITIQUES (stockées en JSON) ===
    @Column("policies")
    @JsonProperty("policies")
    private String policies; // JSON des politiques d'organisation

    // === PARAMÈTRES (stockés en JSON) ===
    @Column("settings")
    @JsonProperty("settings")
    private String settings; // JSON des paramètres d'organisation

    // === ABONNEMENT ===
    @Column("subscription_plan_id")
    @JsonProperty("subscription_plan_id")
    private UUID subscriptionPlanId;

    @Column("subscription_expires_at")
    @JsonProperty("subscription_expires_at")
    private LocalDateTime subscriptionExpiresAt;

    @Column("subscription_auto_renew")
    @JsonProperty("subscription_auto_renew")
    private Boolean subscriptionAutoRenew = true;

    // === STATISTIQUES ===
    @Column("total_rentals")
    @JsonProperty("total_rentals")
    private Integer totalRentals = 0;

    @Column("monthly_revenue")
    @JsonProperty("monthly_revenue")
    private Double monthlyRevenue = 0.0;

    @Column("yearly_revenue")
    @JsonProperty("yearly_revenue")
    private Double yearlyRevenue = 0.0;

    @Column("last_activity_at")
    @JsonProperty("last_activity_at")
    private LocalDateTime lastActivityAt;

    // Constructors
    public Organization(String name, OrganizationType type, UUID ownerId) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.organizationType = type;
        this.ownerId = ownerId;
        this.lastActivityAt = LocalDateTime.now();
        prePersist();
    }

    // === MÉTHODES UTILITAIRES ===

    /**
     * Obtient l'adresse complète
     */
    @JsonProperty("full_address")
    public String getFullAddress() {
        StringBuilder address = new StringBuilder(this.address);
        if (city != null) address.append(", ").append(city);
        if (region != null) address.append(", ").append(region);
        if (country != null) address.append(", ").append(country);
        return address.toString();
    }

    /**
     * Vérifie si l'organisation peut créer une nouvelle agence
     */
    @JsonProperty("can_create_agency")
    public boolean canCreateAgency() {
        return currentAgencies != null && maxAgencies != null && currentAgencies < maxAgencies;
    }

    /**
     * Vérifie si l'organisation peut ajouter un véhicule
     */
    @JsonProperty("can_add_vehicle")
    public boolean canAddVehicle() {
        return currentVehicles != null && maxVehicles != null && currentVehicles < maxVehicles;
    }

    /**
     * Vérifie si l'organisation peut ajouter un chauffeur
     */
    @JsonProperty("can_add_driver")
    public boolean canAddDriver() {
        return currentDrivers != null && maxDrivers != null && currentDrivers < maxDrivers;
    }

    /**
     * Vérifie si l'organisation peut ajouter un utilisateur
     */
    @JsonProperty("can_add_user")
    public boolean canAddUser() {
        return currentUsers != null && maxUsers != null && currentUsers < maxUsers;
    }

    /**
     * Calcul du pourcentage d'utilisation des agences
     */
    @JsonProperty("agency_usage_percentage")
    public double getAgencyUsagePercentage() {
        if (maxAgencies == null || maxAgencies == 0) return 0.0;
        return (currentAgencies != null ? currentAgencies : 0) * 100.0 / maxAgencies;
    }

    /**
     * Calcul du pourcentage d'utilisation des véhicules
     */
    @JsonProperty("vehicle_usage_percentage")
    public double getVehicleUsagePercentage() {
        if (maxVehicles == null || maxVehicles == 0) return 0.0;
        return (currentVehicles != null ? currentVehicles : 0) * 100.0 / maxVehicles;
    }

    /**
     * Calcul du pourcentage d'utilisation des chauffeurs
     */
    @JsonProperty("driver_usage_percentage")
    public double getDriverUsagePercentage() {
        if (maxDrivers == null || maxDrivers == 0) return 0.0;
        return (currentDrivers != null ? currentDrivers : 0) * 100.0 / maxDrivers;
    }

    /**
     * Calcul du pourcentage d'utilisation des utilisateurs
     */
    @JsonProperty("user_usage_percentage")
    public double getUserUsagePercentage() {
        if (maxUsers == null || maxUsers == 0) return 0.0;
        return (currentUsers != null ? currentUsers : 0) * 100.0 / maxUsers;
    }

    /**
     * Vérifie si l'abonnement est actif
     */
    @JsonProperty("is_subscription_active")
    public boolean isSubscriptionActive() {
        return subscriptionExpiresAt != null && subscriptionExpiresAt.isAfter(LocalDateTime.now());
    }

    /**
     * Vérifie si l'abonnement expire bientôt (dans les 30 jours)
     */
    @JsonProperty("is_subscription_expiring_soon")
    public boolean isSubscriptionExpiringSoon() {
        return subscriptionExpiresAt != null &&
            subscriptionExpiresAt.isAfter(LocalDateTime.now()) &&
            subscriptionExpiresAt.isBefore(LocalDateTime.now().plusDays(30));
    }

    /**
     * Met à jour l'activité de l'organisation
     */
    public void updateActivity() {
        this.lastActivityAt = LocalDateTime.now();
        preUpdate();
    }

    /**
     * Incrémente le compteur d'agences
     */
    public void incrementAgencies() {
        this.currentAgencies = (currentAgencies != null ? currentAgencies : 0) + 1;
        updateActivity();
    }

    /**
     * Décrémente le compteur d'agences
     */
    public void decrementAgencies() {
        this.currentAgencies = Math.max(0, (currentAgencies != null ? currentAgencies : 0) - 1);
        updateActivity();
    }

    /**
     * Met à jour les compteurs de ressources
     */
    public void updateResourceCounters(int agencies, int vehicles, int drivers, int users) {
        this.currentAgencies = agencies;
        this.currentVehicles = vehicles;
        this.currentDrivers = drivers;
        this.currentUsers = users;
        updateActivity();
    }

    /**
     * Met à jour les statistiques financières
     */
    public void updateFinancialStats(double monthlyRevenue, double yearlyRevenue, int totalRentals) {
        this.monthlyRevenue = monthlyRevenue;
        this.yearlyRevenue = yearlyRevenue;
        this.totalRentals = totalRentals;
        updateActivity();
    }

    /**
     * Vérifie l'organisation
     */
    public void verify(UUID verifiedBy) {
        this.isVerified = true;
        this.verificationDate = LocalDateTime.now();
        this.verifiedBy = verifiedBy;
        preUpdate();
    }

    /**
     * Met à jour l'abonnement
     */
    public void updateSubscription(UUID planId, LocalDateTime expiresAt, boolean autoRenew) {
        this.subscriptionPlanId = planId;
        this.subscriptionExpiresAt = expiresAt;
        this.subscriptionAutoRenew = autoRenew;
        preUpdate();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\OrganizationSubscription.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.SubscriptionStatus;
import inc.yowyob.rental_api_reactive.application.dto.PaymentMethod;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Table("organization_subscriptions")
public class OrganizationSubscription extends BaseEntity {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    @NotNull(message = "Organization ID is required")
    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @NotNull(message = "Subscription plan ID is required")
    @Column("subscription_plan_id")
    @JsonProperty("subscription_plan_id")
    private UUID subscriptionPlanId;

    @NotNull(message = "Status is required")
    @Column("status")
    @JsonProperty("status")
    private SubscriptionStatus status = SubscriptionStatus.ACTIVE;

    @NotNull(message = "Start date is required")
    @Column("start_date")
    @JsonProperty("start_date")
    private LocalDateTime startDate;

    @NotNull(message = "End date is required")
    @Column("end_date")
    @JsonProperty("end_date")
    private LocalDateTime endDate;

    @Column("auto_renew")
    @JsonProperty("auto_renew")
    private Boolean autoRenew = true;

    @Column("payment_method")
    @JsonProperty("payment_method")
    private PaymentMethod paymentMethod;

    @Column("payment_reference")
    @JsonProperty("payment_reference")
    private String paymentReference;

    @NotNull(message = "Amount is required")
    @DecimalMin(value = "0.0", inclusive = true, message = "Amount must be greater than or equal to 0")
    @Column("amount")
    @JsonProperty("amount")
    private BigDecimal amount;

    @Column("currency")
    @JsonProperty("currency")
    private String currency = "XAF";

    @Column("next_billing_date")
    @JsonProperty("next_billing_date")
    private LocalDateTime nextBillingDate;

    @Column("cancelled_at")
    @JsonProperty("cancelled_at")
    private LocalDateTime cancelledAt;

    @Column("cancelled_by")
    @JsonProperty("cancelled_by")
    private UUID cancelledBy;

    @Column("cancellation_reason")
    @JsonProperty("cancellation_reason")
    private String cancellationReason;

    // Constructors
    public OrganizationSubscription(UUID organizationId, UUID subscriptionPlanId, BigDecimal amount, PaymentMethod paymentMethod) {
        this.id = UUID.randomUUID();
        this.organizationId = organizationId;
        this.subscriptionPlanId = subscriptionPlanId;
        this.startDate = startDate;
        this.endDate = endDate;
        this.amount = amount;
        this.paymentMethod = paymentMethod;
        prePersist();
    }

    /**
     * Vérifie si l'abonnement est actif
     */
    @JsonProperty("is_active")
    public boolean isActive() {
        return status == SubscriptionStatus.ACTIVE &&
            LocalDateTime.now().isBefore(endDate);
    }

    /**
     * Vérifie si l'abonnement a expiré
     */
    @JsonProperty("is_expired")
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(endDate);
    }

    /**
     * Calcule les jours restants
     */
    @JsonProperty("days_remaining")
    public long getDaysRemaining() {
        if (isExpired()) return 0;
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), endDate);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\Role.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.RoleType;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Table("roles")
public class Role extends BaseEntity {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    @NotBlank(message = "Role name is required")
    @Size(min = 2, max = 100, message = "Role name must be between 2 and 100 characters")
    @Column("name")
    @JsonProperty("name")
    private String name;

    @Size(max = 255, message = "Description must not exceed 255 characters")
    @Column("description")
    @JsonProperty("description")
    private String description;

    @NotNull(message = "Organization ID is required")
    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @Column("role_type")
    @JsonProperty("role_type")
    private RoleType roleType = RoleType.CUSTOM;

    @Column("is_system_role")
    @JsonProperty("is_system_role")
    private Boolean isSystemRole = false;

    @Column("is_default_role")
    @JsonProperty("is_default_role")
    private Boolean isDefaultRole = false;

    @Column("priority")
    @JsonProperty("priority")
    private Integer priority = 0;

    @Column("permissions")
    @JsonProperty("permissions")
    private Set<String> permissions = new HashSet<>();

    @Column("color")
    @JsonProperty("color")
    private String color;

    @Column("icon")
    @JsonProperty("icon")
    private String icon;

    @Column("created_by")
    @JsonProperty("created_by")
    private UUID createdBy;

    @Column("updated_by")
    @JsonProperty("updated_by")
    private UUID updatedBy;

    // Constructors
    public Role(String name, String description, UUID organizationId) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.description = description;
        this.organizationId = organizationId;
        prePersist();
    }

    public Role(String name, String description, UUID organizationId, RoleType roleType) {
        this(name, description, organizationId);
        this.roleType = roleType;
        this.isSystemRole = roleType != null && roleType.isSystemRole();
    }

    /**
     * Ajoute une permission au rôle
     */
    public void addPermission(String permissionCode) {
        if (permissionCode != null && !permissionCode.trim().isEmpty()) {
            if (this.permissions == null) {
                this.permissions = new HashSet<>();
            }
            this.permissions.add(permissionCode);
        }
    }

    /**
     * Supprime une permission du rôle
     */
    public void removePermission(String permissionCode) {
        if (this.permissions != null) {
            this.permissions.remove(permissionCode);
        }
    }

    /**
     * Vérifie si le rôle a une permission spécifique
     */
    @JsonProperty("has_permission")
    public boolean hasPermission(String permissionCode) {
        return this.permissions != null && this.permissions.contains(permissionCode);
    }

    /**
     * Vérifie si le rôle peut être modifié
     */
    @JsonProperty("can_be_modified")
    public boolean canBeModified() {
        return !isSystemRole;
    }

    /**
     * Vérifie si le rôle peut être supprimé
     */
    @JsonProperty("can_be_deleted")
    public boolean canBeDeleted() {
        return !isSystemRole && !isDefaultRole;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\SubscriptionPlan.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.math.BigDecimal;
import java.util.Map;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Table("subscription_plans")
public class SubscriptionPlan extends BaseEntity {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    @NotBlank(message = "Plan name is required")
    @Size(min = 2, max = 100, message = "Plan name must be between 2 and 100 characters")
    @Column("name")
    @JsonProperty("name")
    private String name;

    @Size(max = 500, message = "Description must not exceed 500 characters")
    @Column("description")
    @JsonProperty("description")
    private String description;

    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be greater than 0")
    @Column("price")
    @JsonProperty("price")
    private BigDecimal price;

    @NotBlank(message = "Currency is required")
    @Column("currency")
    @JsonProperty("currency")
    private String currency = "XAF";

    @NotNull(message = "Duration in days is required")
    @Min(value = 1, message = "Duration must be at least 1 day")
    @Column("duration_days")
    @JsonProperty("duration_days")
    private Integer durationDays;

    // Limites du plan
    @Column("max_vehicles")
    @JsonProperty("max_vehicles")
    private Integer maxVehicles;

    @Column("max_drivers")
    @JsonProperty("max_drivers")
    private Integer maxDrivers;

    @Column("max_agencies")
    @JsonProperty("max_agencies")
    private Integer maxAgencies;

    @Column("max_users")
    @JsonProperty("max_users")
    private Integer maxUsers;

    // Fonctionnalités
    @Column("features")
    @JsonProperty("features")
    private Map<String, Object> features;

    @Column("is_popular")
    @JsonProperty("is_popular")
    private Boolean isPopular = false;

    @Column("is_custom")
    @JsonProperty("is_custom")
    private Boolean isCustom = false;

    @Column("sort_order")
    @JsonProperty("sort_order")
    private Integer sortOrder = 0;

    @Column("hasGeofencing")
    @JsonProperty("hasGeofencing")
    private Boolean hasGeofencing = false;

    @Column("hasChat")
    @JsonProperty("hasChat")
    private Boolean hasChat = false;

    @Column("hasAnalytics")
    @JsonProperty("hasAnalytics")
    private Boolean hasAnalytics = false;

    // Constructors
    public SubscriptionPlan(String name, BigDecimal price, String currency, Integer durationDays) {
        this.id = UUID.randomUUID();
        this.name = name;
        this.price = price;
        this.currency = currency;
        this.durationDays = durationDays;
        prePersist();
    }

    /**
     * Vérifie si le plan est gratuit
     */
    @JsonProperty("is_free")
    public boolean isFree() {
        return price.compareTo(BigDecimal.ZERO) == 0;
    }

    /**
     * Calcule le prix par jour
     */
    @JsonProperty("price_per_day")
    public BigDecimal getPricePerDay() {
        return price.divide(BigDecimal.valueOf(durationDays), 2, BigDecimal.ROUND_HALF_UP);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\User.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.*;
import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Entité User mise à jour pour supporter le personnel
 * Route: src/main/java/inc/yowyob/rental_api_reactive/persistence/entity/User.java
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("users")
public class User {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    // === INFORMATIONS DE BASE ===
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Column("email")
    @JsonProperty("email")
    private String email;

    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    @Column("password")
    @JsonProperty("password")
    private String password;

    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    @Column("first_name")
    @JsonProperty("firstName")
    private String firstName;

    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    @Column("last_name")
    @JsonProperty("lastName")
    private String lastName;

    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Phone number should be valid")
    @Column("phone")
    @JsonProperty("phone")
    private String phone;

    @NotNull(message = "User type is required")
    @Column("user_type")
    @JsonProperty("userType")
    private UserType userType;

    // === INFORMATIONS ORGANISATION/AGENCE ===
    @Column("organization_id")
    @JsonProperty("organizationId")
    private UUID organizationId;

    @Column("agency_id")
    @JsonProperty("agencyId")
    private UUID agencyId;

    // === INFORMATIONS PROFIL ===
    @Column("profile_picture")
    @JsonProperty("profilePicture")
    private String profilePicture;

    @Column("address")
    @JsonProperty("address")
    private String address;

    @Column("city")
    @JsonProperty("city")
    private String city;

    @Column("country")
    @JsonProperty("country")
    private String country;

    // === VÉRIFICATIONS ===
    @Column("is_email_verified")
    @JsonProperty("isEmailVerified")
    private Boolean isEmailVerified = false;

    @Column("is_phone_verified")
    @JsonProperty("isPhoneVerified")
    private Boolean isPhoneVerified = false;

    @Column("email_verification_token")
    @JsonProperty("emailVerificationToken")
    private String emailVerificationToken;

    @Column("email_verification_expiry")
    @JsonProperty("emailVerificationExpiry")
    private LocalDateTime emailVerificationExpiry;

    @Column("phone_verification_code")
    @JsonProperty("phoneVerificationCode")
    private String phoneVerificationCode;

    @Column("phone_verification_expiry")
    @JsonProperty("phoneVerificationExpiry")
    private LocalDateTime phoneVerificationExpiry;

    // === SÉCURITÉ MOT DE PASSE ===
    @Column("password_reset_token")
    @JsonProperty("passwordResetToken")
    private String passwordResetToken;

    @Column("password_reset_expiry")
    @JsonProperty("passwordResetExpiry")
    private LocalDateTime passwordResetExpiry;

    @Column("must_change_password")
    @JsonProperty("mustChangePassword")
    private Boolean mustChangePassword = false;

    // === SÉCURITÉ COMPTE ===
    @Column("last_login_at")
    @JsonProperty("lastLoginAt")
    private LocalDateTime lastLoginAt;

    @Column("last_login_ip")
    @JsonProperty("lastLoginIp")
    private String lastLoginIp;

    @Column("failed_login_attempts")
    @JsonProperty("failedLoginAttempts")
    private Integer failedLoginAttempts = 0;

    @Column("locked_until")
    @JsonProperty("lockedUntil")
    private LocalDateTime lockedUntil;

    // === INFORMATIONS EMPLOYÉ (PERSONNEL) ===
    @Column("employee_id")
    @JsonProperty("employeeId")
    private String employeeId; // ID employé interne à l'organisation

    @Column("department")
    @JsonProperty("department")
    private String department; // Service/Département

    @Column("position")
    @JsonProperty("position")
    private String position; // Poste/Fonction

    @Column("supervisor_id")
    @JsonProperty("supervisorId")
    private UUID supervisorId; // Superviseur direct

    @Column("hired_at")
    @JsonProperty("hiredAt")
    private LocalDateTime hiredAt; // Date d'embauche

    @Column("salary")
    @JsonProperty("salary")
    private java.math.BigDecimal salary; // Salaire (optionnel)

    @Column("contract_type")
    @JsonProperty("contractType")
    private String contractType; // Type de contrat (CDI, CDD, etc.)

    // === PRÉFÉRENCES UTILISATEUR ===
    @Column("preferred_language")
    @JsonProperty("preferredLanguage")
    private String preferredLanguage = "fr";

    @Column("timezone")
    @JsonProperty("timezone")
    private String timezone = "Africa/Douala";

    @Column("theme")
    @JsonProperty("theme")
    private String theme = "light"; // light, dark

    @Column("currency")
    @JsonProperty("currency")
    private String currency = "XAF";

    @Column("date_format")
    @JsonProperty("dateFormat")
    private String dateFormat = "DD/MM/YYYY";

    // === NOTIFICATIONS ===
    @Column("email_notifications")
    @JsonProperty("emailNotifications")
    private Boolean emailNotifications = true;

    @Column("sms_notifications")
    @JsonProperty("smsNotifications")
    private Boolean smsNotifications = false;

    @Column("push_notifications")
    @JsonProperty("pushNotifications")
    private Boolean pushNotifications = true;

    // === STATUTS ===
    @Column("is_active")
    @JsonProperty("isActive")
    private Boolean isActive = true;

    @Column("is_deleted")
    @JsonProperty("isDeleted")
    private Boolean isDeleted = false;

    @Column("deleted_at")
    @JsonProperty("deletedAt")
    private LocalDateTime deletedAt;

    // === AUDIT ===
    @Column("created_at")
    @JsonProperty("createdAt")
    private LocalDateTime createdAt;

    @Column("updated_at")
    @JsonProperty("updatedAt")
    private LocalDateTime updatedAt;

    @Column("created_by")
    @JsonProperty("createdBy")
    private UUID createdBy;

    @Column("updated_by")
    @JsonProperty("updatedBy")
    private UUID updatedBy;

    // === CONSTRUCTEURS ===
    public User(String email, String password, String firstName, String lastName, UserType userType) {
        this.id = UUID.randomUUID();
        this.email = email;
        this.password = password;
        this.firstName = firstName;
        this.lastName = lastName;
        this.userType = userType;
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    // === MÉTHODES UTILITAIRES ===

    /**
     * Obtient le nom complet de l'utilisateur
     */
    @JsonProperty("fullName")
    public String getFullName() {
        return firstName + " " + lastName;
    }

    /**
     * Vérifie si l'utilisateur est un propriétaire d'organisation
     */
    public boolean isOrganizationOwner() {
        return userType == UserType.ORGANIZATION_OWNER;
    }

    /**
     * Vérifie si l'utilisateur est du personnel
     */
    public boolean isPersonnel() {
        return userType == UserType.AGENCY_MANAGER ||
            userType == UserType.RENTAL_AGENT;
    }

    /**
     * Vérifie si l'utilisateur est un client
     */
    public boolean isClient() {
        return userType == UserType.CLIENT;
    }

    /**
     * Vérifie si l'utilisateur est un administrateur
     */
    public boolean isAdmin() {
        return userType == UserType.SUPER_ADMIN ||
            userType == UserType.ORGANIZATION_OWNER;
    }

    /**
     * Vérifie si l'utilisateur peut gérer une agence
     */
    public boolean canManageAgency() {
        return userType == UserType.ORGANIZATION_OWNER ||
            userType == UserType.AGENCY_MANAGER;
    }

    /**
     * Vérifie si l'utilisateur peut effectuer des locations
     */
    public boolean canHandleRentals() {
        return userType == UserType.AGENCY_MANAGER ||
            userType == UserType.RENTAL_AGENT;
    }

    /**
     * Vérifie si le compte est verrouillé
     */
    public boolean isLocked() {
        return lockedUntil != null && lockedUntil.isAfter(LocalDateTime.now());
    }

    /**
     * Vérifie si l'utilisateur peut se connecter
     */
    public boolean canLogin() {
        return isActive && !isDeleted && !isLocked();
    }

    /**
     * Vérifie si l'utilisateur est assigné à une agence
     */
    public boolean isAssignedToAgency() {
        return agencyId != null;
    }

    /**
     * Obtient le niveau hiérarchique de l'utilisateur
     */
    public int getHierarchyLevel() {
        return userType.getHierarchyLevel();
    }

    /**
     * Méthode appelée avant la persistance
     */
    public void prePersist() {
        if (id == null) {
            id = UUID.randomUUID();
        }
        LocalDateTime now = LocalDateTime.now();
        if (createdAt == null) {
            createdAt = now;
        }
        updatedAt = now;
    }

    /**
     * Méthode appelée avant la mise à jour
     */
    public void preUpdate() {
        updatedAt = LocalDateTime.now();
    }

    /**
     * Remet à zéro les tentatives de connexion échouées
     */
    public void resetFailedLoginAttempts() {
        failedLoginAttempts = 0;
        lockedUntil = null;
    }

    /**
     * Incrémente les tentatives de connexion échouées
     */
    public void incrementFailedLoginAttempts() {
        if (failedLoginAttempts == null) {
            failedLoginAttempts = 0;
        }
        failedLoginAttempts++;

        // Verrouiller après 5 tentatives
        if (failedLoginAttempts >= 5) {
            lockedUntil = LocalDateTime.now().plusHours(1);
        }
    }

    /**
     * Marque l'utilisateur comme supprimé (soft delete)
     */
    public void markAsDeleted(UUID deletedBy) {
        isDeleted = true;
        isActive = false;
        deletedAt = LocalDateTime.now();
        updatedBy = deletedBy;
        updatedAt = LocalDateTime.now();
    }

    /**
     * Restaure un utilisateur supprimé
     */
    public void restore(UUID restoredBy) {
        isDeleted = false;
        isActive = true;
        deletedAt = null;
        updatedBy = restoredBy;
        updatedAt = LocalDateTime.now();
    }

    /**
     * Met à jour les informations d'employé
     */
    public void updateEmployeeInfo(String employeeId, String department, String position, UUID supervisorId) {
        this.employeeId = employeeId;
        this.department = department;
        this.position = position;
        this.supervisorId = supervisorId;
        preUpdate();
    }

    /**
     * Assigne l'utilisateur à une agence
     */
    public void assignToAgency(UUID agencyId, UUID assignedBy) {
        this.agencyId = agencyId;
        this.updatedBy = assignedBy;
        preUpdate();
    }

    /**
     * Désassigne l'utilisateur d'une agence
     */
    public void unassignFromAgency(UUID unassignedBy) {
        this.agencyId = null;
        this.updatedBy = unassignedBy;
        preUpdate();
    }

    /**
     * Met à jour les informations de dernière connexion
     */
    public void updateLastLogin(String ipAddress) {
        lastLoginAt = LocalDateTime.now();
        lastLoginIp = ipAddress;
        resetFailedLoginAttempts();
        preUpdate();
    }

    /**
     * Active la vérification email
     */
    public void setEmailVerificationToken(String token) {
        emailVerificationToken = token;
        emailVerificationExpiry = LocalDateTime.now().plusDays(1);
    }

    /**
     * Marque l'email comme vérifié
     */
    public void verifyEmail() {
        isEmailVerified = true;
        emailVerificationToken = null;
        emailVerificationExpiry = null;
        preUpdate();
    }

    /**
     * Active la réinitialisation du mot de passe
     */
    public void setPasswordResetToken(String token) {
        passwordResetToken = token;
        passwordResetExpiry = LocalDateTime.now().plusHours(1);
    }

    /**
     * Réinitialise le mot de passe
     */
    public void resetPassword(String newPassword) {
        password = newPassword;
        passwordResetToken = null;
        passwordResetExpiry = null;
        mustChangePassword = false;
        preUpdate();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\entity\UserRole.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.entity;

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.*;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
@Table("user_roles")
public class UserRole extends BaseEntity {

    @PrimaryKey
    @JsonProperty("id")
    private UUID id;

    @NotNull(message = "User ID is required")
    @Column("user_id")
    @JsonProperty("user_id")
    private UUID userId;

    @NotNull(message = "Role ID is required")
    @Column("role_id")
    @JsonProperty("role_id")
    private UUID roleId;

    @NotNull(message = "Organization ID is required")
    @Column("organization_id")
    @JsonProperty("organization_id")
    private UUID organizationId;

    @Column("agency_id")
    @JsonProperty("agency_id")
    private UUID agencyId;

    @Column("assigned_at")
    @JsonProperty("assigned_at")
    private LocalDateTime assignedAt;

    @Column("expires_at")
    @JsonProperty("expires_at")
    private LocalDateTime expiresAt;

    @Column("assigned_by")
    @JsonProperty("assigned_by")
    private UUID assignedBy;

    @Column("revoked_at")
    @JsonProperty("revoked_at")
    private LocalDateTime revokedAt;

    @Column("revoked_by")
    @JsonProperty("revoked_by")
    private UUID revokedBy;

    // Constructors
    public UserRole(UUID userId, UUID roleId, UUID organizationId) {
        this.id = UUID.randomUUID();
        this.userId = userId;
        this.roleId = roleId;
        this.organizationId = organizationId;
        this.assignedAt = LocalDateTime.now();
        prePersist();
    }

    public UserRole(UUID userId, UUID roleId, UUID organizationId, UUID agencyId) {
        this(userId, roleId, organizationId);
        this.agencyId = agencyId;
    }

    /**
     * Vérifie si l'assignation est expirée
     */
    @JsonProperty("is_expired")
    public boolean isExpired() {
        return expiresAt != null && LocalDateTime.now().isAfter(expiresAt);
    }

    /**
     * Vérifie si l'assignation est active (utilise isActive de BaseEntity)
     */
    @JsonProperty("is_currently_active")
    public boolean isCurrentlyActive() {
        return getIsActive() && !isExpired();
    }

    /**
     * Révoque l'assignation du rôle
     */
    public void revoke(UUID revokedBy) {
        this.setIsActive(false);
        this.revokedAt = LocalDateTime.now();
        this.revokedBy = revokedBy;
        preUpdate();
    }

    /**
     * Active l'assignation du rôle
     */
    public void activate() {
        this.setIsActive(true);
        this.revokedAt = null;
        this.revokedBy = null;
        preUpdate();
    }

    /**
     * Définit une date d'expiration
     */
    public void setExpiration(LocalDateTime expiresAt) {
        this.expiresAt = expiresAt;
        preUpdate();
    }

    /**
     * Vérifie si l'assignation a été révoquée
     */
    @JsonProperty("is_revoked")
    public boolean isRevoked() {
        return revokedAt != null && revokedBy != null;
    }

    /**
     * Vérifie si l'assignation est temporaire (avec date d'expiration)
     */
    @JsonProperty("is_temporary")
    public boolean isTemporary() {
        return expiresAt != null;
    }

    /**
     * Obtient le nombre de jours restants avant expiration
     */
    @JsonProperty("days_until_expiration")
    public Long getDaysUntilExpiration() {
        if (expiresAt == null) {
            return null;
        }
        return java.time.temporal.ChronoUnit.DAYS.between(LocalDateTime.now(), expiresAt);
    }

    /**
     * Vérifie si l'assignation expire bientôt (dans les 7 prochains jours)
     */
    @JsonProperty("expires_soon")
    public boolean expiresSoon() {
        if (expiresAt == null) {
            return false;
        }
        Long daysUntilExpiration = getDaysUntilExpiration();
        return daysUntilExpiration != null && daysUntilExpiration <= 7 && daysUntilExpiration > 0;
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\mapper\AgencyMapper.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.mapper;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.Agency;
import org.mapstruct.*;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.Collections;
import java.util.Map;

/**
 * Mapper pour les agences.
 */
@Mapper(componentModel = "spring",
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE,
    uses = {ObjectMapper.class})
public abstract class AgencyMapper {

    @Autowired
    private ObjectMapper objectMapper;

    @Mapping(target = "fullAddress", expression = "java(agency.getFullAddress())")
    @Mapping(target = "hasLocation", expression = "java(agency.hasLocation())")
    @Mapping(target = "hasGeofencing", expression = "java(agency.hasGeofencing())")
    @Mapping(target = "isCurrentlyOpen", expression = "java(agency.isCurrentlyOpen())")
    @Mapping(target = "vehicleUtilizationRate", expression = "java(agency.getVehicleUtilizationRate())")
    @Mapping(target = "driverActivityRate", expression = "java(agency.getDriverActivityRate())")
    public abstract AgencyResponse toResponse(Agency agency);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "isActive", ignore = true)
    @Mapping(target = "totalVehicles", ignore = true)
    @Mapping(target = "activeVehicles", ignore = true)
    @Mapping(target = "totalDrivers", ignore = true)
    @Mapping(target = "activeDrivers", ignore = true)
    @Mapping(target = "totalPersonnel", ignore = true)
    @Mapping(target = "totalRentals", ignore = true)
    @Mapping(target = "monthlyRevenue", ignore = true)
    public abstract Agency toEntity(CreateAgencyRequest request);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "organizationId", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "isActive", ignore = true)
    public abstract void updateEntityFromRequest(UpdateAgencyRequest request, @MappingTarget Agency agency);

    /**
     * Convertit un JSON String en Map.
     * Gère l'erreur de parsing.
     */
    protected Map<String, WorkingHoursInfo> mapWorkingHours(String workingHoursJson) {
        if (workingHoursJson == null || workingHoursJson.isEmpty()) {
            return Collections.emptyMap();
        }
        try {
            // Assurez-vous d'avoir un DTO WorkingHoursInfo
            return objectMapper.readValue(workingHoursJson, new TypeReference<Map<String, WorkingHoursInfo>>() {});
        } catch (JsonProcessingException e) {
            return Collections.emptyMap();
        }
    }

    /**
     * Convertit une Map en JSON String.
     */
    protected String mapWorkingHoursToString(Map<String, WorkingHoursInfo> workingHours) {
        if (workingHours == null || workingHours.isEmpty()) {
            return null;
        }
        try {
            return objectMapper.writeValueAsString(workingHours);
        } catch (JsonProcessingException e) {
            return null;
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\mapper\DriverMapper.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.mapper;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.DriverResponse;
import inc.yowyob.rental_api_reactive.persistence.entity.Driver;
import inc.yowyob.rental_api_reactive.persistence.entity.User;

import org.mapstruct.BeanMapping;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;

@Mapper(componentModel = "spring")
public interface DriverMapper {

    // Mappages des identifiants
    @Mapping(target = "driverId", source = "driver.driverId")
    @Mapping(target = "userId", source = "driver.userId")
    @Mapping(target = "organizationId", source = "driver.organizationId")
    @Mapping(target = "agencyId", source = "driver.agencyId")

    // Mapping depuis l'entité User
    @Mapping(target = "firstName", source = "user.firstName")
    @Mapping(target = "lastName", source = "user.lastName")
    @Mapping(target = "email", source = "user.email")
    @Mapping(target = "phone", source = "user.phone")
    // CORRECTION 1: user.profilePicture (nom dans l'entité User) vers profileImageUrl (nom dans DriverResponse)
    @Mapping(target = "profileImageUrl", source = "user.profilePicture")
    @Mapping(target = "userType", source = "user.userType")

    // Mappages depuis l'entité Driver
    @Mapping(target = "dateOfBirth", source = "driver.dateOfBirth")
    @Mapping(target = "licenseNumber", source = "driver.licenseNumber")
    @Mapping(target = "licenseType", source = "driver.licenseType")
    // CORRECTION 2: driver.licenseExpiry (nom dans l'entité Driver) vers licenseExpiryDate (nom dans DriverResponse)
    // @Mapping(target = "licenseExpiryDate", source = "driver.licenseExpiry")
    @Mapping(target = "experienceYears", source = "driver.experience")

    // Mappages des champs commentés (réactivés)
    // @Mapping(target = "location", source = "driver.location")
    // @Mapping(target = "idCardUrl", source = "driver.idCardUrl")
    // @Mapping(target = "driverLicenseUrl", source = "driver.driverLicenseUrl")
    // @Mapping(target = "assignedVehicleIds", source = "driver.assignedVehicleIds")
    // @Mapping(target = "available", source = "driver.available")
    @Mapping(target = "rating", source = "driver.rating")
    // @Mapping(target = "insuranceProvider", source = "driver.insuranceProvider")
    // @Mapping(target = "insurancePolicy", source = "driver.insurancePolicy")
    // // @Mapping(target = "status", source = "driver.status")

    // Mappages des informations Staff (depuis Driver)
    @Mapping(target = "employeeId", source = "driver.employeeId") // Mapping explicite (employeeId -> registrationId)
    @Mapping(target = "position", source = "driver.position")
    @Mapping(target = "hireDate", source = "driver.hireDate")
    @Mapping(target = "staffStatus", source = "driver.staffStatus")

    // Audit fields
    @Mapping(target = "createdAt", source = "driver.createdAt")
    @Mapping(target = "updatedAt", source = "driver.updatedAt")
    
    DriverResponse toDto(Driver driver, User user);

    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
    void updateEntityFromDto(DriverResponse dto, @MappingTarget Driver driver);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\mapper\DtoMapper.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.mapper;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import org.springframework.stereotype.Component;

/**
 * Mapper simple pour les DTOs (sans MapStruct pour plus de contrôle)
 */
@Component
public class DtoMapper {

    /**
     * Convertit les informations de sécurité utilisateur en contexte de sécurité
     */
    public SecurityContext toSecurityContext(inc.yowyob.rental_api_reactive.persistence.entity.User user) {
        if (user == null) return null;

        return SecurityContext.builder()
            .userId(user.getId())
            .userType(user.getUserType())
            .organizationId(user.getOrganizationId())
            .agencyId(user.getAgencyId())
            .email(user.getEmail())
            .fullName(user.getFullName())
            .isActive(user.getIsActive())
            .isEmailVerified(user.getIsEmailVerified())
            .build();
    }

    /**
     * Convertit un filtre tenant
     */
    public TenantFilter toTenantFilter(inc.yowyob.rental_api_reactive.persistence.entity.User user) {
        if (user == null) return null;

        TenantFilter.TenantFilterBuilder builder = TenantFilter.builder()
            .userId(user.getId())
            .userType(user.getUserType());

        // Super admin voit tout
        if (user.getUserType() == inc.yowyob.rental_api_reactive.application.dto.UserType.SUPER_ADMIN) {
            builder.isGlobalAccess(true);
        } else {
            builder.organizationId(user.getOrganizationId());

            // Si l'utilisateur est lié à une agence spécifique
            if (user.getAgencyId() != null &&
                (user.getUserType() == inc.yowyob.rental_api_reactive.application.dto.UserType.AGENCY_MANAGER ||
                    user.getUserType() == inc.yowyob.rental_api_reactive.application.dto.UserType.RENTAL_AGENT)) {
                builder.agencyId(user.getAgencyId());
                builder.isAgencyRestricted(true);
            }
        }

        return builder.build();
    }

    /**
     * Convertit les statistiques d'agence
     */
    public AgencyStatisticsResponse toAgencyStatisticsResponse(inc.yowyob.rental_api_reactive.persistence.entity.Agency agency) {
        if (agency == null) return null;

        return AgencyStatisticsResponse.builder()
            .agencyId(agency.getId())
            .totalVehicles(agency.getTotalVehicles())
            .activeVehicles(agency.getActiveVehicles())
            .totalDrivers(agency.getTotalDrivers())
            .activeDrivers(agency.getActiveDrivers())
            .totalPersonnel(agency.getTotalPersonnel())
            .totalRentals(agency.getTotalRentals())
            .monthlyRevenue(agency.getMonthlyRevenue())
            .vehicleUtilizationRate(agency.getVehicleUtilizationRate())
            .driverActivityRate(agency.getDriverActivityRate())
            .lastUpdated(agency.getUpdatedAt())
            .build();
    }

    /**
     * Convertit les limites d'abonnement
     */
    public SubscriptionLimitsResponse toSubscriptionLimitsResponse(
        inc.yowyob.rental_api_reactive.persistence.entity.Organization organization,
        int activeAgencies) {

        if (organization == null) return null;

        return SubscriptionLimitsResponse.builder()
            .organizationId(organization.getId())
            .subscriptionActive(organization.isSubscriptionActive())
            .subscriptionExpiresAt(organization.getSubscriptionExpiresAt())
            .agencyLimits(ResourceLimitInfo.builder()
                .current(activeAgencies)
                .maximum(organization.getMaxAgencies())
                .available(organization.getMaxAgencies() - activeAgencies)
                .usagePercentage(organization.getAgencyUsagePercentage())
                .build())
            .vehicleLimits(ResourceLimitInfo.builder()
                .current(organization.getCurrentVehicles())
                .maximum(organization.getMaxVehicles())
                .available(organization.getMaxVehicles() - organization.getCurrentVehicles())
                .usagePercentage(organization.getVehicleUsagePercentage())
                .build())
            .driverLimits(ResourceLimitInfo.builder()
                .current(organization.getCurrentDrivers())
                .maximum(organization.getMaxDrivers())
                .available(organization.getMaxDrivers() - organization.getCurrentDrivers())
                .usagePercentage(organization.getDriverUsagePercentage())
                .build())
            .userLimits(ResourceLimitInfo.builder()
                .current(organization.getCurrentUsers())
                .maximum(organization.getMaxUsers())
                .available(organization.getMaxUsers() - organization.getCurrentUsers())
                .usagePercentage(organization.getUserUsagePercentage())
                .build())
            .build();
    }

    /**
     * Convertit les statistiques d'organisation
     */
    public OrganizationStatisticsResponse toOrganizationStatisticsResponse(
        inc.yowyob.rental_api_reactive.persistence.entity.Organization organization,
        int totalAgencies,
        int activeAgencies) {

        if (organization == null) return null;

        return OrganizationStatisticsResponse.builder()
            .organizationId(organization.getId())
            .totalAgencies(totalAgencies)
            .activeAgencies(activeAgencies)
            .maxAgencies(organization.getMaxAgencies())
            .totalVehicles(organization.getCurrentVehicles())
            .maxVehicles(organization.getMaxVehicles())
            .totalDrivers(organization.getCurrentDrivers())
            .maxDrivers(organization.getMaxDrivers())
            .totalUsers(organization.getCurrentUsers())
            .maxUsers(organization.getMaxUsers())
            .monthlyRevenue(organization.getMonthlyRevenue())
            .yearlyRevenue(organization.getYearlyRevenue())
            .totalRentals(organization.getTotalRentals())
            .agencyUsagePercentage(organization.getAgencyUsagePercentage())
            .vehicleUsagePercentage(organization.getVehicleUsagePercentage())
            .driverUsagePercentage(organization.getDriverUsagePercentage())
            .userUsagePercentage(organization.getUserUsagePercentage())
            .isSubscriptionActive(organization.isSubscriptionActive())
            .subscriptionExpiresAt(organization.getSubscriptionExpiresAt())
            .lastActivityAt(organization.getLastActivityAt())
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\mapper\OrganizationMapper.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.mapper;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.CreateOrganizationRequest;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.OrganizationPolicies;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.OrganizationResponse;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.OrganizationSettings;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.UpdateOrganizationRequest;
import inc.yowyob.rental_api_reactive.persistence.entity.Organization;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;
import org.springframework.beans.factory.annotation.Autowired;


/**
 * Mapper pour les organisations, utilisant une classe abstraite pour la conversion JSON.
 */
@Mapper(componentModel = "spring",
    nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public abstract class OrganizationMapper {

    @Autowired
    private ObjectMapper objectMapper;

    // La méthode toResponse nécessite des méthodes custom pour policies et settings
    @Mapping(target = "fullAddress", expression = "java(organization.getFullAddress())")
    @Mapping(target = "canCreateAgency", expression = "java(organization.canCreateAgency())")
    @Mapping(target = "canAddVehicle", expression = "java(organization.canAddVehicle())")
    @Mapping(target = "canAddDriver", expression = "java(organization.canAddDriver())")
    @Mapping(target = "canAddUser", expression = "java(organization.canAddUser())")
    @Mapping(target = "agencyUsagePercentage", expression = "java(organization.getAgencyUsagePercentage())")
    @Mapping(target = "vehicleUsagePercentage", expression = "java(organization.getVehicleUsagePercentage())")
    @Mapping(target = "driverUsagePercentage", expression = "java(organization.getDriverUsagePercentage())")
    @Mapping(target = "userUsagePercentage", expression = "java(organization.getUserUsagePercentage())")
    @Mapping(target = "isSubscriptionActive", expression = "java(organization.isSubscriptionActive())")
    @Mapping(target = "isSubscriptionExpiringSoon", expression = "java(organization.isSubscriptionExpiringSoon())")
    @Mapping(target = "createdBy", ignore = true)
    @Mapping(target = "updatedBy", ignore = true)
    public abstract OrganizationResponse toResponse(Organization organization);


    // La méthode toEntity nécessite des méthodes custom pour policies et settings
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "ownerId", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "isActive", ignore = true)
    @Mapping(target = "isVerified", ignore = true)
    @Mapping(target = "verificationDate", ignore = true)
    @Mapping(target = "verifiedBy", ignore = true)
    @Mapping(target = "currentAgencies", ignore = true)
    @Mapping(target = "currentVehicles", ignore = true)
    @Mapping(target = "currentDrivers", ignore = true)
    @Mapping(target = "currentUsers", ignore = true)
    @Mapping(target = "totalRentals", ignore = true)
    @Mapping(target = "monthlyRevenue", ignore = true)
    @Mapping(target = "yearlyRevenue", ignore = true)
    @Mapping(target = "lastActivityAt", ignore = true)
    @Mapping(target = "subscriptionPlanId", ignore = true)
    @Mapping(target = "subscriptionExpiresAt", ignore = true)
    @Mapping(target = "subscriptionAutoRenew", ignore = true)
    @Mapping(target = "maxAgencies", ignore = true)
    @Mapping(target = "maxVehicles", ignore = true)
    @Mapping(target = "maxDrivers", ignore = true)
    @Mapping(target = "maxUsers", ignore = true)
    @Mapping(target = "logoUrl", ignore = true)
    // PAS besoin d'ignorer policies et settings car on fournit une méthode de conversion
    public abstract Organization toEntity(CreateOrganizationRequest request);


    // La méthode updateEntityFromRequest nécessite des méthodes custom pour policies et settings
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "ownerId", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "isActive", ignore = true)
    @Mapping(target = "isVerified", ignore = true)
    @Mapping(target = "verificationDate", ignore = true)
    @Mapping(target = "verifiedBy", ignore = true)
    @Mapping(target = "currentAgencies", ignore = true)
    @Mapping(target = "currentVehicles", ignore = true)
    @Mapping(target = "currentDrivers", ignore = true)
    @Mapping(target = "currentUsers", ignore = true)
    @Mapping(target = "lastActivityAt", ignore = true)
    @Mapping(target = "maxAgencies", ignore = true)
    @Mapping(target = "maxVehicles", ignore = true)
    @Mapping(target = "maxDrivers", ignore = true)
    @Mapping(target = "maxUsers", ignore = true)
    @Mapping(target = "logoUrl", ignore = true)
    @Mapping(target = "subscriptionPlanId", ignore = true)
    @Mapping(target = "subscriptionExpiresAt", ignore = true)
    @Mapping(target = "subscriptionAutoRenew", ignore = true)
    @Mapping(target = "totalRentals", ignore = true)
    @Mapping(target = "monthlyRevenue", ignore = true)
    @Mapping(target = "yearlyRevenue", ignore = true)
    public abstract void updateEntityFromRequest(UpdateOrganizationRequest request, @MappingTarget Organization organization);


    // === Méthodes de conversion JSON pour les Policies et Settings ===
    // MapStruct utilisera automatiquement ces méthodes quand il verra une conversion
    // entre un objet (ex: OrganizationPolicies) et une String.

    protected String mapPoliciesToString(OrganizationPolicies policies) {
        if (policies == null) return null;
        try {
            // Convertit l'objet OrganizationPolicies en une chaîne JSON
            return objectMapper.writeValueAsString(policies);
        } catch (JsonProcessingException e) {
            // Idéalement, loguer l'erreur
            return null;
        }
    }

    protected OrganizationPolicies mapPolicies(String policiesJson) {
        if (policiesJson == null || policiesJson.isEmpty()) return null;
        try {
            // Convertit la chaîne JSON en un objet OrganizationPolicies
            return objectMapper.readValue(policiesJson, OrganizationPolicies.class);
        } catch (JsonProcessingException e) {
            return null;
        }
    }

    protected String mapSettingsToString(OrganizationSettings settings) {
        if (settings == null) return null;
        try {
            // Convertit l'objet OrganizationSettings en une chaîne JSON
            return objectMapper.writeValueAsString(settings);
        } catch (JsonProcessingException e) {
            return null;
        }
    }

    protected OrganizationSettings mapSettings(String settingsJson) {
        if (settingsJson == null || settingsJson.isEmpty()) return null;
        try {
            // Convertit la chaîne JSON en un objet OrganizationSettings
            return objectMapper.readValue(settingsJson, OrganizationSettings.class);
        } catch (JsonProcessingException e) {
            return null;
        }
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\mapper\RoleMapper.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.mapper;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.RoleResponse;
import inc.yowyob.rental_api_reactive.persistence.entity.Role;
import org.springframework.stereotype.Component;

@Component
public class RoleMapper {

    public RoleResponse toResponse(Role role) {
        if (role == null) {
            return null;
        }

        return RoleResponse.builder()
            .id(role.getId())
            .name(role.getName())
            .description(role.getDescription())
            .organizationId(role.getOrganizationId())
            .roleType(role.getRoleType())
            .isSystemRole(role.getIsSystemRole())
            .isDefaultRole(role.getIsDefaultRole())
            .priority(role.getPriority())
            .permissions(role.getPermissions())
            .permissionCount(role.getPermissions() != null ? role.getPermissions().size() : 0)
            .color(role.getColor())
            .icon(role.getIcon())
            .canBeModified(role.canBeModified())
            .canBeDeleted(role.canBeDeleted())
            .createdAt(role.getCreatedAt())
            .updatedAt(role.getUpdatedAt())
            .createdBy(role.getCreatedBy())
            .updatedBy(role.getUpdatedBy())
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\mapper\UserRoleMapper.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.mapper;

import inc.yowyob.rental_api_reactive.infrastructure.web.dto.UserRoleResponse;
import inc.yowyob.rental_api_reactive.persistence.entity.UserRole;
import org.springframework.stereotype.Component;

@Component
public class UserRoleMapper {

    public UserRoleResponse toResponse(UserRole userRole) {
        if (userRole == null) {
            return null;
        }

        return UserRoleResponse.builder()
            .id(userRole.getId())
            .userId(userRole.getUserId())
            .roleId(userRole.getRoleId())
            .organizationId(userRole.getOrganizationId())
            .agencyId(userRole.getAgencyId())
            .assignedAt(userRole.getAssignedAt())
            .expiresAt(userRole.getExpiresAt())
            .isActive(userRole.getIsActive())
            .isExpired(userRole.isExpired())
            .assignedBy(userRole.getAssignedBy())
            .revokedAt(userRole.getRevokedAt())
            .revokedBy(userRole.getRevokedBy())
            .build();
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\AgencyReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.Agency;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

/**
 * Repository réactif pour l'entité Agency
 */
@Repository
public interface AgencyReactiveRepository extends ReactiveCassandraRepository<Agency, UUID> {

    /**
     * Trouve toutes les agences d'une organisation
     */
    @Query("SELECT * FROM agencies WHERE organization_id = ?0 ALLOW FILTERING")
    Flux<Agency> findByOrganizationId(UUID organizationId);

    /**
     * Trouve les agences actives d'une organisation
     */
    @Query("SELECT * FROM agencies WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Flux<Agency> findActiveByOrganizationId(UUID organizationId);

    /**
     * Trouve les agences par gestionnaire
     */
    @Query("SELECT * FROM agencies WHERE manager_id = ?0 ALLOW FILTERING")
    Flux<Agency> findByManagerId(UUID managerId);

    /**
     * Trouve les agences actives par gestionnaire
     */
    @Query("SELECT * FROM agencies WHERE manager_id = ?0 AND is_active = true ALLOW FILTERING")
    Flux<Agency> findActiveByManagerId(UUID managerId);

    /**
     * Trouve les agences par ville
     */
    @Query("SELECT * FROM agencies WHERE city = ?0 ALLOW FILTERING")
    Flux<Agency> findByCity(String city);

    /**
     * Trouve les agences par pays
     */
    @Query("SELECT * FROM agencies WHERE country = ?0 ALLOW FILTERING")
    Flux<Agency> findByCountry(String country);

    /**
     * Trouve les agences par ville et pays
     */
    @Query("SELECT * FROM agencies WHERE city = ?0 AND country = ?1 ALLOW FILTERING")
    Flux<Agency> findByCityAndCountry(String city, String country);

    /**
     * Trouve les agences actives par ville
     */
    @Query("SELECT * FROM agencies WHERE city = ?0 AND is_active = true ALLOW FILTERING")
    Flux<Agency> findActiveByCityAndCountry(String city, String country);

    /**
     * Compte les agences d'une organisation
     */
    @Query("SELECT COUNT(*) FROM agencies WHERE organization_id = ?0 ALLOW FILTERING")
    Mono<Long> countByOrganizationId(UUID organizationId);

    /**
     * Compte les agences actives d'une organisation
     */
    @Query("SELECT COUNT(*) FROM agencies WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Mono<Long> countActiveByOrganizationId(UUID organizationId);

    /**
     * Vérifie si une agence existe par nom dans une organisation
     */
    @Query("SELECT COUNT(*) FROM agencies WHERE organization_id = ?0 AND name = ?1 ALLOW FILTERING")
    Mono<Long> countByOrganizationIdAndName(UUID organizationId, String name);

    /**
     * Trouve les agences ouvertes 24h/24
     */
    @Query("SELECT * FROM agencies WHERE is_24_hours = true ALLOW FILTERING")
    Flux<Agency> find24HourAgencies();

    /**
     * Trouve les agences avec géofencing activé
     */
    @Query("SELECT * FROM agencies WHERE geofence_zone_id IS NOT NULL OR geofence_radius > 0 ALLOW FILTERING")
    Flux<Agency> findAgenciesWithGeofencing();

    /**
     * Trouve les agences dans une région géographique
     */
    @Query("SELECT * FROM agencies WHERE latitude >= ?0 AND latitude <= ?1 AND longitude >= ?2 AND longitude <= ?3 ALLOW FILTERING")
    Flux<Agency> findAgenciesInBounds(double minLat, double maxLat, double minLng, double maxLng);

    /**
     * Trouve les agences avec réservation en ligne activée
     */
    @Query("SELECT * FROM agencies WHERE allow_online_booking = true AND is_active = true ALLOW FILTERING")
    Flux<Agency> findAgenciesWithOnlineBooking();

    /**
     * Trouve les agences par organisation et région
     */
    @Query("SELECT * FROM agencies WHERE organization_id = ?0 AND region = ?1 ALLOW FILTERING")
    Flux<Agency> findByOrganizationIdAndRegion(UUID organizationId, String region);

    /**
     * Trouve les agences nécessitant une mise à jour des statistiques
     */
    @Query("SELECT * FROM agencies WHERE updated_at < ?0 ALLOW FILTERING")
    Flux<Agency> findAgenciesNeedingStatsUpdate(String cutoffDate);

    /**
     * Trouve une agence par nom dans une organisation
     */
    @Query("SELECT * FROM agencies WHERE organization_id = ?0 AND name = ?1 ALLOW FILTERING")
    Mono<Agency> findByOrganizationIdAndName(UUID organizationId, String name);

    /**
     * Trouve les agences actives d'une organisation avec pagination
     */
    @Query("SELECT * FROM agencies WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Flux<Agency> findActiveByOrganizationIdWithLimit(UUID organizationId);

    /**
     * Trouve les agences par type de devise
     */
    @Query("SELECT * FROM agencies WHERE currency = ?0 ALLOW FILTERING")
    Flux<Agency> findByCurrency(String currency);

    /**
     * Trouve les agences par fuseau horaire
     */
    @Query("SELECT * FROM agencies WHERE timezone = ?0 ALLOW FILTERING")
    Flux<Agency> findByTimezone(String timezone);

    /**
     * Trouve les agences avec un chiffre d'affaires mensuel minimum
     */
    @Query("SELECT * FROM agencies WHERE monthly_revenue >= ?0 ALLOW FILTERING")
    Flux<Agency> findByMinimumMonthlyRevenue(double minRevenue);

    /**
     * Vérifie si une organisation a atteint sa limite d'agences
     */
    default Mono<Boolean> hasReachedAgencyLimit(UUID organizationId, int maxAgencies) {
        return countActiveByOrganizationId(organizationId)
            .map(count -> count >= maxAgencies);
    }

    /**
     * Trouve les agences les plus performantes d'une organisation
     */
    default Flux<Agency> findTopPerformingAgencies(UUID organizationId, int limit) {
        return findActiveByOrganizationId(organizationId)
            .sort((a1, a2) -> Double.compare(
                a2.getMonthlyRevenue() != null ? a2.getMonthlyRevenue() : 0.0,
                a1.getMonthlyRevenue() != null ? a1.getMonthlyRevenue() : 0.0
            ))
            .take(limit);
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\DriverReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import org.springframework.data.cassandra.repository.CassandraRepository;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Slice;
import org.springframework.stereotype.Repository;

import inc.yowyob.rental_api_reactive.persistence.entity.Driver;


import java.util.List;
import java.util.Optional;
import java.util.UUID;

@Repository
public interface DriverReactiveRepository extends CassandraRepository<Driver, UUID> {

    /**
     * Récupère tous les chauffeurs associés à un utilisateur donné
     */
    @Query("SELECT * FROM drivers WHERE user_id = ?0 ALLOW FILTERING")
    Optional<Driver> findByUserId(UUID userId);

    /**
     * Récupère les chauffeurs par statut
     */
    // @Query("SELECT * FROM drivers WHERE status = ?0 ALLOW FILTERING")
    // List<Driver> findByStatus(DriverStatus status);

    /**
     * Récupère les chauffeurs disponibles
     */
    @Query("SELECT * FROM drivers WHERE available = true ALLOW FILTERING")
    List<Driver> findAvailableDrivers();

    /**
     * Récupère les chauffeurs par localisation
     */
    @Query("SELECT * FROM drivers WHERE location = ?0 ALLOW FILTERING")
    List<Driver> findByLocation(String location);

    /**
     * Récupère les chauffeurs ayant une note minimale
     */
    @Query("SELECT * FROM drivers WHERE rating >= ?0 ALLOW FILTERING")
    List<Driver> findByMinimumRating(double rating);

    /**
     * Récupère les chauffeurs assignés à un véhicule spécifique
     */
    @Query("SELECT * FROM drivers WHERE vehicle_assigned CONTAINS ?0 ALLOW FILTERING")
    List<Driver> findByVehicleAssigned(UUID vehicleId);

    List<Driver> findByOrganizationId(UUID organizationId);

        /**
     * Trouve les conducteurs par organisation et pagination
     */
    Slice<Driver> findByOrganizationId(UUID organizationId, Pageable pageable);

        /**
     * Trouve les conducteurs par agence et pagination
     */
    Slice<Driver> findByAgencyId(UUID agencyId, Pageable pageable);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\OnboardingSessionReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.OnboardingSession;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

@Repository
public interface OnboardingSessionReactiveRepository extends ReactiveCassandraRepository<OnboardingSession, UUID> {

    /**
     * Trouve une session par token
     */
    @Query("SELECT * FROM onboarding_sessions WHERE session_token = ?0 ALLOW FILTERING")
    Mono<OnboardingSession> findBySessionToken(String sessionToken);

    /**
     * Trouve les sessions expirées
     */
    @Query("SELECT * FROM onboarding_sessions WHERE expires_at < ?0 ALLOW FILTERING")
    Flux<OnboardingSession> findExpiredSessions(LocalDateTime now);

    /**
     * Trouve les sessions actives (non terminées et non expirées)
     */
    @Query("SELECT * FROM onboarding_sessions WHERE is_completed = false AND expires_at > ?0 ALLOW FILTERING")
    Flux<OnboardingSession> findActiveSessions(LocalDateTime now);

    /**
     * Supprime les sessions expirées
     */
    @Query("DELETE FROM onboarding_sessions WHERE expires_at < ?0")
    Mono<Void> deleteExpiredSessions(LocalDateTime now);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\OrganizationReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.Organization;
import inc.yowyob.rental_api_reactive.application.dto.OrganizationType;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

/**
 * Repository réactif pour l'entité Organization
 */
@Repository
public interface OrganizationReactiveRepository extends ReactiveCassandraRepository<Organization, UUID> {

    /**
     * Trouve une organisation par nom
     */
    @Query("SELECT * FROM organizations WHERE name = ?0 ALLOW FILTERING")
    Mono<Organization> findByName(String name);

    /**
     * Trouve les organisations par propriétaire
     */
    @Query("SELECT * FROM organizations WHERE owner_id = ?0 ALLOW FILTERING")
    Flux<Organization> findByOwnerId(UUID ownerId);

    /**
     * Trouve les organisations actives
     */
    @Query("SELECT * FROM organizations WHERE is_active = true ALLOW FILTERING")
    Flux<Organization> findAllActive();

    /**
     * Trouve les organisations vérifiées
     */
    @Query("SELECT * FROM organizations WHERE is_verified = true ALLOW FILTERING")
    Flux<Organization> findAllVerified();

    /**
     * Trouve les organisations actives et vérifiées
     */
    @Query("SELECT * FROM organizations WHERE is_active = true AND is_verified = true ALLOW FILTERING")
    Flux<Organization> findAllActiveAndVerified();

    /**
     * Trouve les organisations par type
     */
    @Query("SELECT * FROM organizations WHERE organization_type = ?0 ALLOW FILTERING")
    Flux<Organization> findByOrganizationType(OrganizationType organizationType);

    /**
     * Trouve les organisations par ville
     */
    @Query("SELECT * FROM organizations WHERE city = ?0 ALLOW FILTERING")
    Flux<Organization> findByCity(String city);

    /**
     * Trouve les organisations par pays
     */
    @Query("SELECT * FROM organizations WHERE country = ?0 ALLOW FILTERING")
    Flux<Organization> findByCountry(String country);

    /**
     * Trouve les organisations par ville et pays
     */
    @Query("SELECT * FROM organizations WHERE city = ?0 AND country = ?1 ALLOW FILTERING")
    Flux<Organization> findByCityAndCountry(String city, String country);

    /**
     * Trouve les organisations par région
     */
    @Query("SELECT * FROM organizations WHERE region = ?0 ALLOW FILTERING")
    Flux<Organization> findByRegion(String region);

    /**
     * Vérifie si un nom d'organisation existe
     */
    @Query("SELECT COUNT(*) FROM organizations WHERE name = ?0 ALLOW FILTERING")
    Mono<Long> countByName(String name);

    /**
     * Vérifie si un numéro d'enregistrement existe
     */
    @Query("SELECT COUNT(*) FROM organizations WHERE registration_number = ?0 ALLOW FILTERING")
    Mono<Long> countByRegistrationNumber(String registrationNumber);

    /**
     * Vérifie si un numéro fiscal existe
     */
    @Query("SELECT COUNT(*) FROM organizations WHERE tax_number = ?0 ALLOW FILTERING")
    Mono<Long> countByTaxNumber(String taxNumber);

    /**
     * Trouve les organisations avec un abonnement expirant bientôt
     */
    @Query("SELECT * FROM organizations WHERE subscription_expires_at > ?0 AND subscription_expires_at <= ?1 ALLOW FILTERING")
    Flux<Organization> findWithExpiringSubscription(LocalDateTime now, LocalDateTime inThirtyDays);

    /**
     * Trouve les organisations avec un abonnement expiré
     */
    @Query("SELECT * FROM organizations WHERE subscription_expires_at < ?0 ALLOW FILTERING")
    Flux<Organization> findWithExpiredSubscription(LocalDateTime now);

    /**
     * Trouve les organisations par plan d'abonnement
     */
    @Query("SELECT * FROM organizations WHERE subscription_plan_id = ?0 ALLOW FILTERING")
    Flux<Organization> findBySubscriptionPlanId(UUID subscriptionPlanId);

    /**
     * Trouve les organisations inactives depuis une date
     */
    @Query("SELECT * FROM organizations WHERE last_activity_at < ?0 ALLOW FILTERING")
    Flux<Organization> findInactiveSince(LocalDateTime cutoffDate);

    /**
     * Trouve les organisations avec auto-renouvellement activé
     */
    @Query("SELECT * FROM organizations WHERE subscription_auto_renew = true ALLOW FILTERING")
    Flux<Organization> findWithAutoRenewal();

    /**
     * Trouve les organisations avec un nombre minimum de véhicules
     */
    @Query("SELECT * FROM organizations WHERE current_vehicles >= ?0 ALLOW FILTERING")
    Flux<Organization> findWithMinimumVehicles(int minVehicles);

    /**
     * Trouve les organisations avec un chiffre d'affaires mensuel minimum
     */
    @Query("SELECT * FROM organizations WHERE monthly_revenue >= ?0 ALLOW FILTERING")
    Flux<Organization> findByMinimumMonthlyRevenue(double minRevenue);

    /**
     * Trouve les organisations créées dans une période
     */
    @Query("SELECT * FROM organizations WHERE created_at >= ?0 AND created_at <= ?1 ALLOW FILTERING")
    Flux<Organization> findCreatedBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Trouve les organisations nécessitant une vérification
     */
    @Query("SELECT * FROM organizations WHERE is_verified = false AND is_active = true ALLOW FILTERING")
    Flux<Organization> findAwaitingVerification();

    /**
     * Compte les organisations par type
     */
    @Query("SELECT COUNT(*) FROM organizations WHERE organization_type = ?0 ALLOW FILTERING")
    Mono<Long> countByOrganizationType(OrganizationType organizationType);

    /**
     * Compte les organisations actives
     */
    @Query("SELECT COUNT(*) FROM organizations WHERE is_active = true ALLOW FILTERING")
    Mono<Long> countActive();

    /**
     * Trouve les organisations par devise
     */
    @Query("SELECT * FROM organizations WHERE currency = ?0 ALLOW FILTERING")
    Flux<Organization> findByCurrency(String currency);

    /**
     * Trouve les organisations par fuseau horaire
     */
    @Query("SELECT * FROM organizations WHERE timezone = ?0 ALLOW FILTERING")
    Flux<Organization> findByTimezone(String timezone);

    /**
     * Méthodes par défaut pour des opérations complexes
     */

    /**
     * Vérifie si une organisation existe par nom (boolean)
     */
    default Mono<Boolean> existsByName(String name) {
        return countByName(name).map(count -> count > 0);
    }

    /**
     * Vérifie si un numéro d'enregistrement existe (boolean)
     */
    default Mono<Boolean> existsByRegistrationNumber(String registrationNumber) {
        return countByRegistrationNumber(registrationNumber).map(count -> count > 0);
    }

    /**
     * Vérifie si un numéro fiscal existe (boolean)
     */
    default Mono<Boolean> existsByTaxNumber(String taxNumber) {
        return countByTaxNumber(taxNumber).map(count -> count > 0);
    }

    /**
     * Trouve les organisations les plus performantes
     */
    default Flux<Organization> findTopPerformingOrganizations(int limit) {
        return findAllActive()
            .sort((o1, o2) -> Double.compare(
                o2.getMonthlyRevenue() != null ? o2.getMonthlyRevenue() : 0.0,
                o1.getMonthlyRevenue() != null ? o1.getMonthlyRevenue() : 0.0
            ))
            .take(limit);
    }

    /**
     * Trouve les organisations récemment créées
     */
    default Flux<Organization> findRecentlyCreated(int days) {
        LocalDateTime cutoff = LocalDateTime.now().minusDays(days);
        return findCreatedBetween(cutoff, LocalDateTime.now());
    }

    /**
     * Trouve les organisations avec une forte utilisation
     */
    default Flux<Organization> findHighUtilizationOrganizations(double threshold) {
        return findAllActive()
            .filter(org -> org.getVehicleUsagePercentage() >= threshold ||
                org.getAgencyUsagePercentage() >= threshold);
    }

    /**
     * Trouve les organisations nécessitant une attention
     */
    default Flux<Organization> findOrganizationsNeedingAttention() {
        LocalDateTime thirtyDaysAgo = LocalDateTime.now().minusDays(30);
        return findAllActive()
            .filter(org ->
                !org.getIsVerified() ||
                    org.isSubscriptionExpiringSoon() ||
                    (org.getLastActivityAt() != null && org.getLastActivityAt().isBefore(thirtyDaysAgo))
            );
    }
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\OrganizationSubscriptionReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.OrganizationSubscription;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface OrganizationSubscriptionReactiveRepository extends ReactiveCassandraRepository<OrganizationSubscription, UUID>  {

    Mono<OrganizationSubscription> findByOrganizationId(UUID organizationId);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\RoleReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.Role;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Repository
public interface RoleReactiveRepository extends ReactiveCassandraRepository<Role, UUID> {

    /**
     * Trouve les rôles par organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 ALLOW FILTERING")
    Flux<Role> findByOrganizationId(UUID organizationId);

    /**
     * Trouve un rôle par nom dans une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND name = ?1 ALLOW FILTERING")
    Mono<Role> findByOrganizationIdAndName(UUID organizationId, String name);

    /**
     * Vérifie si un nom de rôle existe dans une organisation
     */
    @Query("SELECT COUNT(*) FROM roles WHERE organization_id = ?0 AND name = ?1 ALLOW FILTERING")
    Mono<Long> countByOrganizationIdAndName(UUID organizationId, String name);

    /**
     * Trouve les rôles par défaut d'une organisation
     */
    @Query("SELECT * FROM roles WHERE organization_id = ?0 AND is_default_role = true ALLOW FILTERING")
    Flux<Role> findDefaultRolesByOrganizationId(UUID organizationId);

    /**
     * Trouve les rôles système
     */
    @Query("SELECT * FROM roles WHERE is_system_role = true ALLOW FILTERING")
    Flux<Role> findSystemRoles();
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\SubscriptionPlanReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Repository
public interface SubscriptionPlanReactiveRepository extends ReactiveCassandraRepository<SubscriptionPlan, UUID> {

    /**
     * Trouve tous les plans actifs triés par ordre
     */
    @Query("SELECT * FROM subscription_plans WHERE is_active = true ALLOW FILTERING")
    Flux<SubscriptionPlan> findAllActive();

    /**
     * Trouve les plans populaires
     */
    @Query("SELECT * FROM subscription_plans WHERE is_popular = true AND is_active = true ALLOW FILTERING")
    Flux<SubscriptionPlan> findPopularPlans();

    /**
     * Trouve les plans non personnalisés
     */
    @Query("SELECT * FROM subscription_plans WHERE is_custom = false AND is_active = true ALLOW FILTERING")
    Flux<SubscriptionPlan> findStandardPlans();
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\UserReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.application.dto.UserType;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

/**
 * Repository réactif pour l'entité User (Mis à jour)
 */
@Repository
public interface UserReactiveRepository extends ReactiveCassandraRepository<User, UUID> {
    /**
     * Trouve un utilisateur par email
     */
    @Query("SELECT * FROM users WHERE email = ?0 ALLOW FILTERING")
    Mono<User> findByEmail(String email);

    /**
     * Vérifie si un email existe
     */
    @Query("SELECT COUNT(*) FROM users WHERE email = ?0 ALLOW FILTERING")
    Mono<Long> countByEmail(String email);

    /**
     * Trouve les utilisateurs actifs uniquement
     */
    @Query("SELECT * FROM users WHERE is_active = true ALLOW FILTERING")
    Flux<User> findActiveUsers();

    /**
     * Trouve les utilisateurs non supprimés
     */
    @Query("SELECT * FROM users WHERE is_deleted = false ALLOW FILTERING")
    Flux<User> findNonDeletedUsers();

    // === RECHERCHES PAR ORGANISATION ===

    /**
     * Trouve les utilisateurs par organisation
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 ALLOW FILTERING")
    Flux<User> findByOrganizationId(UUID organizationId);

    /**
     * Trouve les utilisateurs actifs par organisation
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Flux<User> findActiveByOrganizationId(UUID organizationId);

    /**
     * Compte les utilisateurs d'une organisation
     */
    @Query("SELECT COUNT(*) FROM users WHERE organization_id = ?0 ALLOW FILTERING")
    Mono<Long> countByOrganizationId(UUID organizationId);

    // === RECHERCHES PAR AGENCE ===

    /**
     * Trouve les utilisateurs par agence
     */
    @Query("SELECT * FROM users WHERE agency_id = ?0 ALLOW FILTERING")
    Flux<User> findByAgencyId(UUID agencyId);

    /**
     * Trouve les utilisateurs actifs par agence
     */
    @Query("SELECT * FROM users WHERE agency_id = ?0 AND is_active = true ALLOW FILTERING")
    Flux<User> findActiveByAgencyId(UUID agencyId);

    /**
     * Compte les utilisateurs d'une agence
     */
    @Query("SELECT COUNT(*) FROM users WHERE agency_id = ?0 ALLOW FILTERING")
    Mono<Long> countByAgencyId(UUID agencyId);

    /**
     * Trouve les utilisateurs d'une organisation sans agence assignée
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND agency_id = null ALLOW FILTERING")
    Flux<User> findUnassignedByOrganizationId(UUID organizationId);

    /**
     * Trouve les utilisateurs par type
     */
    @Query("SELECT * FROM users WHERE user_type = ?0 ALLOW FILTERING")
    Flux<User> findByUserType(UserType userType);

    /**
     * Trouve les utilisateurs par type et organisation
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND user_type = ?1 ALLOW FILTERING")
    Flux<User> findByOrganizationIdAndUserType(UUID organizationId, UserType userType);

    /**
     * Trouve les utilisateurs par type et agence
     */
    @Query("SELECT * FROM users WHERE agency_id = ?0 AND user_type = ?1 ALLOW FILTERING")
    Flux<User> findByAgencyIdAndUserType(UUID agencyId, UserType userType);

    /**
     * Trouve tout le personnel (AGENCY_MANAGER, RENTAL_AGENT, DRIVER)
     */
    @Query("SELECT * FROM users WHERE user_type IN ('AGENCY_MANAGER', 'RENTAL_AGENT', 'DRIVER') ALLOW FILTERING")
    Flux<User> findAllPersonnel();

    /**
     * Trouve le personnel par organisation
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND user_type IN ('AGENCY_MANAGER', 'RENTAL_AGENT', 'DRIVER') ALLOW FILTERING")
    Flux<User> findPersonnelByOrganizationId(UUID organizationId);

    /**
     * Trouve le personnel par agence
     */
    @Query("SELECT * FROM users WHERE agency_id = ?0 AND user_type IN ('AGENCY_MANAGER', 'RENTAL_AGENT', 'DRIVER') ALLOW FILTERING")
    Flux<User> findPersonnelByAgencyId(UUID agencyId);

    // === RECHERCHES PAR INFORMATIONS EMPLOYÉ ===

    /**
     * Trouve un utilisateur par ID employé
     */
    @Query("SELECT * FROM users WHERE employee_id = ?0 ALLOW FILTERING")
    Mono<User> findByEmployeeId(String employeeId);

    /**
     * Trouve les utilisateurs par département
     */
    @Query("SELECT * FROM users WHERE department = ?0 ALLOW FILTERING")
    Flux<User> findByDepartment(String department);

    /**
     * Trouve les utilisateurs par superviseur
     */
    @Query("SELECT * FROM users WHERE supervisor_id = ?0 ALLOW FILTERING")
    Flux<User> findBySupervisorId(UUID supervisorId);

    /**
     * Trouve les utilisateurs par organisation et département
     */
    @Query("SELECT * FROM users WHERE organization_id = ?0 AND department = ?1 ALLOW FILTERING")
    Flux<User> findByOrganizationIdAndDepartment(UUID organizationId, String department);

    /**
     * Trouve un utilisateur par token de réinitialisation
     */
    @Query("SELECT * FROM users WHERE password_reset_token = ?0 ALLOW FILTERING")
    Mono<User> findByPasswordResetToken(String token);

    /**
     * Trouve un utilisateur par token de vérification email
     */
    @Query("SELECT * FROM users WHERE email_verification_token = ?0 ALLOW FILTERING")
    Mono<User> findByEmailVerificationToken(String token);

    /**
     * Trouve les utilisateurs verrouillés
     */
    @Query("SELECT * FROM users WHERE locked_until > dateof(now()) ALLOW FILTERING")
    Flux<User> findLockedUsers();

    /**
     * Trouve les utilisateurs qui doivent changer leur mot de passe
     */
    @Query("SELECT * FROM users WHERE must_change_password = true ALLOW FILTERING")
    Flux<User> findUsersRequiringPasswordChange();

    /**
     * Compte les utilisateurs par type dans une organisation
     */
    @Query("SELECT COUNT(*) FROM users WHERE organization_id = ?0 AND user_type = ?1 ALLOW FILTERING")
    Mono<Long> countByOrganizationIdAndUserType(UUID organizationId, UserType userType);

    /**
     * Compte les utilisateurs actifs par organisation
     */
    @Query("SELECT COUNT(*) FROM users WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Mono<Long> countActiveByOrganizationId(UUID organizationId);

    /**
     * Compte le personnel par organisation
     */
    @Query("SELECT COUNT(*) FROM users WHERE organization_id = ?0 AND user_type IN ('AGENCY_MANAGER', 'RENTAL_AGENT', 'DRIVER') ALLOW FILTERING")
    Mono<Long> countPersonnelByOrganizationId(UUID organizationId);

    /**
     * Compte le personnel par agence
     */
    @Query("SELECT COUNT(*) FROM users WHERE agency_id = ?0 AND user_type IN ('AGENCY_MANAGER', 'RENTAL_AGENT', 'DRIVER') ALLOW FILTERING")
    Mono<Long> countPersonnelByAgencyId(UUID agencyId);

    // === RECHERCHES RÉCENTES ===

    /**
     * Trouve les utilisateurs créés récemment (30 derniers jours)
     */
    @Query("SELECT * FROM users WHERE created_at > dateof(now()) - 2592000000 ALLOW FILTERING")
    Flux<User> findRecentlyCreatedUsers();

    /**
     * Trouve les utilisateurs connectés récemment (7 derniers jours)
     */
    @Query("SELECT * FROM users WHERE last_login_at > dateof(now()) - 604800000 ALLOW FILTERING")
    Flux<User> findRecentlyLoggedInUsers();

    // === MÉTHODES DE MISE À JOUR BULK ===

    /**
     * Active tous les utilisateurs d'une organisation
     */
    @Query("UPDATE users SET is_active = true WHERE organization_id = ?0")
    Mono<Void> activateAllByOrganizationId(UUID organizationId);

    /**
     * Désactive tous les utilisateurs d'une organisation
     */
    @Query("UPDATE users SET is_active = false WHERE organization_id = ?0")
    Mono<Void> deactivateAllByOrganizationId(UUID organizationId);

    /**
     * Désassigne tous les utilisateurs d'une agence
     */
    @Query("UPDATE users SET agency_id = null WHERE agency_id = ?0")
    Mono<Void> unassignAllFromAgency(UUID agencyId);
}
```

--- PATH: src\main\java\inc\yowyob\rental_api_reactive\persistence\repository\UserRoleReactiveRepository.java ---

```java
package inc.yowyob.rental_api_reactive.persistence.repository;

import inc.yowyob.rental_api_reactive.persistence.entity.UserRole;
import org.springframework.data.cassandra.repository.Query;
import org.springframework.data.cassandra.repository.ReactiveCassandraRepository;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

@Repository
public interface UserRoleReactiveRepository extends ReactiveCassandraRepository<UserRole, UUID> {

    /**
     * Trouve les rôles d'un utilisateur
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0")
    Flux<UserRole> findByUserId(UUID userId);

    /**
     * Trouve les utilisateurs ayant un rôle spécifique
     */
    @Query("SELECT * FROM user_roles WHERE role_id = ?0 ALLOW FILTERING")
    Flux<UserRole> findByRoleId(UUID roleId);

    /**
     * Trouve les rôles actifs d'un utilisateur
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND is_active = true")
    Flux<UserRole> findActiveByUserId(UUID userId);

    /**
     * Supprime tous les rôles d'un utilisateur
     */
    @Query("DELETE FROM user_roles WHERE user_id = ?0")
    Mono<Void> deleteByUserId(UUID userId);

    /**
     * Trouve une relation spécifique utilisateur-rôle
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND role_id = ?1")
    Mono<UserRole> findByUserIdAndRoleId(UUID userId, UUID roleId);

    /**
     * Compte les utilisateurs ayant un rôle spécifique
     */
    @Query("SELECT COUNT(*) FROM user_roles WHERE role_id = ?0 AND is_active = true ALLOW FILTERING")
    Mono<Long> countByRoleId(UUID roleId);

    /**
     * Compte les rôles actifs d'un utilisateur
     */
    @Query("SELECT COUNT(*) FROM user_roles WHERE user_id = ?0 AND is_active = true")
    Mono<Long> countActiveByUserId(UUID userId);

    /**
     * Trouve les assignations par organisation
     */
    @Query("SELECT * FROM user_roles WHERE organization_id = ?0 ALLOW FILTERING")
    Flux<UserRole> findByOrganizationId(UUID organizationId);

    /**
     * Trouve les assignations par agence
     */
    @Query("SELECT * FROM user_roles WHERE agency_id = ?0 ALLOW FILTERING")
    Flux<UserRole> findByAgencyId(UUID agencyId);

    /**
     * Trouve les assignations temporaires (avec date d'expiration)
     */
    @Query("SELECT * FROM user_roles WHERE expires_at IS NOT NULL ALLOW FILTERING")
    Flux<UserRole> findTemporaryAssignments();

    /**
     * Trouve les assignations qui expirent bientôt
     */
    @Query("SELECT * FROM user_roles WHERE is_active = true AND expires_at IS NOT NULL AND expires_at <= ?0 AND expires_at > ?1 ALLOW FILTERING")
    Flux<UserRole> findExpiringSoon(LocalDateTime expirationThreshold, LocalDateTime now);

    /**
     * Trouve les assignations expirées
     */
    @Query("SELECT * FROM user_roles WHERE is_active = true AND expires_at IS NOT NULL AND expires_at < ?0 ALLOW FILTERING")
    Flux<UserRole> findExpired(LocalDateTime now);

    /**
     * Trouve les assignations créées par un utilisateur spécifique
     */
    @Query("SELECT * FROM user_roles WHERE assigned_by = ?0 ALLOW FILTERING")
    Flux<UserRole> findByAssignedBy(UUID assignedBy);

    /**
     * Trouve les assignations dans une période donnée
     */
    @Query("SELECT * FROM user_roles WHERE assigned_at >= ?0 AND assigned_at <= ?1 ALLOW FILTERING")
    Flux<UserRole> findByAssignedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Compte les utilisateurs actifs dans une organisation
     */
    @Query("SELECT COUNT(DISTINCT user_id) FROM user_roles WHERE organization_id = ?0 AND is_active = true ALLOW FILTERING")
    Mono<Long> countDistinctActiveUsersByOrganizationId(UUID organizationId);

    /**
     * Trouve les rôles actifs par organisation et utilisateur
     */
    @Query("SELECT * FROM user_roles WHERE user_id = ?0 AND organization_id = ?1 AND is_active = true")
    Flux<UserRole> findActiveByUserIdAndOrganizationId(UUID userId, UUID organizationId);

    /**
     * Vérifie si un utilisateur a un rôle spécifique
     */
    @Query("SELECT COUNT(*) FROM user_roles WHERE user_id = ?0 AND role_id = ?1 AND is_active = true")
    Mono<Long> countActiveByUserIdAndRoleId(UUID userId, UUID roleId);
}
```

--- PATH: src\main\resources\application.properties ---

```properties
# ================================================================
# APPLICATION INFORMATION
# ================================================================
spring.application.name=rental-api-reactive

# ================================================================
# SERVER CONFIGURATION
# ================================================================
server.port=8080
server.error.include-message=always
server.error.include-binding-errors=always

# ================================================================
# CASSANDRA/SCYLLA CONFIGURATION
# ================================================================
spring.cassandra.contact-points=localhost
spring.cassandra.keyspace-name=rental
spring.cassandra.username=cassandra
spring.cassandra.password=cassandra
spring.cassandra.port=9042
spring.cassandra.local-datacenter=datacenter1

spring.cassandra.schema-action=CREATE_IF_NOT_EXISTS
spring.cassandra.request.timeout=10s
spring.cassandra.connection.connect-timeout=10s
spring.cassandra.connection.init-query-timeout=10s

# ================================================================
# CORS CONFIGURATION
# ================================================================
app.cors.allowed-origins=http://localhost:3000,http://localhost:8080,http://localhost:4200
app.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
app.cors.allowed-headers=*
app.cors.allow-credentials=true

# ================================================================
# SECURITY & JWT CONFIGURATION
# ================================================================
app.jwt.secret=KsBman55FbHOoyT2SCZl46RZnc0oySFlenms644lQPKOt//JW78D5brRZuWelLzVts/ACnJcdXtIEl3D57KO5w==
app.jwt.expiration=86400000
app.jwt.refresh-expiration=604800000

# ================================================================
# OPENAPI / SWAGGER CONFIGURATION
# ================================================================
springdoc.api-docs.enabled=true
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui
springdoc.swagger-ui.operationsSorter=method
springdoc.packages-to-scan=inc.yowyob.rental_api_reactive.infrastructure.web.controller

# Configuration des chemins  inclure
springdoc.paths-to-match=/api/v1/**

# Activation du support CORS pour Swagger
springdoc.swagger-ui.csrf.enabled=false

# ================================================================
# ACTUATOR CONFIGURATION
# ================================================================
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=when-authorized

# ================================================================
# LOGGING CONFIGURATION
# ================================================================
logging.level.inc.yowyob.rental_api_reactive=DEBUG
logging.level.org.springframework.security=DEBUG
logging.level.com.datastax.oss.driver=INFO
logging.level.reactor.netty=INFO
logging.pattern.console=%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(%5p) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n

# ================================================================
# FILE UPLOAD CONFIGURATION
# ================================================================
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
app.file.upload-dir=./uploads
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\RentalApiReactiveApplicationTests.java ---

```java
package inc.yowyob.rental_api_reactive;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class RentalApiReactiveApplicationTests {

	@Test
	void contextLoads() {
	}

}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\application\service\OnboardingReactiveServiceTest.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import inc.yowyob.rental_api_reactive.persistence.entity.OnboardingSession;
import inc.yowyob.rental_api_reactive.persistence.repository.OnboardingSessionReactiveRepository;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.OwnerInfoRequest;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.OnboardingSessionResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class OnboardingReactiveServiceTest {

    @Mock
    private OnboardingSessionReactiveRepository onboardingSessionRepository;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private OnboardingReactiveService onboardingService;

    private OnboardingSession testSession;
    private UUID testSessionId;

    @BeforeEach
    void setUp() {
        testSessionId = UUID.randomUUID();
        testSession = new OnboardingSession();
        testSession.setId(testSessionId);
        testSession.setSessionToken("test-token");
        testSession.setCurrentStep(1);
        testSession.setMaxStep(3);
        testSession.setIsCompleted(false);
        testSession.setExpiresAt(LocalDateTime.now().plusHours(24));
    }

    @Test
    void createOnboardingSession_ShouldCreateAndReturnSession() {
        // Given
        when(onboardingSessionRepository.save(any(OnboardingSession.class)))
            .thenReturn(Mono.just(testSession));

        // When & Then
        StepVerifier.create(onboardingService.createOnboardingSession())
            .expectNextMatches(response ->
                response.getId().equals(testSessionId) &&
                    response.getCurrentStep() == 1 &&
                    !response.getIsCompleted()
            )
            .verifyComplete();
    }

    @Test
    void getOnboardingSession_WhenSessionExists_ShouldReturnSession() {
        // Given
        when(onboardingSessionRepository.findById(testSessionId))
            .thenReturn(Mono.just(testSession));

        // When & Then
        StepVerifier.create(onboardingService.getOnboardingSession(testSessionId))
            .expectNextMatches(response ->
                response.getId().equals(testSessionId) &&
                    response.getSessionToken().equals("test-token")
            )
            .verifyComplete();
    }

    @Test
    void getOnboardingSession_WhenSessionNotExists_ShouldReturnError() {
        // Given
        when(onboardingSessionRepository.findById(testSessionId))
            .thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(onboardingService.getOnboardingSession(testSessionId))
            .expectError(RuntimeException.class)
            .verify();
    }

    @Test
    void saveOwnerInfo_WhenSessionValid_ShouldSaveAndReturnUpdatedSession() throws Exception {
        // Given
        OwnerInfoRequest ownerInfo = new OwnerInfoRequest();
        ownerInfo.setFirstName("John");
        ownerInfo.setLastName("Doe");
        ownerInfo.setEmail("john.doe@example.com");

        when(onboardingSessionRepository.findById(testSessionId))
            .thenReturn(Mono.just(testSession));
        when(objectMapper.writeValueAsString(any()))
            .thenReturn("{\"firstName\":\"John\"}");
        when(onboardingSessionRepository.save(any(OnboardingSession.class)))
            .thenReturn(Mono.just(testSession));

        // When & Then
        StepVerifier.create(onboardingService.saveOwnerInfo(testSessionId, ownerInfo))
            .expectNextMatches(response ->
                response.getId().equals(testSessionId)
            )
            .verifyComplete();
    }

    @Test
    void saveOwnerInfo_WhenSessionExpired_ShouldReturnError() {
        // Given
        testSession.setExpiresAt(LocalDateTime.now().minusHours(1)); // Expired
        OwnerInfoRequest ownerInfo = new OwnerInfoRequest();

        when(onboardingSessionRepository.findById(testSessionId))
            .thenReturn(Mono.just(testSession));

        // When & Then
        StepVerifier.create(onboardingService.saveOwnerInfo(testSessionId, ownerInfo))
            .expectError(RuntimeException.class)
            .verify();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\application\service\OrganizationReactiveServiceTest.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.persistence.entity.Organization;
import inc.yowyob.rental_api_reactive.persistence.repository.OrganizationReactiveRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class OrganizationReactiveServiceTest {

    @Mock
    private OrganizationReactiveRepository organizationRepository;

    @InjectMocks
    private OrganizationReactiveService organizationService;

    private Organization testOrganization1;
    private Organization testOrganization2;
    private UUID organizationId1;
    private UUID organizationId2;
    private UUID ownerId1;
    private UUID ownerId2;

    @BeforeEach
    void setUp() {
        organizationId1 = UUID.randomUUID();
        organizationId2 = UUID.randomUUID();
        ownerId1 = UUID.randomUUID();
        ownerId2 = UUID.randomUUID();

        testOrganization1 = new Organization();
        testOrganization1.setId(organizationId1);
        testOrganization1.setName("YowyoB Transport");
        testOrganization1.setDescription("Entreprise de transport urbain à Douala");
        testOrganization1.setBusinessType("Transport");
        testOrganization1.setRegistrationNumber("CM-DLA-2024-001");
        testOrganization1.setTaxNumber("TAX-001-2024");
        testOrganization1.setOwnerId(ownerId1);
        testOrganization1.setContactEmail("contact@yowyob.transport");
        testOrganization1.setContactPhone("+237123456789");
        testOrganization1.setWebsite("https://transport.yowyob.inc");
        testOrganization1.setAddressLine1("Rue de la République");
        testOrganization1.setAddressLine2("Immeuble Moderne");
        testOrganization1.setCity("Douala");
        testOrganization1.setStateProvince("Littoral");
        testOrganization1.setPostalCode("00237");
        testOrganization1.setCountry("CM");
        testOrganization1.setMaxVehicles(50);
        testOrganization1.setMaxDrivers(25);
        testOrganization1.setMaxAgencies(5);
        testOrganization1.setMaxUsers(20);
        testOrganization1.setCurrency("XAF");
        testOrganization1.setTimezone("Africa/Douala");
        testOrganization1.setDefaultLanguage("fr");
        testOrganization1.setLogoUrl("https://cdn.yowyob.inc/logos/transport.png");
        testOrganization1.setIsVerified(true);
        testOrganization1.setVerificationDate(LocalDateTime.now().minusDays(30));
        testOrganization1.setIsActive(true);
        testOrganization1.setCreatedAt(LocalDateTime.now().minusDays(60));
        testOrganization1.setUpdatedAt(LocalDateTime.now().minusDays(1));


        testOrganization2 = new Organization();
        testOrganization2.setId(organizationId2);
        testOrganization2.setName("Cameroon Logistics");
        testOrganization2.setDescription("Société de logistique et transport de marchandises");
        testOrganization2.setBusinessType("Logistics");
        testOrganization2.setRegistrationNumber("CM-YAO-2024-002");
        testOrganization2.setOwnerId(ownerId2);
        testOrganization2.setContactEmail("info@cameroon-logistics.cm");
        testOrganization2.setContactPhone("+237987654321");
        testOrganization2.setCity("Yaoundé");
        testOrganization2.setCountry("CM");
        testOrganization2.setMaxVehicles(30);
        testOrganization2.setMaxDrivers(15);
        testOrganization2.setMaxAgencies(3);
        testOrganization2.setMaxUsers(10);
        testOrganization2.setCurrency("XAF");
        testOrganization2.setTimezone("Africa/Douala");
        testOrganization2.setDefaultLanguage("fr");
        testOrganization2.setIsVerified(false);
        testOrganization2.setIsActive(true);
        testOrganization2.setCreatedAt(LocalDateTime.now().minusDays(15));
        testOrganization2.setUpdatedAt(LocalDateTime.now().minusDays(2));

    }

    @Test
    void findAll_ShouldReturnAllOrganizations_WhenOrganizationsExist() {
        // Given
        when(organizationRepository.findAll()).thenReturn(Flux.just(testOrganization1, testOrganization2));

        // When & Then
        StepVerifier.create(organizationService.findAll())
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getName()).isEqualTo("YowyoB Transport");
                assertThat(orgResponse.getBusinessType()).isEqualTo("Transport");
                return true;
            })
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getName()).isEqualTo("Cameroon Logistics");
                assertThat(orgResponse.getBusinessType()).isEqualTo("Logistics");
                return true;
            })
            .verifyComplete();

        verify(organizationRepository, times(1)).findAll();
    }

    @Test
    void findAll_ShouldReturnEmpty_WhenNoOrganizationsExist() {
        // Given
        when(organizationRepository.findAll()).thenReturn(Flux.empty());

        // When & Then
        StepVerifier.create(organizationService.findAll())
            .verifyComplete();

        verify(organizationRepository, times(1)).findAll();
    }

    @Test
    void findById_ShouldReturnOrganization_WhenOrganizationExists() {
        // Given
        when(organizationRepository.findById(organizationId1)).thenReturn(Mono.just(testOrganization1));

        // When & Then
        StepVerifier.create(organizationService.findById(organizationId1))
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getId()).isEqualTo(organizationId1);
                assertThat(orgResponse.getName()).isEqualTo("YowyoB Transport");
                return true;
            })
            .verifyComplete();

        verify(organizationRepository, times(1)).findById(organizationId1);
    }

    @Test
    void findById_ShouldReturnEmpty_WhenOrganizationNotExists() {
        // Given
        UUID nonExistentId = UUID.randomUUID();
        when(organizationRepository.findById(nonExistentId)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(organizationService.findById(nonExistentId))
            .verifyComplete();

        verify(organizationRepository, times(1)).findById(nonExistentId);
    }

    @Test
    void findByOwnerId_ShouldReturnOrganization_WhenOwnerExists() {
        // Given
        when(organizationRepository.findByOwnerId(ownerId1)).thenReturn(Mono.just(testOrganization1));

        // When & Then
        StepVerifier.create(organizationService.findByOwnerId(ownerId1))
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getOwnerId()).isEqualTo(ownerId1);
                assertThat(orgResponse.getName()).isEqualTo("YowyoB Transport");
                return true;
            })
            .verifyComplete();

        verify(organizationRepository, times(1)).findByOwnerId(ownerId1);
    }

    /*@Test
    void findByRegistrationNumber_ShouldReturnOrganization_WhenExists() {
        // Given
        String regNum = "CM-DLA-2024-001";
        when(organizationRepository.findByRegistrationNumber(regNum)).thenReturn(Mono.just(testOrganization1));

        // When & Then
        StepVerifier.create(organizationService.findByRegistrationNumber(regNum))
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getRegistrationNumber()).isEqualTo(regNum);
                assertThat(orgResponse.getName()).isEqualTo("YowyoB Transport");
                return true;
            })
            .verifyComplete();

        verify(organizationRepository, times(1)).findByRegistrationNumber(regNum);
    }*/


    @Test
    void findAllActive_ShouldReturnActiveOrganizations_WhenActiveOrganizationsExist() {
        // Given
        when(organizationRepository.findAllActive()).thenReturn(Flux.just(testOrganization1, testOrganization2));

        // When & Then
        StepVerifier.create(organizationService.findAllActive())
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getIsActive()).isTrue();
                assertThat(orgResponse.getName()).isEqualTo("YowyoB Transport");
                return true;
            })
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getIsActive()).isTrue();
                assertThat(orgResponse.getName()).isEqualTo("Cameroon Logistics");
                return true;
            })
            .verifyComplete();

        verify(organizationRepository, times(1)).findAllActive();
    }

    @Test
    void findAllActive_ShouldReturnEmpty_WhenNoActiveOrganizations() {
        // Given
        when(organizationRepository.findAllActive()).thenReturn(Flux.empty());

        // When & Then
        StepVerifier.create(organizationService.findAllActive())
            .verifyComplete();

        verify(organizationRepository, times(1)).findAllActive();
    }

    @Test
    void existsByName_ShouldReturnTrue_WhenNameExists() {
        // Given
        String existingName = "YowyoB Transport";
        when(organizationRepository.countByName(existingName)).thenReturn(Mono.just(1L));

        // When & Then
        StepVerifier.create(organizationService.existsByName(existingName))
            .expectNext(true)
            .verifyComplete();

        verify(organizationRepository, times(1)).countByName(existingName);
    }

    @Test
    void existsByName_ShouldReturnFalse_WhenNameNotExists() {
        // Given
        String nonExistentName = "Non Existent Organization";
        when(organizationRepository.countByName(nonExistentName)).thenReturn(Mono.just(0L));

        // When & Then
        StepVerifier.create(organizationService.existsByName(nonExistentName))
            .expectNext(false)
            .verifyComplete();

        verify(organizationRepository, times(1)).countByName(nonExistentName);
    }

    @Test
    void save_ShouldReturnSavedOrganization_WhenOrganizationIsValid() {
        // Given
        Organization newOrganization = new Organization();
        newOrganization.setName("New Transport Company");
        newOrganization.setOwnerId(UUID.randomUUID());

        // The service will add an ID, timestamps, etc.
        when(organizationRepository.save(any(Organization.class))).thenReturn(Mono.just(newOrganization));

        // When & Then
        StepVerifier.create(organizationService.save(newOrganization))
            .expectNextMatches(orgResponse -> {
                assertThat(orgResponse.getName()).isEqualTo("New Transport Company");
                return true;
            })
            .verifyComplete();

        verify(organizationRepository, times(1)).save(any(Organization.class));
    }

    @Test
    void deleteById_ShouldCompleteSuccessfully_WhenOrganizationExists() {
        // Given
        when(organizationRepository.deleteById(organizationId1)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(organizationService.deleteById(organizationId1))
            .verifyComplete();

        verify(organizationRepository, times(1)).deleteById(organizationId1);
    }

    @Test
    void save_ShouldSetTimestampsAndId_BeforeSaving() {
        // Given
        Organization newOrganization = new Organization();
        newOrganization.setName("Test Organization");
        newOrganization.setOwnerId(UUID.randomUUID());

        // Prepare an ArgumentCaptor to capture the organization passed to the save method
        ArgumentCaptor<Organization> organizationCaptor = ArgumentCaptor.forClass(Organization.class);

        // When save is called, just return the captured object
        when(organizationRepository.save(organizationCaptor.capture())).thenReturn(Mono.empty());

        // When
        StepVerifier.create(organizationService.save(newOrganization))
            .verifyComplete();

        // Then
        // Verify that the save method on the repository was called once
        verify(organizationRepository, times(1)).save(any(Organization.class));

        // Get the captured organization
        Organization capturedOrg = organizationCaptor.getValue();

        // Assert that the service has set the required fields before saving
        assertThat(capturedOrg.getId()).isNotNull();
        assertThat(capturedOrg.getCreatedAt()).isNotNull();
        assertThat(capturedOrg.getUpdatedAt()).isNotNull();
        assertThat(capturedOrg.getIsActive()).isTrue();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\application\service\PermissionReactiveServiceTest.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.dto.Permission;
import inc.yowyob.rental_api_reactive.persistence.entity.Role;
import inc.yowyob.rental_api_reactive.persistence.entity.UserRole;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.UserRoleReactiveRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.util.Set;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class PermissionReactiveServiceTest {

    @Mock
    private UserRoleReactiveRepository userRoleRepository;

    @Mock
    private RoleReactiveRepository roleRepository;

    @InjectMocks
    private PermissionReactiveService permissionService;

    private UUID userId;
    private UUID roleId;
    private UUID organizationId;
    private UserRole userRole;
    private Role role;

    @BeforeEach
    void setUp() {
        userId = UUID.randomUUID();
        roleId = UUID.randomUUID();
        organizationId = UUID.randomUUID();

        userRole = new UserRole(userId, roleId, organizationId);
        userRole.setIsActive(true);

        role = new Role("Test Role", "Test description", organizationId);
        role.setId(roleId);
        role.setPermissions(Set.of(
            Permission.USER_READ.getCode(),
            Permission.USER_WRITE.getCode(),
            Permission.VEHICLE_READ.getCode()
        ));
    }

    @Test
    void getAllPermissions_ShouldReturnAllPermissions() {
        // When & Then
        StepVerifier.create(permissionService.getAllPermissions())
            .expectNextCount(Permission.values().length)
            .verifyComplete();
    }

    @Test
    void getPermissionsByResource_ShouldReturnResourcePermissions() {
        // When & Then
        StepVerifier.create(permissionService.getPermissionsByResource("USER"))
            .assertNext(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getResource()).isEqualTo("USER");
                assertThat(response.getPermissions()).isNotEmpty();
                assertThat(response.getTotalCount()).isGreaterThan(0);
            })
            .verifyComplete();
    }

    @Test
    void getUserPermissions_ShouldReturnUserPermissions() {
        // Given
        when(userRoleRepository.findActiveByUserId(userId))
            .thenReturn(Flux.just(userRole));
        when(roleRepository.findById(roleId))
            .thenReturn(Mono.just(role));

        // When & Then
        StepVerifier.create(permissionService.getUserPermissions(userId))
            .assertNext(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getUserId()).isEqualTo(userId);
                assertThat(response.getPermissions()).contains(
                    Permission.USER_READ.getCode(),
                    Permission.USER_WRITE.getCode(),
                    Permission.VEHICLE_READ.getCode()
                );
                assertThat(response.getTotalCount()).isEqualTo(3);
            })
            .verifyComplete();
    }

    @Test
    void hasPermission_ShouldReturnTrueForValidPermission() {
        // Given
        when(userRoleRepository.findActiveByUserId(userId))
            .thenReturn(Flux.just(userRole));
        when(roleRepository.findById(roleId))
            .thenReturn(Mono.just(role));

        // When & Then
        StepVerifier.create(permissionService.hasPermission(userId, Permission.USER_READ.getCode()))
            .assertNext(hasPermission -> {
                assertThat(hasPermission).isTrue();
            })
            .verifyComplete();
    }

    @Test
    void hasPermission_ShouldReturnFalseForInvalidPermission() {
        // Given
        when(userRoleRepository.findActiveByUserId(userId))
            .thenReturn(Flux.just(userRole));
        when(roleRepository.findById(roleId))
            .thenReturn(Mono.just(role));

        // When & Then
        StepVerifier.create(permissionService.hasPermission(userId, Permission.SYSTEM_ADMIN.getCode()))
            .assertNext(hasPermission -> {
                assertThat(hasPermission).isFalse();
            })
            .verifyComplete();
    }

    @Test
    void hasAllPermissions_ShouldReturnTrueWhenUserHasAllPermissions() {
        // Given
        Set<String> requestedPermissions = Set.of(
            Permission.USER_READ.getCode(),
            Permission.USER_WRITE.getCode()
        );

        when(userRoleRepository.findActiveByUserId(userId))
            .thenReturn(Flux.just(userRole));
        when(roleRepository.findById(roleId))
            .thenReturn(Mono.just(role));

        // When & Then
        StepVerifier.create(permissionService.hasAllPermissions(userId, requestedPermissions))
            .assertNext(hasAllPermissions -> {
                assertThat(hasAllPermissions).isTrue();
            })
            .verifyComplete();
    }

    @Test
    void hasAnyPermission_ShouldReturnTrueWhenUserHasAnyPermission() {
        // Given
        Set<String> requestedPermissions = Set.of(
            Permission.USER_READ.getCode(),
            Permission.SYSTEM_ADMIN.getCode()
        );

        when(userRoleRepository.findActiveByUserId(userId))
            .thenReturn(Flux.just(userRole));
        when(roleRepository.findById(roleId))
            .thenReturn(Mono.just(role));

        // When & Then
        StepVerifier.create(permissionService.hasAnyPermission(userId, requestedPermissions))
            .assertNext(hasAnyPermission -> {
                assertThat(hasAnyPermission).isTrue();
            })
            .verifyComplete();
    }

    @Test
    void compareUserPermissions_ShouldComparePermissionsCorrectly() {
        // Given
        UUID userId2 = UUID.randomUUID();
        UUID roleId2 = UUID.randomUUID();

        UserRole userRole2 = new UserRole(userId2, roleId2, organizationId);
        userRole2.setIsActive(true);

        Role role2 = new Role("Test Role 2", "Test description 2", organizationId);
        role2.setId(roleId2);
        role2.setPermissions(Set.of(
            Permission.USER_READ.getCode(),
            Permission.RENTAL_READ.getCode()
        ));

        when(userRoleRepository.findActiveByUserId(userId))
            .thenReturn(Flux.just(userRole));
        when(roleRepository.findById(roleId))
            .thenReturn(Mono.just(role));

        when(userRoleRepository.findActiveByUserId(userId2))
            .thenReturn(Flux.just(userRole2));
        when(roleRepository.findById(roleId2))
            .thenReturn(Mono.just(role2));

        // When & Then
        StepVerifier.create(permissionService.compareUserPermissions(userId, userId2))
            .assertNext(comparison -> {
                assertThat(comparison).isNotNull();
                assertThat(comparison.getUserId1()).isEqualTo(userId);
                assertThat(comparison.getUserId2()).isEqualTo(userId2);
                assertThat(comparison.getCommonPermissions()).contains(Permission.USER_READ.getCode());
                assertThat(comparison.getUser1OnlyPermissions()).contains(
                    Permission.USER_WRITE.getCode(),
                    Permission.VEHICLE_READ.getCode()
                );
                assertThat(comparison.getUser2OnlyPermissions()).contains(Permission.RENTAL_READ.getCode());
            })
            .verifyComplete();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\application\service\RoleReactiveServiceTest.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.dto.Permission;
import inc.yowyob.rental_api_reactive.application.dto.RoleType;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.CreateRoleRequest;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.RoleResponse;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.UpdateRoleRequest;
import inc.yowyob.rental_api_reactive.persistence.entity.Role;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.UserRoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.mapper.RoleMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.util.Set;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class RoleReactiveServiceTest {

    @Mock
    private RoleReactiveRepository roleRepository;

    @Mock
    private UserRoleReactiveRepository userRoleRepository;

    @Mock
    private RoleMapper roleMapper;

    @InjectMocks
    private RoleReactiveService roleService;

    private UUID organizationId;
    private UUID createdBy;
    private CreateRoleRequest createRequest;
    private Role role;
    private RoleResponse roleResponse;

    @BeforeEach
    void setUp() {
        organizationId = UUID.randomUUID();
        createdBy = UUID.randomUUID();

        createRequest = CreateRoleRequest.builder()
            .name("Test Role")
            .description("Test role description")
            .organizationId(organizationId)
            .roleType(RoleType.CUSTOM)
            .priority(50)
            .permissions(Set.of(Permission.USER_READ.getCode(), Permission.USER_WRITE.getCode()))
            .color("#3b82f6")
            .icon("shield")
            .build();

        role = new Role("Test Role", "Test role description", organizationId);
        role.setId(UUID.randomUUID());
        role.setRoleType(RoleType.CUSTOM);
        role.setPriority(50);
        role.setPermissions(Set.of(Permission.USER_READ.getCode(), Permission.USER_WRITE.getCode()));
        role.setColor("#3b82f6");
        role.setIcon("shield");

        roleResponse = RoleResponse.builder()
            .id(role.getId())
            .name(role.getName())
            .description(role.getDescription())
            .organizationId(role.getOrganizationId())
            .roleType(role.getRoleType())
            .permissions(role.getPermissions())
            .build();
    }

    @Test
    void createRole_ShouldCreateRoleSuccessfully() {
        // Given
        when(roleRepository.countByOrganizationIdAndName(organizationId, "Test Role"))
            .thenReturn(Mono.just(0L));
        when(roleRepository.save(any(Role.class))).thenReturn(Mono.just(role));
        when(roleMapper.toResponse(role)).thenReturn(roleResponse);

        // When & Then
        StepVerifier.create(roleService.createRole(createRequest, createdBy))
            .assertNext(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getName()).isEqualTo("Test Role");
                assertThat(response.getOrganizationId()).isEqualTo(organizationId);
                assertThat(response.getRoleType()).isEqualTo(RoleType.CUSTOM);
            })
            .verifyComplete();
    }

    @Test
    void createRole_ShouldFailWhenNameExists() {
        // Given
        when(roleRepository.countByOrganizationIdAndName(organizationId, "Test Role"))
            .thenReturn(Mono.just(1L));

        // When & Then
        StepVerifier.create(roleService.createRole(createRequest, createdBy))
            .expectErrorMatches(throwable ->
                throwable instanceof IllegalArgumentException &&
                    throwable.getMessage().contains("Role name already exists"))
            .verify();
    }

    @Test
    void updateRole_ShouldUpdateRoleSuccessfully() {
        // Given
        UUID roleId = role.getId();
        UpdateRoleRequest updateRequest = UpdateRoleRequest.builder()
            .name("Updated Role")
            .description("Updated description")
            .build();

        when(roleRepository.findById(roleId)).thenReturn(Mono.just(role));
        when(roleRepository.save(any(Role.class))).thenReturn(Mono.just(role));
        when(roleMapper.toResponse(any(Role.class))).thenReturn(roleResponse);

        // When & Then
        StepVerifier.create(roleService.updateRole(roleId, updateRequest, createdBy))
            .assertNext(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getId()).isEqualTo(roleId);
            })
            .verifyComplete();
    }

    @Test
    void deleteRole_ShouldDeleteRoleSuccessfully() {
        // Given
        UUID roleId = role.getId();
        role.setIsSystemRole(false);
        role.setIsDefaultRole(false);

        when(roleRepository.findById(roleId)).thenReturn(Mono.just(role));
        when(userRoleRepository.countByRoleId(roleId)).thenReturn(Mono.just(0L));
        when(roleRepository.deleteById(roleId)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(roleService.deleteRole(roleId))
            .verifyComplete();
    }

    @Test
    void deleteRole_ShouldFailForSystemRole() {
        // Given
        UUID roleId = role.getId();
        role.setIsSystemRole(true);

        when(roleRepository.findById(roleId)).thenReturn(Mono.just(role));

        // When & Then
        StepVerifier.create(roleService.deleteRole(roleId))
            .expectErrorMatches(throwable ->
                throwable instanceof IllegalArgumentException &&
                    throwable.getMessage().contains("Cannot delete system role"))
            .verify();
    }

    @Test
    void getRolesByOrganization_ShouldReturnRoles() {
        // Given
        when(roleRepository.findByOrganizationId(organizationId))
            .thenReturn(Flux.just(role));
        when(roleMapper.toResponse(role)).thenReturn(roleResponse);

        // When & Then
        StepVerifier.create(roleService.getRolesByOrganization(organizationId))
            .assertNext(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getOrganizationId()).isEqualTo(organizationId);
            })
            .verifyComplete();
    }

    @Test
    void cloneRole_ShouldCloneRoleSuccessfully() {
        // Given
        UUID roleId = role.getId();
        String newName = "Cloned Role";

        when(roleRepository.findById(roleId)).thenReturn(Mono.just(role));
        when(roleRepository.countByOrganizationIdAndName(organizationId, newName))
            .thenReturn(Mono.just(0L));
        when(roleRepository.save(any(Role.class))).thenReturn(Mono.just(role));
        when(roleMapper.toResponse(any(Role.class))).thenReturn(roleResponse);

        // When & Then
        StepVerifier.create(roleService.cloneRole(roleId, newName, createdBy))
            .assertNext(response -> {
                assertThat(response).isNotNull();
            })
            .verifyComplete();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\application\service\SubscriptionPlanReactiveServiceTest.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import inc.yowyob.rental_api_reactive.persistence.repository.SubscriptionPlanReactiveRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.math.BigDecimal;
import java.util.UUID;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class SubscriptionPlanReactiveServiceTest {

    @Mock
    private SubscriptionPlanReactiveRepository subscriptionPlanRepository;

    @InjectMocks
    private SubscriptionPlanReactiveService subscriptionPlanService;

    private SubscriptionPlan testPlan;
    private UUID testPlanId;

    @BeforeEach
    void setUp() {
        testPlanId = UUID.randomUUID();
        testPlan = new SubscriptionPlan();
        testPlan.setId(testPlanId);
        testPlan.setName("BASIC");
        testPlan.setDescription("Plan de base");
        testPlan.setPrice(new BigDecimal("29.99"));
        testPlan.setCurrency("XAF");
        testPlan.setDurationDays(30);
        testPlan.setIsActive(true);
    }

    @Test
    void getAllActivePlans_ShouldReturnAllActivePlans() {
        // Given
        when(subscriptionPlanRepository.findAllActive())
            .thenReturn(Flux.just(testPlan));

        // When & Then
        StepVerifier.create(subscriptionPlanService.getAllActivePlans())
            .expectNext(testPlan)
            .verifyComplete();
    }

    @Test
    void getPlanById_WhenPlanExists_ShouldReturnPlan() {
        // Given
        when(subscriptionPlanRepository.findById(testPlanId))
            .thenReturn(Mono.just(testPlan));

        // When & Then
        StepVerifier.create(subscriptionPlanService.getPlanById(testPlanId))
            .expectNext(testPlan)
            .verifyComplete();
    }

    @Test
    void getPlanById_WhenPlanNotExists_ShouldReturnEmpty() {
        // Given
        when(subscriptionPlanRepository.findById(testPlanId))
            .thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(subscriptionPlanService.getPlanById(testPlanId))
            .verifyComplete();
    }

    @Test
    void getPopularPlans_ShouldReturnPopularPlans() {
        // Given
        testPlan.setIsPopular(true);
        when(subscriptionPlanRepository.findPopularPlans())
            .thenReturn(Flux.just(testPlan));

        // When & Then
        StepVerifier.create(subscriptionPlanService.getPopularPlans())
            .expectNext(testPlan)
            .verifyComplete();
    }

    @Test
    void savePlan_ShouldSaveAndReturnPlan() {
        // Given
        when(subscriptionPlanRepository.save(any(SubscriptionPlan.class)))
            .thenReturn(Mono.just(testPlan));

        // When & Then
        StepVerifier.create(subscriptionPlanService.savePlan(testPlan))
            .expectNext(testPlan)
            .verifyComplete();
    }

    @Test
    void deactivatePlan_WhenPlanExists_ShouldDeactivateAndReturn() {
        // Given
        when(subscriptionPlanRepository.findById(testPlanId))
            .thenReturn(Mono.just(testPlan));
        when(subscriptionPlanRepository.save(any(SubscriptionPlan.class)))
            .thenReturn(Mono.just(testPlan));

        // When & Then
        StepVerifier.create(subscriptionPlanService.deactivatePlan(testPlanId))
            .expectNextMatches(plan -> !plan.getIsActive())
            .verifyComplete();
    }

    @Test
    void deactivatePlan_WhenPlanNotExists_ShouldReturnError() {
        // Given
        when(subscriptionPlanRepository.findById(testPlanId))
            .thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(subscriptionPlanService.deactivatePlan(testPlanId))
            .expectError(RuntimeException.class)
            .verify();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\application\service\UserReactiveServiceTest.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.dto.UserType;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UserReactiveServiceTest {

    @Mock
    private UserReactiveRepository userRepository;

    @InjectMocks
    private UserReactiveService userService;

    private User testUser1;
    private User testUser2;
    private UUID testUserId1;
    private UUID testUserId2;
    private UUID organizationId;

    @BeforeEach
    void setUp() {
        testUserId1 = UUID.randomUUID();
        testUserId2 = UUID.randomUUID();
        organizationId = UUID.randomUUID();

        testUser1 = new User();
        testUser1.setId(testUserId1);
        testUser1.setEmail("john.doe@example.com");
        testUser1.setFirstName("John");
        testUser1.setLastName("Doe");
        testUser1.setPhone("+237123456789");
        testUser1.setUserType(UserType.CLIENT);
        testUser1.setOrganizationId(organizationId);
        testUser1.setIsEmailVerified(true);
        testUser1.setIsPhoneVerified(false);
        testUser1.setPreferredLanguage("fr");
        testUser1.setTimezone("Africa/Douala");
        testUser1.setIsActive(true);
        testUser1.setCreatedAt(LocalDateTime.now());

        testUser2 = new User();
        testUser2.setId(testUserId2);
        testUser2.setEmail("jane.smith@example.com");
        testUser2.setFirstName("Jane");
        testUser2.setLastName("Smith");
        testUser2.setPhone("+237987654321");
        testUser2.setUserType(UserType.AGENCY_MANAGER);
        testUser2.setOrganizationId(organizationId);
        testUser2.setIsEmailVerified(false);
        testUser2.setIsPhoneVerified(true);
        testUser2.setPreferredLanguage("en");
        testUser2.setTimezone("Africa/Douala");
        testUser2.setIsActive(true);
        testUser2.setCreatedAt(LocalDateTime.now());
    }

    @Test
    void findAll_ShouldReturnAllUsers_WhenUsersExist() {
        // Given
        when(userRepository.findAll()).thenReturn(Flux.just(testUser1, testUser2));

        // When & Then
        StepVerifier.create(userService.findAll())
            .expectNextMatches(userResponse -> {
                assertThat(userResponse.getEmail()).isEqualTo("john.doe@example.com");
                assertThat(userResponse.getFirstName()).isEqualTo("John");
                assertThat(userResponse.getLastName()).isEqualTo("Doe");
                assertThat(userResponse.getFullName()).isEqualTo("John Doe");
                assertThat(userResponse.getUserType()).isEqualTo(UserType.CLIENT);
                assertThat(userResponse.getIsEmailVerified()).isTrue();
                return true;
            })
            .expectNextMatches(userResponse -> {
                assertThat(userResponse.getEmail()).isEqualTo("jane.smith@example.com");
                assertThat(userResponse.getFirstName()).isEqualTo("Jane");
                assertThat(userResponse.getUserType()).isEqualTo(UserType.AGENCY_MANAGER);
                assertThat(userResponse.getIsPhoneVerified()).isTrue();
                return true;
            })
            .verifyComplete();

        verify(userRepository, times(1)).findAll();
    }

    @Test
    void findAll_ShouldReturnEmpty_WhenNoUsersExist() {
        // Given
        when(userRepository.findAll()).thenReturn(Flux.empty());

        // When & Then
        StepVerifier.create(userService.findAll())
            .verifyComplete();

        verify(userRepository, times(1)).findAll();
    }

    @Test
    void findById_ShouldReturnUser_WhenUserExists() {
        // Given
        when(userRepository.findById(testUserId1)).thenReturn(Mono.just(testUser1));

        // When & Then
        StepVerifier.create(userService.findById(testUserId1))
            .expectNextMatches(userResponse -> {
                assertThat(userResponse.getId()).isEqualTo(testUserId1);
                assertThat(userResponse.getEmail()).isEqualTo("john.doe@example.com");
                assertThat(userResponse.getPhone()).isEqualTo("+237123456789");
                assertThat(userResponse.getOrganizationId()).isEqualTo(organizationId);
                return true;
            })
            .verifyComplete();

        verify(userRepository, times(1)).findById(testUserId1);
    }

    @Test
    void findById_ShouldReturnEmpty_WhenUserNotExists() {
        // Given
        UUID nonExistentId = UUID.randomUUID();
        when(userRepository.findById(nonExistentId)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(userService.findById(nonExistentId))
            .verifyComplete();

        verify(userRepository, times(1)).findById(nonExistentId);
    }

    @Test
    void findByEmail_ShouldReturnUser_WhenEmailExists() {
        // Given
        String email = "john.doe@example.com";
        when(userRepository.findByEmail(email)).thenReturn(Mono.just(testUser1));

        // When & Then
        StepVerifier.create(userService.findByEmail(email))
            .expectNextMatches(userResponse -> {
                assertThat(userResponse.getEmail()).isEqualTo(email);
                assertThat(userResponse.getFirstName()).isEqualTo("John");
                return true;
            })
            .verifyComplete();

        verify(userRepository, times(1)).findByEmail(email);
    }

    @Test
    void findByEmail_ShouldReturnEmpty_WhenEmailNotExists() {
        // Given
        String nonExistentEmail = "nonexistent@example.com";
        when(userRepository.findByEmail(nonExistentEmail)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(userService.findByEmail(nonExistentEmail))
            .verifyComplete();

        verify(userRepository, times(1)).findByEmail(nonExistentEmail);
    }

    @Test
    void findByOrganizationId_ShouldReturnUsersInOrganization_WhenUsersExist() {
        // Given
        when(userRepository.findByOrganizationId(organizationId))
            .thenReturn(Flux.just(testUser1, testUser2));

        // When & Then
        StepVerifier.create(userService.findByOrganizationId(organizationId))
            .expectNextMatches(userResponse -> {
                assertThat(userResponse.getOrganizationId()).isEqualTo(organizationId);
                assertThat(userResponse.getEmail()).isEqualTo("john.doe@example.com");
                return true;
            })
            .expectNextMatches(userResponse -> {
                assertThat(userResponse.getOrganizationId()).isEqualTo(organizationId);
                assertThat(userResponse.getEmail()).isEqualTo("jane.smith@example.com");
                return true;
            })
            .verifyComplete();

        verify(userRepository, times(1)).findByOrganizationId(organizationId);
    }

    @Test
    void findByOrganizationId_ShouldReturnEmpty_WhenNoUsersInOrganization() {
        // Given
        UUID emptyOrganizationId = UUID.randomUUID();
        when(userRepository.findByOrganizationId(emptyOrganizationId))
            .thenReturn(Flux.empty());

        // When & Then
        StepVerifier.create(userService.findByOrganizationId(emptyOrganizationId))
            .verifyComplete();

        verify(userRepository, times(1)).findByOrganizationId(emptyOrganizationId);
    }

    @Test
    void existsByEmail_ShouldReturnTrue_WhenEmailExists() {
        // Given
        String existingEmail = "john.doe@example.com";
        when(userRepository.countByEmail(existingEmail)).thenReturn(Mono.just(1L));

        // When & Then
        StepVerifier.create(userService.existsByEmail(existingEmail))
            .expectNext(true)
            .verifyComplete();

        verify(userRepository, times(1)).countByEmail(existingEmail);
    }

    @Test
    void existsByEmail_ShouldReturnFalse_WhenEmailNotExists() {
        // Given
        String nonExistentEmail = "nonexistent@example.com";
        when(userRepository.countByEmail(nonExistentEmail)).thenReturn(Mono.just(0L));

        // When & Then
        StepVerifier.create(userService.existsByEmail(nonExistentEmail))
            .expectNext(false)
            .verifyComplete();

        verify(userRepository, times(1)).countByEmail(nonExistentEmail);
    }

    @Test
    void save_ShouldReturnSavedUser_WhenUserIsValid() {
        // Given
        User newUser = new User();
        newUser.setEmail("new.user@example.com");
        newUser.setFirstName("New");
        newUser.setLastName("User");
        newUser.setUserType(UserType.CLIENT);

        User savedUser = new User();
        savedUser.setId(UUID.randomUUID());
        savedUser.setEmail("new.user@example.com");
        savedUser.setFirstName("New");
        savedUser.setLastName("User");
        savedUser.setUserType(UserType.CLIENT);
        savedUser.setCreatedAt(LocalDateTime.now());
        savedUser.setIsActive(true);

        when(userRepository.save(any(User.class))).thenReturn(Mono.just(savedUser));

        // When & Then
        StepVerifier.create(userService.save(newUser))
            .expectNextMatches(userResponse -> {
                assertThat(userResponse.getEmail()).isEqualTo("new.user@example.com");
                assertThat(userResponse.getFirstName()).isEqualTo("New");
                assertThat(userResponse.getLastName()).isEqualTo("User");
                assertThat(userResponse.getFullName()).isEqualTo("New User");
                assertThat(userResponse.getUserType()).isEqualTo(UserType.CLIENT);
                assertThat(userResponse.getIsActive()).isTrue();
                return true;
            })
            .verifyComplete();

        verify(userRepository, times(1)).save(any(User.class));
    }

    @Test
    void deleteById_ShouldCompleteSuccessfully_WhenUserExists() {
        // Given
        when(userRepository.deleteById(testUserId1)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(userService.deleteById(testUserId1))
            .verifyComplete();

        verify(userRepository, times(1)).deleteById(testUserId1);
    }

    @Test
    void save_ShouldCallPrePersist_BeforeSaving() {
        // Given
        User newUser = new User();
        newUser.setEmail("test@example.com");
        newUser.setFirstName("Test");
        newUser.setLastName("User");
        newUser.setUserType(UserType.CLIENT);

        when(userRepository.save(any(User.class))).thenAnswer(invocation -> {
            User userToSave = invocation.getArgument(0);
            // Vérifier que prePersist a été appelé
            assertThat(userToSave.getId()).isNotNull();
            assertThat(userToSave.getCreatedAt()).isNotNull();
            assertThat(userToSave.getUpdatedAt()).isNotNull();
            return Mono.just(userToSave);
        });

        // When & Then
        StepVerifier.create(userService.save(newUser))
            .expectNextCount(1)
            .verifyComplete();

        verify(userRepository, times(1)).save(any(User.class));
    }

    @Test
    void findByEmail_ShouldHandleNullEmail_Gracefully() {
        // Given
        when(userRepository.findByEmail(null)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(userService.findByEmail(null))
            .verifyComplete();

        verify(userRepository, times(1)).findByEmail(null);
    }

    @Test
    void existsByEmail_ShouldHandleEmptyEmail_Gracefully() {
        // Given
        String emptyEmail = "";
        when(userRepository.countByEmail(emptyEmail)).thenReturn(Mono.just(0L));

        // When & Then
        StepVerifier.create(userService.existsByEmail(emptyEmail))
            .expectNext(false)
            .verifyComplete();

        verify(userRepository, times(1)).countByEmail(emptyEmail);
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\application\service\UserRoleReactiveServiceTest.java ---

```java
package inc.yowyob.rental_api_reactive.application.service;

import inc.yowyob.rental_api_reactive.application.service.UserRoleReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.AssignRoleRequest;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.UserRoleResponse;
import inc.yowyob.rental_api_reactive.persistence.entity.Role;
import inc.yowyob.rental_api_reactive.persistence.entity.User;
import inc.yowyob.rental_api_reactive.persistence.entity.UserRole;
import inc.yowyob.rental_api_reactive.persistence.repository.RoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.UserReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.UserRoleReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.mapper.UserRoleMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class UserRoleReactiveServiceTest {

    @Mock
    private UserRoleReactiveRepository userRoleRepository;

    @Mock
    private RoleReactiveRepository roleRepository;

    @Mock
    private UserReactiveRepository userRepository;

    @Mock
    private UserRoleMapper userRoleMapper;

    @InjectMocks
    private UserRoleReactiveService userRoleService;

    private UUID userId;
    private UUID roleId;
    private UUID organizationId;
    private UUID assignedBy;
    private AssignRoleRequest assignRequest;
    private User user;
    private Role role;
    private UserRole userRole;
    private UserRoleResponse userRoleResponse;

    @BeforeEach
    void setUp() {
        userId = UUID.randomUUID();
        roleId = UUID.randomUUID();
        organizationId = UUID.randomUUID();
        assignedBy = UUID.randomUUID();

        assignRequest = AssignRoleRequest.builder()
            .userId(userId)
            .roleId(roleId)
            .organizationId(organizationId)
            .expiresAt(LocalDateTime.now().plusMonths(6))
            .build();

        user = new User();
        user.setId(userId);
        user.setEmail("test@example.com");

        role = new Role("Test Role", "Test description", organizationId);
        role.setId(roleId);

        userRole = new UserRole(userId, roleId, organizationId);
        userRole.setId(UUID.randomUUID());
        userRole.setAssignedBy(assignedBy);

        userRoleResponse = UserRoleResponse.builder()
            .id(userRole.getId())
            .userId(userId)
            .roleId(roleId)
            .organizationId(organizationId)
            .isActive(true)
            .build();
    }

    @Test
    void assignRole_ShouldAssignRoleSuccessfully() {
        // Given
        when(userRepository.findById(userId)).thenReturn(Mono.just(user));
        when(roleRepository.findById(roleId)).thenReturn(Mono.just(role));
        when(userRoleRepository.findByUserIdAndRoleId(userId, roleId))
            .thenReturn(Mono.empty());
        when(userRoleRepository.save(any(UserRole.class))).thenReturn(Mono.just(userRole));
        when(userRoleMapper.toResponse(userRole)).thenReturn(userRoleResponse);

        // When & Then
        StepVerifier.create(userRoleService.assignRole(assignRequest, assignedBy))
            .assertNext(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getUserId()).isEqualTo(userId);
                assertThat(response.getRoleId()).isEqualTo(roleId);
                assertThat(response.getOrganizationId()).isEqualTo(organizationId);
            })
            .verifyComplete();
    }

    @Test
    void assignRole_ShouldFailWhenUserNotFound() {
        // Given
        when(userRepository.findById(userId)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(userRoleService.assignRole(assignRequest, assignedBy))
            .expectErrorMatches(throwable ->
                throwable instanceof IllegalArgumentException &&
                    throwable.getMessage().contains("User not found"))
            .verify();
    }

    @Test
    void assignRole_ShouldFailWhenRoleNotFound() {
        // Given
        when(userRepository.findById(userId)).thenReturn(Mono.just(user));
        when(roleRepository.findById(roleId)).thenReturn(Mono.empty());

        // When & Then
        StepVerifier.create(userRoleService.assignRole(assignRequest, assignedBy))
            .expectErrorMatches(throwable ->
                throwable instanceof IllegalArgumentException &&
                    throwable.getMessage().contains("Role not found"))
            .verify();
    }

    @Test
    void assignRole_ShouldFailWhenRoleAlreadyAssigned() {
        // Given
        userRole.setIsActive(true);
        when(userRepository.findById(userId)).thenReturn(Mono.just(user));
        when(roleRepository.findById(roleId)).thenReturn(Mono.just(role));
        when(userRoleRepository.findByUserIdAndRoleId(userId, roleId))
            .thenReturn(Mono.just(userRole));

        // When & Then
        StepVerifier.create(userRoleService.assignRole(assignRequest, assignedBy))
            .expectErrorMatches(throwable ->
                throwable instanceof IllegalArgumentException &&
                    throwable.getMessage().contains("User already has this role"))
            .verify();
    }

    @Test
    void revokeRole_ShouldRevokeRoleSuccessfully() {
        // Given
        when(userRoleRepository.findByUserIdAndRoleId(userId, roleId))
            .thenReturn(Mono.just(userRole));
        when(userRoleRepository.save(any(UserRole.class))).thenReturn(Mono.just(userRole));

        // When & Then
        StepVerifier.create(userRoleService.revokeRole(userId, roleId, assignedBy))
            .verifyComplete();
    }

    @Test
    void getUserRoles_ShouldReturnUserRoles() {
        // Given
        when(userRoleRepository.findActiveByUserId(userId))
            .thenReturn(Flux.just(userRole));
        when(userRoleMapper.toResponse(userRole)).thenReturn(userRoleResponse);

        // When & Then
        StepVerifier.create(userRoleService.getUserRoles(userId))
            .assertNext(response -> {
                assertThat(response).isNotNull();
                assertThat(response.getUserId()).isEqualTo(userId);
            })
            .verifyComplete();
    }

    @Test
    void activateRole_ShouldActivateRoleSuccessfully() {
        // Given
        userRole.setIsActive(false);
        when(userRoleRepository.findByUserIdAndRoleId(userId, roleId))
            .thenReturn(Mono.just(userRole));
        when(userRoleRepository.save(any(UserRole.class))).thenReturn(Mono.just(userRole));
        when(userRoleMapper.toResponse(any(UserRole.class))).thenReturn(userRoleResponse);

        // When & Then
        StepVerifier.create(userRoleService.activateRole(userId, roleId))
            .assertNext(response -> {
                assertThat(response).isNotNull();
            })
            .verifyComplete();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\infrastructure\config\TestDataBuilder.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.config;

import inc.yowyob.rental_api_reactive.persistence.entity.OnboardingSession;
import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.UUID;

/**
 * Builder pour créer des données de test
 */
public class TestDataBuilder {

    public static SubscriptionPlan createTestSubscriptionPlan(String name, BigDecimal price) {
        SubscriptionPlan plan = new SubscriptionPlan();
        plan.setId(UUID.randomUUID());
        plan.setName(name);
        plan.setDescription("Plan de test " + name);
        plan.setPrice(price);
        plan.setCurrency("XAF");
        plan.setDurationDays(30);
        plan.setMaxVehicles(10);
        plan.setMaxDrivers(5);
        plan.setMaxAgencies(2);
        plan.setMaxUsers(8);
        plan.setIsPopular(false);
        plan.setIsCustom(false);
        plan.setSortOrder(1);
        plan.setFeatures(Map.of(
            "geofencing", false,
            "chat", true,
            "advanced_reports", false
        ));
        plan.prePersist();
        return plan;
    }

    public static OnboardingSession createTestOnboardingSession() {
        OnboardingSession session = new OnboardingSession();
        session.setId(UUID.randomUUID());
        session.setSessionToken("test-token-" + UUID.randomUUID());
        session.setCurrentStep(1);
        session.setMaxStep(3);
        session.setIsCompleted(false);
        session.setExpiresAt(LocalDateTime.now().plusHours(24));
        session.prePersist();
        return session;
    }

    public static OwnerInfoRequest createTestOwnerInfoRequest() {
        OwnerInfoRequest request = new OwnerInfoRequest();
        request.setFirstName("John");
        request.setLastName("Doe");
        request.setEmail("john.doe@example.com");
        request.setPhone("+237123456789");
        request.setIdCardNumber("ID123456789");
        request.setAddress("123 Test Street");
        request.setCity("Yaoundé");
        request.setCountry("Cameroun");
        request.setDateOfBirth(LocalDate.of(1990, 1, 1));
        request.setNationality("Camerounaise");
        request.setProfession("Entrepreneur");
        return request;
    }

    public static OrganizationInfoRequest createTestOrganizationInfoRequest() {
        OrganizationInfoRequest request = new OrganizationInfoRequest();
        request.setOrganizationName("Test Rental Company");
        request.setOrganizationType("ENTERPRISE");
        request.setRegistrationNumber("RC123456");
        request.setTaxNumber("TAX789012");
        request.setAddress("456 Business Avenue");
        request.setCity("Douala");
        request.setCountry("Cameroun");
        request.setDescription("Entreprise de location de véhicules de test");
        request.setAllowsDriverRental(true);
        request.setAllowsDriverlessRental(true);
        request.setRequireDeposit(true);
        request.setDefaultDepositAmount(50000.0);
        request.setCancellationPolicy("Annulation gratuite 24h avant");
        return request;
    }

    public static SubscriptionInfoRequest createTestSubscriptionInfoRequest(UUID planId) {
        SubscriptionInfoRequest request = new SubscriptionInfoRequest();
        request.setSubscriptionPlanId(planId);
        request.setPaymentMethod("CARD");
        request.setPaymentToken("test-payment-token");
        request.setBillingAddress("789 Billing Street");
        request.setBillingCity("Yaoundé");
        request.setBillingCountry("Cameroun");
        request.setAcceptTerms(true);
        request.setNewsletterSubscription(false);
        return request;
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\HealthReactiveControllerTest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.reactive.server.WebTestClient;

@WebFluxTest(HealthReactiveController.class)
class HealthReactiveControllerTest {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    void health_ShouldReturnHealthStatus() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/health")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Application is healthy")
            .jsonPath("$.data").isNotEmpty()
            .jsonPath("$.data.status").isEqualTo("UP")
            .jsonPath("$.data.timestamp").isNotEmpty()
            .jsonPath("$.data.service").isEqualTo("Rental API Reactive")
            .jsonPath("$.data.version").isEqualTo("1.0.0")
            .jsonPath("$.data.environment").isEqualTo("development");
    }

    @Test
    void readiness_ShouldReturnReadinessStatus() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/health/readiness")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Application is ready")
            .jsonPath("$.data").isNotEmpty()
            .jsonPath("$.data.status").isEqualTo("READY")
            .jsonPath("$.data.timestamp").isNotEmpty()
            .jsonPath("$.data.checks").isNotEmpty()
            .jsonPath("$.data.checks.database").isEqualTo("UP")
            .jsonPath("$.data.checks.memory").isEqualTo("OK")
            .jsonPath("$.data.checks.disk").isEqualTo("OK");
    }

    @Test
    void liveness_ShouldReturnLivenessStatus() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/health/liveness")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Application is alive")
            .jsonPath("$.data").isNotEmpty()
            .jsonPath("$.data.status").isEqualTo("ALIVE")
            .jsonPath("$.data.timestamp").isNotEmpty()
            .jsonPath("$.data.uptime").isEqualTo("running");
    }

    @Test
    void health_ShouldReturnJsonContentType() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/health")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON);
    }

    @Test
    void health_ShouldRejectNonJsonAccept() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/health")
            .accept(MediaType.TEXT_PLAIN)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void readiness_ShouldHaveCorrectStructure() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/health/readiness")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").exists()
            .jsonPath("$.message").exists()
            .jsonPath("$.data").exists()
            .jsonPath("$.timestamp").exists()
            .jsonPath("$.status_code").exists();
    }

    @Test
    void liveness_ShouldHaveCorrectStructure() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/health/liveness")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").exists()
            .jsonPath("$.message").exists()
            .jsonPath("$.data").exists()
            .jsonPath("$.timestamp").exists()
            .jsonPath("$.status_code").exists();
    }

    @Test
    void allHealthEndpoints_ShouldReturnStatusCode200() {
        // Health endpoint
        webTestClient.get()
            .uri("/api/v1/health")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.status_code").isEqualTo(200);

        // Readiness endpoint
        webTestClient.get()
            .uri("/api/v1/health/readiness")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.status_code").isEqualTo(200);

        // Liveness endpoint
        webTestClient.get()
            .uri("/api/v1/health/liveness")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.status_code").isEqualTo(200);
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\OrganizationReactiveControllerTest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.service.OrganizationReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.OrganizationResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.reactive.server.WebTestClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.when;

@WebFluxTest(OrganizationReactiveController.class)
class OrganizationReactiveControllerTest {

    @Autowired
    private WebTestClient webTestClient;

    @MockBean
    private OrganizationReactiveService organizationService;

    private OrganizationResponse testOrgResponse1;
    private OrganizationResponse testOrgResponse2;
    private UUID organizationId1;
    private UUID organizationId2;
    private UUID ownerId1;
    private UUID ownerId2;

    @BeforeEach
    void setUp() {
        organizationId1 = UUID.randomUUID();
        organizationId2 = UUID.randomUUID();
        ownerId1 = UUID.randomUUID();
        ownerId2 = UUID.randomUUID();

        testOrgResponse1 = new OrganizationResponse();
        testOrgResponse1.setId(organizationId1);
        testOrgResponse1.setName("YowyoB Transport");
        testOrgResponse1.setDescription("Entreprise de transport urbain à Douala");
        testOrgResponse1.setBusinessType("Transport");
        testOrgResponse1.setRegistrationNumber("CM-DLA-2024-001");
        testOrgResponse1.setOwnerId(ownerId1);
        testOrgResponse1.setContactEmail("contact@yowyob.transport");
        testOrgResponse1.setContactPhone("+237123456789");
        testOrgResponse1.setWebsite("https://transport.yowyob.inc");
        testOrgResponse1.setFullAddress("Rue de la République, Immeuble Moderne, Douala, Littoral 00237, CM");
        testOrgResponse1.setCity("Douala");
        testOrgResponse1.setCountry("CM");
        testOrgResponse1.setMaxVehicles(50);
        testOrgResponse1.setMaxDrivers(25);
        testOrgResponse1.setMaxAgencies(5);
        testOrgResponse1.setMaxUsers(20);
        testOrgResponse1.setCurrency("XAF");
        testOrgResponse1.setTimezone("Africa/Douala");
        testOrgResponse1.setLogoUrl("https://cdn.yowyob.inc/logos/transport.png");
        testOrgResponse1.setIsVerified(true);
        testOrgResponse1.setVerificationDate(LocalDateTime.now().minusDays(30));
        testOrgResponse1.setCreatedAt(LocalDateTime.now().minusDays(60));
        testOrgResponse1.setIsActive(true);

        testOrgResponse2 = new OrganizationResponse();
        testOrgResponse2.setId(organizationId2);
        testOrgResponse2.setName("Cameroon Logistics");
        testOrgResponse2.setDescription("Société de logistique et transport de marchandises");
        testOrgResponse2.setBusinessType("Logistics");
        testOrgResponse2.setRegistrationNumber("CM-YAO-2024-002");
        testOrgResponse2.setOwnerId(ownerId2);
        testOrgResponse2.setContactEmail("info@cameroon-logistics.cm");
        testOrgResponse2.setContactPhone("+237987654321");
        testOrgResponse2.setCity("Yaoundé");
        testOrgResponse2.setCountry("CM");
        testOrgResponse2.setMaxVehicles(30);
        testOrgResponse2.setMaxDrivers(15);
        testOrgResponse2.setMaxAgencies(3);
        testOrgResponse2.setMaxUsers(10);
        testOrgResponse2.setCurrency("XAF");
        testOrgResponse2.setTimezone("Africa/Douala");
        testOrgResponse2.setIsVerified(false);
        testOrgResponse2.setCreatedAt(LocalDateTime.now().minusDays(15));
        testOrgResponse2.setIsActive(true);
    }

    @Test
    void getAllOrganizations_ShouldReturnSuccessResponse_WhenOrganizationsExist() {
        // Given
        when(organizationService.findAll()).thenReturn(Flux.just(testOrgResponse1, testOrgResponse2));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(false)
            .jsonPath("$.message").isEqualTo("Organisation non trouvée")
            .jsonPath("$.status_code").isEqualTo(404);
    }

    @Test
    void getOrganizationById_ShouldReturnBadRequest_WhenIdIsInvalid() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/{id}", "invalid-uuid")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isBadRequest();
    }

    @Test
    void getOrganizationByOwner_ShouldReturnOrganization_WhenOwnerExists() {
        // Given
        when(organizationService.findByOwnerId(ownerId1)).thenReturn(Mono.just(testOrgResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/owner/{ownerId}", ownerId1)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Organisation du propriétaire trouvée")
            .jsonPath("$.data.owner_id").isEqualTo(ownerId1.toString())
            .jsonPath("$.data.name").isEqualTo("YowyoB Transport");
    }

    @Test
    void getOrganizationByOwner_ShouldReturnNotFound_WhenOwnerHasNoOrganization() {
        // Given
        UUID ownerWithoutOrg = UUID.randomUUID();
        when(organizationService.findByOwnerId(ownerWithoutOrg)).thenReturn(Mono.empty());

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/owner/{ownerId}", ownerWithoutOrg)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(false)
            .jsonPath("$.message").isEqualTo("Organisation non trouvée pour ce propriétaire")
            .jsonPath("$.status_code").isEqualTo(404);
    }

    @Test
    void getOrganizationByOwner_ShouldReturnBadRequest_WhenOwnerIdIsInvalid() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/owner/{ownerId}", "invalid-uuid")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isBadRequest();
    }

    @Test
    void getActiveOrganizations_ShouldReturnActiveOrganizations_WhenActiveOrganizationsExist() {
        // Given
        when(organizationService.findAllActive()).thenReturn(Flux.just(testOrgResponse1, testOrgResponse2));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/active")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Organisations actives récupérées")
            .jsonPath("$.data").isNotEmpty();
    }

    @Test
    void getActiveOrganizations_ShouldReturnEmpty_WhenNoActiveOrganizations() {
        // Given
        when(organizationService.findAllActive()).thenReturn(Flux.empty());

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/active")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Organisations actives récupérées");
    }

    @Test
    void checkOrganizationNameExists_ShouldReturnTrue_WhenNameExists() {
        // Given
        String existingName = "YowyoB Transport";
        when(organizationService.existsByName(existingName)).thenReturn(Mono.just(true));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/exists/{name}", existingName)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Nom existe");
    }

    @Test
    void checkOrganizationNameExists_ShouldReturnFalse_WhenNameNotExists() {
        // Given
        String nonExistentName = "Non Existent Organization";
        when(organizationService.existsByName(nonExistentName)).thenReturn(Mono.just(false));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/exists/{name}", nonExistentName)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isEqualTo(false)
            .jsonPath("$.message").isEqualTo("Nom disponible");
    }

    @Test
    void checkOrganizationNameExists_ShouldHandleSpecialCharacters_InName() {
        // Given
        String nameWithSpecialChars = "Org & Co. (Ltd)";
        when(organizationService.existsByName(nameWithSpecialChars)).thenReturn(Mono.just(false));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/exists/{name}", nameWithSpecialChars)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isEqualTo(false);
    }

    @Test
    void checkOrganizationNameExists_ShouldHandleEmptyName_Gracefully() {
        // Given
        String emptyName = "";
        when(organizationService.existsByName(emptyName)).thenReturn(Mono.just(false));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/exists/{name}", emptyName)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isEqualTo(false);
    }

    @Test
    void getAllOrganizations_ShouldHandleServiceError_Gracefully() {
        // Given
        when(organizationService.findAll()).thenReturn(Flux.error(new RuntimeException("Service error")));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void getOrganizationById_ShouldHandleServiceError_Gracefully() {
        // Given
        when(organizationService.findById(organizationId1)).thenReturn(Mono.error(new RuntimeException("Service error")));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/{id}", organizationId1)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void getOrganizationByOwner_ShouldHandleServiceError_Gracefully() {
        // Given
        when(organizationService.findByOwnerId(ownerId1)).thenReturn(Mono.error(new RuntimeException("Service error")));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/owner/{ownerId}", ownerId1)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void checkOrganizationNameExists_ShouldHandleServiceError_Gracefully() {
        // Given
        String name = "Test Organization";
        when(organizationService.existsByName(name)).thenReturn(Mono.error(new RuntimeException("Service error")));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/exists/{name}", name)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void getAllOrganizations_ShouldHaveCorrectContentType() {
        // Given
        when(organizationService.findAll()).thenReturn(Flux.just(testOrgResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON);
    }

    @Test
    void getAllOrganizations_ShouldAcceptJsonOnly() {
        // Given
        when(organizationService.findAll()).thenReturn(Flux.just(testOrgResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations")
            .accept(MediaType.TEXT_PLAIN)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void getOrganizationById_ShouldReturnCorrectJsonStructure() {
        // Given
        when(organizationService.findById(organizationId1)).thenReturn(Mono.just(testOrgResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/{id}", organizationId1)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").exists()
            .jsonPath("$.message").exists()
            .jsonPath("$.data").exists()
            .jsonPath("$.timestamp").exists()
            .jsonPath("$.status_code").exists()
            .jsonPath("$.data.id").exists()
            .jsonPath("$.data.name").exists()
            .jsonPath("$.data.business_type").exists()
            .jsonPath("$.data.owner_id").exists()
            .jsonPath("$.data.is_active").exists();
    }

    @Test
    void getActiveOrganizations_ShouldFilterActiveOrganizations() {
        // Given
        when(organizationService.findAllActive()).thenReturn(Flux.just(testOrgResponse1, testOrgResponse2));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/organizations/active")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isArray();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\infrastructure\web\controller\UserReactiveControllerTest.java ---

```java
package inc.yowyob.rental_api_reactive.infrastructure.web.controller;

import inc.yowyob.rental_api_reactive.application.dto.UserType;
import inc.yowyob.rental_api_reactive.application.service.UserReactiveService;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.UserResponse;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.reactive.server.WebTestClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

import static org.mockito.Mockito.when;

@WebFluxTest(UserReactiveController.class)
class UserReactiveControllerTest {

    @Autowired
    private WebTestClient webTestClient;

    @MockBean
    private UserReactiveService userService;

    private UserResponse testUserResponse1;
    private UserResponse testUserResponse2;
    private UUID testUserId1;
    private UUID testUserId2;
    private UUID organizationId;

    @BeforeEach
    void setUp() {
        testUserId1 = UUID.randomUUID();
        testUserId2 = UUID.randomUUID();
        organizationId = UUID.randomUUID();

        testUserResponse1 = new UserResponse();
        testUserResponse1.setId(testUserId1);
        testUserResponse1.setEmail("john.doe@example.com");
        testUserResponse1.setFirstName("John");
        testUserResponse1.setLastName("Doe");
        testUserResponse1.setFullName("John Doe");
        testUserResponse1.setPhone("+237123456789");
        testUserResponse1.setUserType(UserType.CLIENT);
        testUserResponse1.setOrganizationId(organizationId);
        testUserResponse1.setProfilePicture("https://cdn.example.com/profiles/john.jpg");
        testUserResponse1.setIsEmailVerified(true);
        testUserResponse1.setIsPhoneVerified(false);
        testUserResponse1.setPreferredLanguage("fr");
        testUserResponse1.setTimezone("Africa/Douala");
        testUserResponse1.setLastLoginAt(LocalDateTime.now().minusHours(2));
        testUserResponse1.setCreatedAt(LocalDateTime.now().minusDays(30));
        testUserResponse1.setIsActive(true);

        testUserResponse2 = new UserResponse();
        testUserResponse2.setId(testUserId2);
        testUserResponse2.setEmail("jane.smith@example.com");
        testUserResponse2.setFirstName("Jane");
        testUserResponse2.setLastName("Smith");
        testUserResponse2.setFullName("Jane Smith");
        testUserResponse2.setPhone("+237987654321");
        testUserResponse2.setUserType(UserType.AGENCY_MANAGER);
        testUserResponse2.setOrganizationId(organizationId);
        testUserResponse2.setIsEmailVerified(false);
        testUserResponse2.setIsPhoneVerified(true);
        testUserResponse2.setPreferredLanguage("en");
        testUserResponse2.setTimezone("Africa/Douala");
        testUserResponse2.setLastLoginAt(LocalDateTime.now().minusMinutes(30));
        testUserResponse2.setCreatedAt(LocalDateTime.now().minusDays(15));
        testUserResponse2.setIsActive(true);
    }

    @Test
    void getAllUsers_ShouldReturnSuccessResponse_WhenUsersExist() {
        // Given
        when(userService.findAll()).thenReturn(Flux.just(testUserResponse1, testUserResponse2));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Utilisateurs récupérés avec succès")
            .jsonPath("$.data").isNotEmpty()
            .jsonPath("$.timestamp").isNotEmpty()
            .jsonPath("$.status_code").isEqualTo(200);
    }

    @Test
    void getAllUsers_ShouldReturnSuccessResponse_WhenNoUsersExist() {
        // Given
        when(userService.findAll()).thenReturn(Flux.empty());

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON)
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Utilisateurs récupérés avec succès");
    }

    @Test
    void getUserById_ShouldReturnUser_WhenUserExists() {
        // Given
        when(userService.findById(testUserId1)).thenReturn(Mono.just(testUserResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/{id}", testUserId1)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Utilisateur trouvé")
            .jsonPath("$.data.id").isEqualTo(testUserId1.toString())
            .jsonPath("$.data.email").isEqualTo("john.doe@example.com")
            .jsonPath("$.data.first_name").isEqualTo("John")
            .jsonPath("$.data.last_name").isEqualTo("Doe")
            .jsonPath("$.data.full_name").isEqualTo("John Doe")
            .jsonPath("$.data.phone").isEqualTo("+237123456789")
            .jsonPath("$.data.user_type").isEqualTo("CLIENT")
            .jsonPath("$.data.organization_id").isEqualTo(organizationId.toString())
            .jsonPath("$.data.is_email_verified").isEqualTo(true)
            .jsonPath("$.data.is_phone_verified").isEqualTo(false)
            .jsonPath("$.data.preferred_language").isEqualTo("fr")
            .jsonPath("$.data.timezone").isEqualTo("Africa/Douala")
            .jsonPath("$.data.is_active").isEqualTo(true);
    }

    @Test
    void getUserById_ShouldReturnNotFound_WhenUserNotExists() {
        // Given
        UUID nonExistentId = UUID.randomUUID();
        when(userService.findById(nonExistentId)).thenReturn(Mono.empty());

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/{id}", nonExistentId)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(false)
            .jsonPath("$.message").isEqualTo("Utilisateur non trouvé")
            .jsonPath("$.status_code").isEqualTo(404);
    }

    @Test
    void getUserById_ShouldReturnBadRequest_WhenIdIsInvalid() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/{id}", "invalid-uuid")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isBadRequest();
    }

    @Test
    void getUserByEmail_ShouldReturnUser_WhenEmailExists() {
        // Given
        String email = "john.doe@example.com";
        when(userService.findByEmail(email)).thenReturn(Mono.just(testUserResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/email/{email}", email)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Utilisateur trouvé")
            .jsonPath("$.data.email").isEqualTo(email)
            .jsonPath("$.data.first_name").isEqualTo("John");
    }

    @Test
    void getUserByEmail_ShouldReturnNotFound_WhenEmailNotExists() {
        // Given
        String nonExistentEmail = "nonexistent@example.com";
        when(userService.findByEmail(nonExistentEmail)).thenReturn(Mono.empty());

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/email/{email}", nonExistentEmail)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(false)
            .jsonPath("$.message").isEqualTo("Utilisateur non trouvé")
            .jsonPath("$.status_code").isEqualTo(404);
    }

    @Test
    void getUserByEmail_ShouldHandleSpecialCharacters_InEmail() {
        // Given
        String emailWithSpecialChars = "test+special@example-domain.co.uk";
        when(userService.findByEmail(emailWithSpecialChars)).thenReturn(Mono.just(testUserResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/email/{email}", emailWithSpecialChars)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true);
    }

    @Test
    void getUsersByOrganization_ShouldReturnUsers_WhenUsersExistInOrganization() {
        // Given
        when(userService.findByOrganizationId(organizationId))
            .thenReturn(Flux.just(testUserResponse1, testUserResponse2));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/organization/{organizationId}", organizationId)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Utilisateurs de l'organisation récupérés")
            .jsonPath("$.data").isNotEmpty();
    }

    @Test
    void getUsersByOrganization_ShouldReturnEmpty_WhenNoUsersInOrganization() {
        // Given
        UUID emptyOrganizationId = UUID.randomUUID();
        when(userService.findByOrganizationId(emptyOrganizationId)).thenReturn(Flux.empty());

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/organization/{organizationId}", emptyOrganizationId)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Utilisateurs de l'organisation récupérés");
    }

    @Test
    void getUsersByOrganization_ShouldReturnBadRequest_WhenOrganizationIdIsInvalid() {
        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/organization/{organizationId}", "invalid-uuid")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isBadRequest();
    }

    @Test
    void checkEmailExists_ShouldReturnTrue_WhenEmailExists() {
        // Given
        String existingEmail = "john.doe@example.com";
        when(userService.existsByEmail(existingEmail)).thenReturn(Mono.just(true));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/exists/{email}", existingEmail)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isEqualTo(true)
            .jsonPath("$.message").isEqualTo("Email existe");
    }

    @Test
    void checkEmailExists_ShouldReturnFalse_WhenEmailNotExists() {
        // Given
        String nonExistentEmail = "nonexistent@example.com";
        when(userService.existsByEmail(nonExistentEmail)).thenReturn(Mono.just(false));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/exists/{email}", nonExistentEmail)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isEqualTo(false)
            .jsonPath("$.message").isEqualTo("Email disponible");
    }

    @Test
    void checkEmailExists_ShouldHandleInvalidEmail_Gracefully() {
        // Given
        String invalidEmail = "invalid-email-format";
        when(userService.existsByEmail(invalidEmail)).thenReturn(Mono.just(false));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/exists/{email}", invalidEmail)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").isEqualTo(false);
    }

    @Test
    void getAllUsers_ShouldHandleServiceError_Gracefully() {
        // Given
        when(userService.findAll()).thenReturn(Flux.error(new RuntimeException("Service error")));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void getUserById_ShouldHandleServiceError_Gracefully() {
        // Given
        when(userService.findById(testUserId1)).thenReturn(Mono.error(new RuntimeException("Service error")));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/{id}", testUserId1)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void checkEmailExists_ShouldHandleServiceError_Gracefully() {
        // Given
        String email = "test@example.com";
        when(userService.existsByEmail(email)).thenReturn(Mono.error(new RuntimeException("Service error")));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users/exists/{email}", email)
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().is5xxServerError();
    }

    @Test
    void getAllUsers_ShouldHaveCorrectContentType() {
        // Given
        when(userService.findAll()).thenReturn(Flux.just(testUserResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users")
            .exchange()
            .expectStatus().isOk()
            .expectHeader().contentType(MediaType.APPLICATION_JSON);
    }

    @Test
    void getAllUsers_ShouldAcceptJsonOnly() {
        // Given
        when(userService.findAll()).thenReturn(Flux.just(testUserResponse1));

        // When & Then
        webTestClient.get()
            .uri("/api/v1/users")
            .accept(MediaType.TEXT_PLAIN)
            .exchange()
            .expectStatus().is5xxServerError();
    }
}
```

--- PATH: src\test\java\inc\yowyob\rental_api_reactive\integration\OnboardingIntegrationTest.java ---

```java
package inc.yowyob.rental_api_reactive.integration;

import inc.yowyob.rental_api_reactive.infrastructure.config.TestDataBuilder;
import inc.yowyob.rental_api_reactive.infrastructure.web.dto.*;
import inc.yowyob.rental_api_reactive.persistence.entity.OnboardingSession;
import inc.yowyob.rental_api_reactive.persistence.entity.SubscriptionPlan;
import inc.yowyob.rental_api_reactive.persistence.repository.OnboardingSessionReactiveRepository;
import inc.yowyob.rental_api_reactive.persistence.repository.SubscriptionPlanReactiveRepository;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.reactive.server.WebTestClient;
import reactor.test.StepVerifier;

import java.math.BigDecimal;
import java.util.UUID;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWebTestClient
@ActiveProfiles("test")
class OnboardingIntegrationTest {

    @Autowired
    private WebTestClient webTestClient;

    @Autowired
    private OnboardingSessionReactiveRepository onboardingSessionRepository;

    @Autowired
    private SubscriptionPlanReactiveRepository subscriptionPlanRepository;

    private SubscriptionPlan testPlan;

    @BeforeEach
    void setUp() {
        // Nettoyer la base de données
        onboardingSessionRepository.deleteAll().block();
        subscriptionPlanRepository.deleteAll().block();

        // Créer un plan de test
        testPlan = TestDataBuilder.createTestSubscriptionPlan("TEST_PLAN", new BigDecimal("29.99"));
        testPlan = subscriptionPlanRepository.save(testPlan).block();
    }

    @Test
    void completeOnboardingFlow_ShouldWork() {
        // Approche simplifiée : créer directement une session de test
        OnboardingSession testSession = TestDataBuilder.createTestOnboardingSession();
        testSession = onboardingSessionRepository.save(testSession).block();
        UUID sessionId = testSession.getId();

        // Vérifier que l'endpoint de création fonctionne
        webTestClient
            .post()
            .uri("/api/v1/onboarding/session")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data.id").exists();

        // Étape 2: Sauvegarder les informations du propriétaire
        OwnerInfoRequest ownerInfo = TestDataBuilder.createTestOwnerInfoRequest();

        webTestClient
            .put()
            .uri("/api/v1/onboarding/session/{sessionId}/owner-info", sessionId)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(ownerInfo)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data.currentStep").isEqualTo(2);

        // Étape 3: Sauvegarder les informations de l'organisation
        OrganizationInfoRequest organizationInfo = TestDataBuilder.createTestOrganizationInfoRequest();

        webTestClient
            .put()
            .uri("/api/v1/onboarding/session/{sessionId}/organization-info", sessionId)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(organizationInfo)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data.currentStep").isEqualTo(3);

        // Étape 4: Finaliser l'onboarding
        SubscriptionInfoRequest subscriptionInfo = TestDataBuilder.createTestSubscriptionInfoRequest(testPlan.getId());

        webTestClient
            .post()
            .uri("/api/v1/onboarding/session/{sessionId}/complete", sessionId)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(subscriptionInfo)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data.organizationId").exists();

        // Vérifier que la session est marquée comme terminée
        StepVerifier.create(onboardingSessionRepository.findById(sessionId))
            .expectNextMatches(session1 -> session1.getIsCompleted())
            .verifyComplete();
    }

    /**
     * Méthode alternative pour un test plus simple et direct
     */
    @Test
    void completeOnboardingFlow_Alternative_ShouldWork() {
        // Étape 1: Créer une session d'onboarding et récupérer la réponse complète
        ApiResponse<OnboardingSessionResponse> sessionResponse = webTestClient
            .post()
            .uri("/api/v1/onboarding/session")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody(ApiResponse.class)
            .returnResult()
            .getResponseBody();

        Assertions.assertNotNull(sessionResponse);
        Assertions.assertNotNull(sessionResponse.getData());
        Assertions.assertTrue(sessionResponse.getSuccess());

        // Créer une session manuellement pour les tests
        OnboardingSession testSession = TestDataBuilder.createTestOnboardingSession();
        testSession = onboardingSessionRepository.save(testSession).block();
        UUID sessionId = testSession.getId();

        // Étape 2: Sauvegarder les informations du propriétaire
        OwnerInfoRequest ownerInfo = TestDataBuilder.createTestOwnerInfoRequest();

        webTestClient
            .put()
            .uri("/api/v1/onboarding/session/{sessionId}/owner-info", sessionId)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(ownerInfo)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true);

        // Étape 3: Sauvegarder les informations de l'organisation
        OrganizationInfoRequest organizationInfo = TestDataBuilder.createTestOrganizationInfoRequest();

        webTestClient
            .put()
            .uri("/api/v1/onboarding/session/{sessionId}/organization-info", sessionId)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(organizationInfo)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true);

        // Étape 4: Finaliser l'onboarding
        SubscriptionInfoRequest subscriptionInfo = TestDataBuilder.createTestSubscriptionInfoRequest(testPlan.getId());

        webTestClient
            .post()
            .uri("/api/v1/onboarding/session/{sessionId}/complete", sessionId)
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(subscriptionInfo)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data.organizationId").exists();

        // Vérifier que la session est marquée comme terminée
        StepVerifier.create(onboardingSessionRepository.findById(sessionId))
            .expectNextMatches(session1 -> session1.getIsCompleted())
            .verifyComplete();
    }

    @Test
    void getSubscriptionPlans_ShouldReturnAvailablePlans() {
        webTestClient
            .get()
            .uri("/api/v1/onboarding/plans")
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data").exists();
    }

    @Test
    void getSession_WhenSessionExists_ShouldReturnSession() {
        // Créer une session de test
        OnboardingSession testSession = TestDataBuilder.createTestOnboardingSession();
        testSession = onboardingSessionRepository.save(testSession).block();

        webTestClient
            .get()
            .uri("/api/v1/onboarding/session/{sessionId}", testSession.getId())
            .accept(MediaType.APPLICATION_JSON)
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.success").isEqualTo(true)
            .jsonPath("$.data.id").isEqualTo(testSession.getId().toString())
            .jsonPath("$.data.sessionToken").isEqualTo(testSession.getSessionToken());
    }

    @Test
    void saveOwnerInfo_WithInvalidData_ShouldReturnBadRequest() {
        // Créer une session de test
        OnboardingSession testSession = TestDataBuilder.createTestOnboardingSession();
        testSession = onboardingSessionRepository.save(testSession).block();

        // Données invalides (email manquant)
        OwnerInfoRequest invalidOwnerInfo = new OwnerInfoRequest();
        invalidOwnerInfo.setFirstName("John");
        // email manquant

        webTestClient
            .put()
            .uri("/api/v1/onboarding/session/{sessionId}/owner-info", testSession.getId())
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(invalidOwnerInfo)
            .exchange()
            .expectStatus().isBadRequest();
    }

    /**
     * Méthode utilitaire pour extraire l'ID de session depuis une chaîne JSON
     */
    private UUID extractSessionIdFromJsonString(String jsonResponse) {
        try {
            // Approche simple avec regex pour extraire l'ID
            // Pattern pour trouver "id":"uuid-value"
            String pattern = "\"id\":\"([a-f0-9-]{36})\"";
            java.util.regex.Pattern p = java.util.regex.Pattern.compile(pattern);
            java.util.regex.Matcher m = p.matcher(jsonResponse);

            if (m.find()) {
                return UUID.fromString(m.group(1));
            }

            // Si regex échoue, créer une session de test comme fallback
            OnboardingSession testSession = TestDataBuilder.createTestOnboardingSession();
            testSession = onboardingSessionRepository.save(testSession).block();
            return testSession.getId();

        } catch (Exception e) {
            // Fallback : créer une session de test
            OnboardingSession testSession = TestDataBuilder.createTestOnboardingSession();
            testSession = onboardingSessionRepository.save(testSession).block();
            return testSession.getId();
        }
    }

    /**
     * Méthode utilitaire pour extraire l'ID de session depuis une ResponseSpec
     * Note: Cette méthode est simplifiée pour l'exemple
     */
    private UUID extractSessionIdFromResponse(WebTestClient.ResponseSpec responseSpec) {
        // Dans un vrai projet, vous pourriez utiliser Jackson ou une autre approche
        // Pour cet exemple, nous créons une session de test directement
        OnboardingSession testSession = TestDataBuilder.createTestOnboardingSession();
        testSession = onboardingSessionRepository.save(testSession).block();
        return testSession.getId();
    }
}
```
